/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/bootstrap/dist/js/bootstrap.js":
/*!*****************************************************!*\
  !*** ./node_modules/bootstrap/dist/js/bootstrap.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
  * Bootstrap v4.4.1 (https://getbootstrap.com/)
  * Copyright 2011-2019 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
  */
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports, __webpack_require__(/*! jquery */ "jquery"), __webpack_require__(/*! popper.js */ "./node_modules/popper.js/dist/esm/popper.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! jquery */ "jquery"), __webpack_require__(/*! popper.js */ "./node_modules/popper.js/dist/esm/popper.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);
})(this, function (exports, $, Popper) {
  'use strict';

  $ = $ && $.hasOwnProperty('default') ? $['default'] : $;
  Popper = Popper && Popper.hasOwnProperty('default') ? Popper['default'] : Popper;

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.4.1): util.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * ------------------------------------------------------------------------
   * Private TransitionEnd Helpers
   * ------------------------------------------------------------------------
   */


  var TRANSITION_END = 'transitionend';
  var MAX_UID = 1000000;
  var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)

  function toType(obj) {
    return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
  }

  function getSpecialTransitionEndEvent() {
    return {
      bindType: TRANSITION_END,
      delegateType: TRANSITION_END,
      handle: function handle(event) {
        if ($(event.target).is(this)) {
          return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params
        }

        return undefined; // eslint-disable-line no-undefined
      }
    };
  }

  function transitionEndEmulator(duration) {
    var _this = this;

    var called = false;
    $(this).one(Util.TRANSITION_END, function () {
      called = true;
    });
    setTimeout(function () {
      if (!called) {
        Util.triggerTransitionEnd(_this);
      }
    }, duration);
    return this;
  }

  function setTransitionEndSupport() {
    $.fn.emulateTransitionEnd = transitionEndEmulator;
    $.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
  }
  /**
   * --------------------------------------------------------------------------
   * Public Util Api
   * --------------------------------------------------------------------------
   */


  var Util = {
    TRANSITION_END: 'bsTransitionEnd',
    getUID: function getUID(prefix) {
      do {
        // eslint-disable-next-line no-bitwise
        prefix += ~~(Math.random() * MAX_UID); // "~~" acts like a faster Math.floor() here
      } while (document.getElementById(prefix));

      return prefix;
    },
    getSelectorFromElement: function getSelectorFromElement(element) {
      var selector = element.getAttribute('data-target');

      if (!selector || selector === '#') {
        var hrefAttr = element.getAttribute('href');
        selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : '';
      }

      try {
        return document.querySelector(selector) ? selector : null;
      } catch (err) {
        return null;
      }
    },
    getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {
      if (!element) {
        return 0;
      } // Get transition-duration of the element


      var transitionDuration = $(element).css('transition-duration');
      var transitionDelay = $(element).css('transition-delay');
      var floatTransitionDuration = parseFloat(transitionDuration);
      var floatTransitionDelay = parseFloat(transitionDelay); // Return 0 if element or transition duration is not found

      if (!floatTransitionDuration && !floatTransitionDelay) {
        return 0;
      } // If multiple durations are defined, take the first


      transitionDuration = transitionDuration.split(',')[0];
      transitionDelay = transitionDelay.split(',')[0];
      return (parseFloat(transitionDuration) + parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
    },
    reflow: function reflow(element) {
      return element.offsetHeight;
    },
    triggerTransitionEnd: function triggerTransitionEnd(element) {
      $(element).trigger(TRANSITION_END);
    },
    // TODO: Remove in v5
    supportsTransitionEnd: function supportsTransitionEnd() {
      return Boolean(TRANSITION_END);
    },
    isElement: function isElement(obj) {
      return (obj[0] || obj).nodeType;
    },
    typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
      for (var property in configTypes) {
        if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
          var expectedTypes = configTypes[property];
          var value = config[property];
          var valueType = value && Util.isElement(value) ? 'element' : toType(value);

          if (!new RegExp(expectedTypes).test(valueType)) {
            throw new Error(componentName.toUpperCase() + ": " + ("Option \"" + property + "\" provided type \"" + valueType + "\" ") + ("but expected type \"" + expectedTypes + "\"."));
          }
        }
      }
    },
    findShadowRoot: function findShadowRoot(element) {
      if (!document.documentElement.attachShadow) {
        return null;
      } // Can find the shadow root otherwise it'll return the document


      if (typeof element.getRootNode === 'function') {
        var root = element.getRootNode();
        return root instanceof ShadowRoot ? root : null;
      }

      if (element instanceof ShadowRoot) {
        return element;
      } // when we don't find a shadow root


      if (!element.parentNode) {
        return null;
      }

      return Util.findShadowRoot(element.parentNode);
    },
    jQueryDetection: function jQueryDetection() {
      if (typeof $ === 'undefined') {
        throw new TypeError('Bootstrap\'s JavaScript requires jQuery. jQuery must be included before Bootstrap\'s JavaScript.');
      }

      var version = $.fn.jquery.split(' ')[0].split('.');
      var minMajor = 1;
      var ltMajor = 2;
      var minMinor = 9;
      var minPatch = 1;
      var maxMajor = 4;

      if (version[0] < ltMajor && version[1] < minMinor || version[0] === minMajor && version[1] === minMinor && version[2] < minPatch || version[0] >= maxMajor) {
        throw new Error('Bootstrap\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0');
      }
    }
  };
  Util.jQueryDetection();
  setTransitionEndSupport();
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */

  var NAME = 'alert';
  var VERSION = '4.4.1';
  var DATA_KEY = 'bs.alert';
  var EVENT_KEY = "." + DATA_KEY;
  var DATA_API_KEY = '.data-api';
  var JQUERY_NO_CONFLICT = $.fn[NAME];
  var Selector = {
    DISMISS: '[data-dismiss="alert"]'
  };
  var Event = {
    CLOSE: "close" + EVENT_KEY,
    CLOSED: "closed" + EVENT_KEY,
    CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
  };
  var ClassName = {
    ALERT: 'alert',
    FADE: 'fade',
    SHOW: 'show'
  };
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Alert =
  /*#__PURE__*/
  function () {
    function Alert(element) {
      this._element = element;
    } // Getters


    var _proto = Alert.prototype; // Public

    _proto.close = function close(element) {
      var rootElement = this._element;

      if (element) {
        rootElement = this._getRootElement(element);
      }

      var customEvent = this._triggerCloseEvent(rootElement);

      if (customEvent.isDefaultPrevented()) {
        return;
      }

      this._removeElement(rootElement);
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY);
      this._element = null;
    } // Private
    ;

    _proto._getRootElement = function _getRootElement(element) {
      var selector = Util.getSelectorFromElement(element);
      var parent = false;

      if (selector) {
        parent = document.querySelector(selector);
      }

      if (!parent) {
        parent = $(element).closest("." + ClassName.ALERT)[0];
      }

      return parent;
    };

    _proto._triggerCloseEvent = function _triggerCloseEvent(element) {
      var closeEvent = $.Event(Event.CLOSE);
      $(element).trigger(closeEvent);
      return closeEvent;
    };

    _proto._removeElement = function _removeElement(element) {
      var _this = this;

      $(element).removeClass(ClassName.SHOW);

      if (!$(element).hasClass(ClassName.FADE)) {
        this._destroyElement(element);

        return;
      }

      var transitionDuration = Util.getTransitionDurationFromElement(element);
      $(element).one(Util.TRANSITION_END, function (event) {
        return _this._destroyElement(element, event);
      }).emulateTransitionEnd(transitionDuration);
    };

    _proto._destroyElement = function _destroyElement(element) {
      $(element).detach().trigger(Event.CLOSED).remove();
    } // Static
    ;

    Alert._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var $element = $(this);
        var data = $element.data(DATA_KEY);

        if (!data) {
          data = new Alert(this);
          $element.data(DATA_KEY, data);
        }

        if (config === 'close') {
          data[config](this);
        }
      });
    };

    Alert._handleDismiss = function _handleDismiss(alertInstance) {
      return function (event) {
        if (event) {
          event.preventDefault();
        }

        alertInstance.close(this);
      };
    };

    _createClass(Alert, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION;
      }
    }]);

    return Alert;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event.CLICK_DATA_API, Selector.DISMISS, Alert._handleDismiss(new Alert()));
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME] = Alert._jQueryInterface;
  $.fn[NAME].Constructor = Alert;

  $.fn[NAME].noConflict = function () {
    $.fn[NAME] = JQUERY_NO_CONFLICT;
    return Alert._jQueryInterface;
  };
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME$1 = 'button';
  var VERSION$1 = '4.4.1';
  var DATA_KEY$1 = 'bs.button';
  var EVENT_KEY$1 = "." + DATA_KEY$1;
  var DATA_API_KEY$1 = '.data-api';
  var JQUERY_NO_CONFLICT$1 = $.fn[NAME$1];
  var ClassName$1 = {
    ACTIVE: 'active',
    BUTTON: 'btn',
    FOCUS: 'focus'
  };
  var Selector$1 = {
    DATA_TOGGLE_CARROT: '[data-toggle^="button"]',
    DATA_TOGGLES: '[data-toggle="buttons"]',
    DATA_TOGGLE: '[data-toggle="button"]',
    DATA_TOGGLES_BUTTONS: '[data-toggle="buttons"] .btn',
    INPUT: 'input:not([type="hidden"])',
    ACTIVE: '.active',
    BUTTON: '.btn'
  };
  var Event$1 = {
    CLICK_DATA_API: "click" + EVENT_KEY$1 + DATA_API_KEY$1,
    FOCUS_BLUR_DATA_API: "focus" + EVENT_KEY$1 + DATA_API_KEY$1 + " " + ("blur" + EVENT_KEY$1 + DATA_API_KEY$1),
    LOAD_DATA_API: "load" + EVENT_KEY$1 + DATA_API_KEY$1
  };
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Button =
  /*#__PURE__*/
  function () {
    function Button(element) {
      this._element = element;
    } // Getters


    var _proto = Button.prototype; // Public

    _proto.toggle = function toggle() {
      var triggerChangeEvent = true;
      var addAriaPressed = true;
      var rootElement = $(this._element).closest(Selector$1.DATA_TOGGLES)[0];

      if (rootElement) {
        var input = this._element.querySelector(Selector$1.INPUT);

        if (input) {
          if (input.type === 'radio') {
            if (input.checked && this._element.classList.contains(ClassName$1.ACTIVE)) {
              triggerChangeEvent = false;
            } else {
              var activeElement = rootElement.querySelector(Selector$1.ACTIVE);

              if (activeElement) {
                $(activeElement).removeClass(ClassName$1.ACTIVE);
              }
            }
          } else if (input.type === 'checkbox') {
            if (this._element.tagName === 'LABEL' && input.checked === this._element.classList.contains(ClassName$1.ACTIVE)) {
              triggerChangeEvent = false;
            }
          } else {
            // if it's not a radio button or checkbox don't add a pointless/invalid checked property to the input
            triggerChangeEvent = false;
          }

          if (triggerChangeEvent) {
            input.checked = !this._element.classList.contains(ClassName$1.ACTIVE);
            $(input).trigger('change');
          }

          input.focus();
          addAriaPressed = false;
        }
      }

      if (!(this._element.hasAttribute('disabled') || this._element.classList.contains('disabled'))) {
        if (addAriaPressed) {
          this._element.setAttribute('aria-pressed', !this._element.classList.contains(ClassName$1.ACTIVE));
        }

        if (triggerChangeEvent) {
          $(this._element).toggleClass(ClassName$1.ACTIVE);
        }
      }
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY$1);
      this._element = null;
    } // Static
    ;

    Button._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$1);

        if (!data) {
          data = new Button(this);
          $(this).data(DATA_KEY$1, data);
        }

        if (config === 'toggle') {
          data[config]();
        }
      });
    };

    _createClass(Button, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$1;
      }
    }]);

    return Button;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event$1.CLICK_DATA_API, Selector$1.DATA_TOGGLE_CARROT, function (event) {
    var button = event.target;

    if (!$(button).hasClass(ClassName$1.BUTTON)) {
      button = $(button).closest(Selector$1.BUTTON)[0];
    }

    if (!button || button.hasAttribute('disabled') || button.classList.contains('disabled')) {
      event.preventDefault(); // work around Firefox bug #1540995
    } else {
      var inputBtn = button.querySelector(Selector$1.INPUT);

      if (inputBtn && (inputBtn.hasAttribute('disabled') || inputBtn.classList.contains('disabled'))) {
        event.preventDefault(); // work around Firefox bug #1540995

        return;
      }

      Button._jQueryInterface.call($(button), 'toggle');
    }
  }).on(Event$1.FOCUS_BLUR_DATA_API, Selector$1.DATA_TOGGLE_CARROT, function (event) {
    var button = $(event.target).closest(Selector$1.BUTTON)[0];
    $(button).toggleClass(ClassName$1.FOCUS, /^focus(in)?$/.test(event.type));
  });
  $(window).on(Event$1.LOAD_DATA_API, function () {
    // ensure correct active class is set to match the controls' actual values/states
    // find all checkboxes/readio buttons inside data-toggle groups
    var buttons = [].slice.call(document.querySelectorAll(Selector$1.DATA_TOGGLES_BUTTONS));

    for (var i = 0, len = buttons.length; i < len; i++) {
      var button = buttons[i];
      var input = button.querySelector(Selector$1.INPUT);

      if (input.checked || input.hasAttribute('checked')) {
        button.classList.add(ClassName$1.ACTIVE);
      } else {
        button.classList.remove(ClassName$1.ACTIVE);
      }
    } // find all button toggles


    buttons = [].slice.call(document.querySelectorAll(Selector$1.DATA_TOGGLE));

    for (var _i = 0, _len = buttons.length; _i < _len; _i++) {
      var _button = buttons[_i];

      if (_button.getAttribute('aria-pressed') === 'true') {
        _button.classList.add(ClassName$1.ACTIVE);
      } else {
        _button.classList.remove(ClassName$1.ACTIVE);
      }
    }
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME$1] = Button._jQueryInterface;
  $.fn[NAME$1].Constructor = Button;

  $.fn[NAME$1].noConflict = function () {
    $.fn[NAME$1] = JQUERY_NO_CONFLICT$1;
    return Button._jQueryInterface;
  };
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME$2 = 'carousel';
  var VERSION$2 = '4.4.1';
  var DATA_KEY$2 = 'bs.carousel';
  var EVENT_KEY$2 = "." + DATA_KEY$2;
  var DATA_API_KEY$2 = '.data-api';
  var JQUERY_NO_CONFLICT$2 = $.fn[NAME$2];
  var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key

  var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key

  var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch

  var SWIPE_THRESHOLD = 40;
  var Default = {
    interval: 5000,
    keyboard: true,
    slide: false,
    pause: 'hover',
    wrap: true,
    touch: true
  };
  var DefaultType = {
    interval: '(number|boolean)',
    keyboard: 'boolean',
    slide: '(boolean|string)',
    pause: '(string|boolean)',
    wrap: 'boolean',
    touch: 'boolean'
  };
  var Direction = {
    NEXT: 'next',
    PREV: 'prev',
    LEFT: 'left',
    RIGHT: 'right'
  };
  var Event$2 = {
    SLIDE: "slide" + EVENT_KEY$2,
    SLID: "slid" + EVENT_KEY$2,
    KEYDOWN: "keydown" + EVENT_KEY$2,
    MOUSEENTER: "mouseenter" + EVENT_KEY$2,
    MOUSELEAVE: "mouseleave" + EVENT_KEY$2,
    TOUCHSTART: "touchstart" + EVENT_KEY$2,
    TOUCHMOVE: "touchmove" + EVENT_KEY$2,
    TOUCHEND: "touchend" + EVENT_KEY$2,
    POINTERDOWN: "pointerdown" + EVENT_KEY$2,
    POINTERUP: "pointerup" + EVENT_KEY$2,
    DRAG_START: "dragstart" + EVENT_KEY$2,
    LOAD_DATA_API: "load" + EVENT_KEY$2 + DATA_API_KEY$2,
    CLICK_DATA_API: "click" + EVENT_KEY$2 + DATA_API_KEY$2
  };
  var ClassName$2 = {
    CAROUSEL: 'carousel',
    ACTIVE: 'active',
    SLIDE: 'slide',
    RIGHT: 'carousel-item-right',
    LEFT: 'carousel-item-left',
    NEXT: 'carousel-item-next',
    PREV: 'carousel-item-prev',
    ITEM: 'carousel-item',
    POINTER_EVENT: 'pointer-event'
  };
  var Selector$2 = {
    ACTIVE: '.active',
    ACTIVE_ITEM: '.active.carousel-item',
    ITEM: '.carousel-item',
    ITEM_IMG: '.carousel-item img',
    NEXT_PREV: '.carousel-item-next, .carousel-item-prev',
    INDICATORS: '.carousel-indicators',
    DATA_SLIDE: '[data-slide], [data-slide-to]',
    DATA_RIDE: '[data-ride="carousel"]'
  };
  var PointerType = {
    TOUCH: 'touch',
    PEN: 'pen'
  };
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Carousel =
  /*#__PURE__*/
  function () {
    function Carousel(element, config) {
      this._items = null;
      this._interval = null;
      this._activeElement = null;
      this._isPaused = false;
      this._isSliding = false;
      this.touchTimeout = null;
      this.touchStartX = 0;
      this.touchDeltaX = 0;
      this._config = this._getConfig(config);
      this._element = element;
      this._indicatorsElement = this._element.querySelector(Selector$2.INDICATORS);
      this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;
      this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent);

      this._addEventListeners();
    } // Getters


    var _proto = Carousel.prototype; // Public

    _proto.next = function next() {
      if (!this._isSliding) {
        this._slide(Direction.NEXT);
      }
    };

    _proto.nextWhenVisible = function nextWhenVisible() {
      // Don't call next when the page isn't visible
      // or the carousel or its parent isn't visible
      if (!document.hidden && $(this._element).is(':visible') && $(this._element).css('visibility') !== 'hidden') {
        this.next();
      }
    };

    _proto.prev = function prev() {
      if (!this._isSliding) {
        this._slide(Direction.PREV);
      }
    };

    _proto.pause = function pause(event) {
      if (!event) {
        this._isPaused = true;
      }

      if (this._element.querySelector(Selector$2.NEXT_PREV)) {
        Util.triggerTransitionEnd(this._element);
        this.cycle(true);
      }

      clearInterval(this._interval);
      this._interval = null;
    };

    _proto.cycle = function cycle(event) {
      if (!event) {
        this._isPaused = false;
      }

      if (this._interval) {
        clearInterval(this._interval);
        this._interval = null;
      }

      if (this._config.interval && !this._isPaused) {
        this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
      }
    };

    _proto.to = function to(index) {
      var _this = this;

      this._activeElement = this._element.querySelector(Selector$2.ACTIVE_ITEM);

      var activeIndex = this._getItemIndex(this._activeElement);

      if (index > this._items.length - 1 || index < 0) {
        return;
      }

      if (this._isSliding) {
        $(this._element).one(Event$2.SLID, function () {
          return _this.to(index);
        });
        return;
      }

      if (activeIndex === index) {
        this.pause();
        this.cycle();
        return;
      }

      var direction = index > activeIndex ? Direction.NEXT : Direction.PREV;

      this._slide(direction, this._items[index]);
    };

    _proto.dispose = function dispose() {
      $(this._element).off(EVENT_KEY$2);
      $.removeData(this._element, DATA_KEY$2);
      this._items = null;
      this._config = null;
      this._element = null;
      this._interval = null;
      this._isPaused = null;
      this._isSliding = null;
      this._activeElement = null;
      this._indicatorsElement = null;
    } // Private
    ;

    _proto._getConfig = function _getConfig(config) {
      config = _objectSpread2({}, Default, {}, config);
      Util.typeCheckConfig(NAME$2, config, DefaultType);
      return config;
    };

    _proto._handleSwipe = function _handleSwipe() {
      var absDeltax = Math.abs(this.touchDeltaX);

      if (absDeltax <= SWIPE_THRESHOLD) {
        return;
      }

      var direction = absDeltax / this.touchDeltaX;
      this.touchDeltaX = 0; // swipe left

      if (direction > 0) {
        this.prev();
      } // swipe right


      if (direction < 0) {
        this.next();
      }
    };

    _proto._addEventListeners = function _addEventListeners() {
      var _this2 = this;

      if (this._config.keyboard) {
        $(this._element).on(Event$2.KEYDOWN, function (event) {
          return _this2._keydown(event);
        });
      }

      if (this._config.pause === 'hover') {
        $(this._element).on(Event$2.MOUSEENTER, function (event) {
          return _this2.pause(event);
        }).on(Event$2.MOUSELEAVE, function (event) {
          return _this2.cycle(event);
        });
      }

      if (this._config.touch) {
        this._addTouchEventListeners();
      }
    };

    _proto._addTouchEventListeners = function _addTouchEventListeners() {
      var _this3 = this;

      if (!this._touchSupported) {
        return;
      }

      var start = function start(event) {
        if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {
          _this3.touchStartX = event.originalEvent.clientX;
        } else if (!_this3._pointerEvent) {
          _this3.touchStartX = event.originalEvent.touches[0].clientX;
        }
      };

      var move = function move(event) {
        // ensure swiping with one touch and not pinching
        if (event.originalEvent.touches && event.originalEvent.touches.length > 1) {
          _this3.touchDeltaX = 0;
        } else {
          _this3.touchDeltaX = event.originalEvent.touches[0].clientX - _this3.touchStartX;
        }
      };

      var end = function end(event) {
        if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {
          _this3.touchDeltaX = event.originalEvent.clientX - _this3.touchStartX;
        }

        _this3._handleSwipe();

        if (_this3._config.pause === 'hover') {
          // If it's a touch-enabled device, mouseenter/leave are fired as
          // part of the mouse compatibility events on first tap - the carousel
          // would stop cycling until user tapped out of it;
          // here, we listen for touchend, explicitly pause the carousel
          // (as if it's the second time we tap on it, mouseenter compat event
          // is NOT fired) and after a timeout (to allow for mouse compatibility
          // events to fire) we explicitly restart cycling
          _this3.pause();

          if (_this3.touchTimeout) {
            clearTimeout(_this3.touchTimeout);
          }

          _this3.touchTimeout = setTimeout(function (event) {
            return _this3.cycle(event);
          }, TOUCHEVENT_COMPAT_WAIT + _this3._config.interval);
        }
      };

      $(this._element.querySelectorAll(Selector$2.ITEM_IMG)).on(Event$2.DRAG_START, function (e) {
        return e.preventDefault();
      });

      if (this._pointerEvent) {
        $(this._element).on(Event$2.POINTERDOWN, function (event) {
          return start(event);
        });
        $(this._element).on(Event$2.POINTERUP, function (event) {
          return end(event);
        });

        this._element.classList.add(ClassName$2.POINTER_EVENT);
      } else {
        $(this._element).on(Event$2.TOUCHSTART, function (event) {
          return start(event);
        });
        $(this._element).on(Event$2.TOUCHMOVE, function (event) {
          return move(event);
        });
        $(this._element).on(Event$2.TOUCHEND, function (event) {
          return end(event);
        });
      }
    };

    _proto._keydown = function _keydown(event) {
      if (/input|textarea/i.test(event.target.tagName)) {
        return;
      }

      switch (event.which) {
        case ARROW_LEFT_KEYCODE:
          event.preventDefault();
          this.prev();
          break;

        case ARROW_RIGHT_KEYCODE:
          event.preventDefault();
          this.next();
          break;
      }
    };

    _proto._getItemIndex = function _getItemIndex(element) {
      this._items = element && element.parentNode ? [].slice.call(element.parentNode.querySelectorAll(Selector$2.ITEM)) : [];
      return this._items.indexOf(element);
    };

    _proto._getItemByDirection = function _getItemByDirection(direction, activeElement) {
      var isNextDirection = direction === Direction.NEXT;
      var isPrevDirection = direction === Direction.PREV;

      var activeIndex = this._getItemIndex(activeElement);

      var lastItemIndex = this._items.length - 1;
      var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;

      if (isGoingToWrap && !this._config.wrap) {
        return activeElement;
      }

      var delta = direction === Direction.PREV ? -1 : 1;
      var itemIndex = (activeIndex + delta) % this._items.length;
      return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];
    };

    _proto._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {
      var targetIndex = this._getItemIndex(relatedTarget);

      var fromIndex = this._getItemIndex(this._element.querySelector(Selector$2.ACTIVE_ITEM));

      var slideEvent = $.Event(Event$2.SLIDE, {
        relatedTarget: relatedTarget,
        direction: eventDirectionName,
        from: fromIndex,
        to: targetIndex
      });
      $(this._element).trigger(slideEvent);
      return slideEvent;
    };

    _proto._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {
      if (this._indicatorsElement) {
        var indicators = [].slice.call(this._indicatorsElement.querySelectorAll(Selector$2.ACTIVE));
        $(indicators).removeClass(ClassName$2.ACTIVE);

        var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];

        if (nextIndicator) {
          $(nextIndicator).addClass(ClassName$2.ACTIVE);
        }
      }
    };

    _proto._slide = function _slide(direction, element) {
      var _this4 = this;

      var activeElement = this._element.querySelector(Selector$2.ACTIVE_ITEM);

      var activeElementIndex = this._getItemIndex(activeElement);

      var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);

      var nextElementIndex = this._getItemIndex(nextElement);

      var isCycling = Boolean(this._interval);
      var directionalClassName;
      var orderClassName;
      var eventDirectionName;

      if (direction === Direction.NEXT) {
        directionalClassName = ClassName$2.LEFT;
        orderClassName = ClassName$2.NEXT;
        eventDirectionName = Direction.LEFT;
      } else {
        directionalClassName = ClassName$2.RIGHT;
        orderClassName = ClassName$2.PREV;
        eventDirectionName = Direction.RIGHT;
      }

      if (nextElement && $(nextElement).hasClass(ClassName$2.ACTIVE)) {
        this._isSliding = false;
        return;
      }

      var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);

      if (slideEvent.isDefaultPrevented()) {
        return;
      }

      if (!activeElement || !nextElement) {
        // Some weirdness is happening, so we bail
        return;
      }

      this._isSliding = true;

      if (isCycling) {
        this.pause();
      }

      this._setActiveIndicatorElement(nextElement);

      var slidEvent = $.Event(Event$2.SLID, {
        relatedTarget: nextElement,
        direction: eventDirectionName,
        from: activeElementIndex,
        to: nextElementIndex
      });

      if ($(this._element).hasClass(ClassName$2.SLIDE)) {
        $(nextElement).addClass(orderClassName);
        Util.reflow(nextElement);
        $(activeElement).addClass(directionalClassName);
        $(nextElement).addClass(directionalClassName);
        var nextElementInterval = parseInt(nextElement.getAttribute('data-interval'), 10);

        if (nextElementInterval) {
          this._config.defaultInterval = this._config.defaultInterval || this._config.interval;
          this._config.interval = nextElementInterval;
        } else {
          this._config.interval = this._config.defaultInterval || this._config.interval;
        }

        var transitionDuration = Util.getTransitionDurationFromElement(activeElement);
        $(activeElement).one(Util.TRANSITION_END, function () {
          $(nextElement).removeClass(directionalClassName + " " + orderClassName).addClass(ClassName$2.ACTIVE);
          $(activeElement).removeClass(ClassName$2.ACTIVE + " " + orderClassName + " " + directionalClassName);
          _this4._isSliding = false;
          setTimeout(function () {
            return $(_this4._element).trigger(slidEvent);
          }, 0);
        }).emulateTransitionEnd(transitionDuration);
      } else {
        $(activeElement).removeClass(ClassName$2.ACTIVE);
        $(nextElement).addClass(ClassName$2.ACTIVE);
        this._isSliding = false;
        $(this._element).trigger(slidEvent);
      }

      if (isCycling) {
        this.cycle();
      }
    } // Static
    ;

    Carousel._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$2);

        var _config = _objectSpread2({}, Default, {}, $(this).data());

        if (_typeof(config) === 'object') {
          _config = _objectSpread2({}, _config, {}, config);
        }

        var action = typeof config === 'string' ? config : _config.slide;

        if (!data) {
          data = new Carousel(this, _config);
          $(this).data(DATA_KEY$2, data);
        }

        if (typeof config === 'number') {
          data.to(config);
        } else if (typeof action === 'string') {
          if (typeof data[action] === 'undefined') {
            throw new TypeError("No method named \"" + action + "\"");
          }

          data[action]();
        } else if (_config.interval && _config.ride) {
          data.pause();
          data.cycle();
        }
      });
    };

    Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {
      var selector = Util.getSelectorFromElement(this);

      if (!selector) {
        return;
      }

      var target = $(selector)[0];

      if (!target || !$(target).hasClass(ClassName$2.CAROUSEL)) {
        return;
      }

      var config = _objectSpread2({}, $(target).data(), {}, $(this).data());

      var slideIndex = this.getAttribute('data-slide-to');

      if (slideIndex) {
        config.interval = false;
      }

      Carousel._jQueryInterface.call($(target), config);

      if (slideIndex) {
        $(target).data(DATA_KEY$2).to(slideIndex);
      }

      event.preventDefault();
    };

    _createClass(Carousel, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$2;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default;
      }
    }]);

    return Carousel;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event$2.CLICK_DATA_API, Selector$2.DATA_SLIDE, Carousel._dataApiClickHandler);
  $(window).on(Event$2.LOAD_DATA_API, function () {
    var carousels = [].slice.call(document.querySelectorAll(Selector$2.DATA_RIDE));

    for (var i = 0, len = carousels.length; i < len; i++) {
      var $carousel = $(carousels[i]);

      Carousel._jQueryInterface.call($carousel, $carousel.data());
    }
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME$2] = Carousel._jQueryInterface;
  $.fn[NAME$2].Constructor = Carousel;

  $.fn[NAME$2].noConflict = function () {
    $.fn[NAME$2] = JQUERY_NO_CONFLICT$2;
    return Carousel._jQueryInterface;
  };
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME$3 = 'collapse';
  var VERSION$3 = '4.4.1';
  var DATA_KEY$3 = 'bs.collapse';
  var EVENT_KEY$3 = "." + DATA_KEY$3;
  var DATA_API_KEY$3 = '.data-api';
  var JQUERY_NO_CONFLICT$3 = $.fn[NAME$3];
  var Default$1 = {
    toggle: true,
    parent: ''
  };
  var DefaultType$1 = {
    toggle: 'boolean',
    parent: '(string|element)'
  };
  var Event$3 = {
    SHOW: "show" + EVENT_KEY$3,
    SHOWN: "shown" + EVENT_KEY$3,
    HIDE: "hide" + EVENT_KEY$3,
    HIDDEN: "hidden" + EVENT_KEY$3,
    CLICK_DATA_API: "click" + EVENT_KEY$3 + DATA_API_KEY$3
  };
  var ClassName$3 = {
    SHOW: 'show',
    COLLAPSE: 'collapse',
    COLLAPSING: 'collapsing',
    COLLAPSED: 'collapsed'
  };
  var Dimension = {
    WIDTH: 'width',
    HEIGHT: 'height'
  };
  var Selector$3 = {
    ACTIVES: '.show, .collapsing',
    DATA_TOGGLE: '[data-toggle="collapse"]'
  };
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Collapse =
  /*#__PURE__*/
  function () {
    function Collapse(element, config) {
      this._isTransitioning = false;
      this._element = element;
      this._config = this._getConfig(config);
      this._triggerArray = [].slice.call(document.querySelectorAll("[data-toggle=\"collapse\"][href=\"#" + element.id + "\"]," + ("[data-toggle=\"collapse\"][data-target=\"#" + element.id + "\"]")));
      var toggleList = [].slice.call(document.querySelectorAll(Selector$3.DATA_TOGGLE));

      for (var i = 0, len = toggleList.length; i < len; i++) {
        var elem = toggleList[i];
        var selector = Util.getSelectorFromElement(elem);
        var filterElement = [].slice.call(document.querySelectorAll(selector)).filter(function (foundElem) {
          return foundElem === element;
        });

        if (selector !== null && filterElement.length > 0) {
          this._selector = selector;

          this._triggerArray.push(elem);
        }
      }

      this._parent = this._config.parent ? this._getParent() : null;

      if (!this._config.parent) {
        this._addAriaAndCollapsedClass(this._element, this._triggerArray);
      }

      if (this._config.toggle) {
        this.toggle();
      }
    } // Getters


    var _proto = Collapse.prototype; // Public

    _proto.toggle = function toggle() {
      if ($(this._element).hasClass(ClassName$3.SHOW)) {
        this.hide();
      } else {
        this.show();
      }
    };

    _proto.show = function show() {
      var _this = this;

      if (this._isTransitioning || $(this._element).hasClass(ClassName$3.SHOW)) {
        return;
      }

      var actives;
      var activesData;

      if (this._parent) {
        actives = [].slice.call(this._parent.querySelectorAll(Selector$3.ACTIVES)).filter(function (elem) {
          if (typeof _this._config.parent === 'string') {
            return elem.getAttribute('data-parent') === _this._config.parent;
          }

          return elem.classList.contains(ClassName$3.COLLAPSE);
        });

        if (actives.length === 0) {
          actives = null;
        }
      }

      if (actives) {
        activesData = $(actives).not(this._selector).data(DATA_KEY$3);

        if (activesData && activesData._isTransitioning) {
          return;
        }
      }

      var startEvent = $.Event(Event$3.SHOW);
      $(this._element).trigger(startEvent);

      if (startEvent.isDefaultPrevented()) {
        return;
      }

      if (actives) {
        Collapse._jQueryInterface.call($(actives).not(this._selector), 'hide');

        if (!activesData) {
          $(actives).data(DATA_KEY$3, null);
        }
      }

      var dimension = this._getDimension();

      $(this._element).removeClass(ClassName$3.COLLAPSE).addClass(ClassName$3.COLLAPSING);
      this._element.style[dimension] = 0;

      if (this._triggerArray.length) {
        $(this._triggerArray).removeClass(ClassName$3.COLLAPSED).attr('aria-expanded', true);
      }

      this.setTransitioning(true);

      var complete = function complete() {
        $(_this._element).removeClass(ClassName$3.COLLAPSING).addClass(ClassName$3.COLLAPSE).addClass(ClassName$3.SHOW);
        _this._element.style[dimension] = '';

        _this.setTransitioning(false);

        $(_this._element).trigger(Event$3.SHOWN);
      };

      var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
      var scrollSize = "scroll" + capitalizedDimension;
      var transitionDuration = Util.getTransitionDurationFromElement(this._element);
      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      this._element.style[dimension] = this._element[scrollSize] + "px";
    };

    _proto.hide = function hide() {
      var _this2 = this;

      if (this._isTransitioning || !$(this._element).hasClass(ClassName$3.SHOW)) {
        return;
      }

      var startEvent = $.Event(Event$3.HIDE);
      $(this._element).trigger(startEvent);

      if (startEvent.isDefaultPrevented()) {
        return;
      }

      var dimension = this._getDimension();

      this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + "px";
      Util.reflow(this._element);
      $(this._element).addClass(ClassName$3.COLLAPSING).removeClass(ClassName$3.COLLAPSE).removeClass(ClassName$3.SHOW);
      var triggerArrayLength = this._triggerArray.length;

      if (triggerArrayLength > 0) {
        for (var i = 0; i < triggerArrayLength; i++) {
          var trigger = this._triggerArray[i];
          var selector = Util.getSelectorFromElement(trigger);

          if (selector !== null) {
            var $elem = $([].slice.call(document.querySelectorAll(selector)));

            if (!$elem.hasClass(ClassName$3.SHOW)) {
              $(trigger).addClass(ClassName$3.COLLAPSED).attr('aria-expanded', false);
            }
          }
        }
      }

      this.setTransitioning(true);

      var complete = function complete() {
        _this2.setTransitioning(false);

        $(_this2._element).removeClass(ClassName$3.COLLAPSING).addClass(ClassName$3.COLLAPSE).trigger(Event$3.HIDDEN);
      };

      this._element.style[dimension] = '';
      var transitionDuration = Util.getTransitionDurationFromElement(this._element);
      $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
    };

    _proto.setTransitioning = function setTransitioning(isTransitioning) {
      this._isTransitioning = isTransitioning;
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY$3);
      this._config = null;
      this._parent = null;
      this._element = null;
      this._triggerArray = null;
      this._isTransitioning = null;
    } // Private
    ;

    _proto._getConfig = function _getConfig(config) {
      config = _objectSpread2({}, Default$1, {}, config);
      config.toggle = Boolean(config.toggle); // Coerce string values

      Util.typeCheckConfig(NAME$3, config, DefaultType$1);
      return config;
    };

    _proto._getDimension = function _getDimension() {
      var hasWidth = $(this._element).hasClass(Dimension.WIDTH);
      return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;
    };

    _proto._getParent = function _getParent() {
      var _this3 = this;

      var parent;

      if (Util.isElement(this._config.parent)) {
        parent = this._config.parent; // It's a jQuery object

        if (typeof this._config.parent.jquery !== 'undefined') {
          parent = this._config.parent[0];
        }
      } else {
        parent = document.querySelector(this._config.parent);
      }

      var selector = "[data-toggle=\"collapse\"][data-parent=\"" + this._config.parent + "\"]";
      var children = [].slice.call(parent.querySelectorAll(selector));
      $(children).each(function (i, element) {
        _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);
      });
      return parent;
    };

    _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {
      var isOpen = $(element).hasClass(ClassName$3.SHOW);

      if (triggerArray.length) {
        $(triggerArray).toggleClass(ClassName$3.COLLAPSED, !isOpen).attr('aria-expanded', isOpen);
      }
    } // Static
    ;

    Collapse._getTargetFromElement = function _getTargetFromElement(element) {
      var selector = Util.getSelectorFromElement(element);
      return selector ? document.querySelector(selector) : null;
    };

    Collapse._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var $this = $(this);
        var data = $this.data(DATA_KEY$3);

        var _config = _objectSpread2({}, Default$1, {}, $this.data(), {}, _typeof(config) === 'object' && config ? config : {});

        if (!data && _config.toggle && /show|hide/.test(config)) {
          _config.toggle = false;
        }

        if (!data) {
          data = new Collapse(this, _config);
          $this.data(DATA_KEY$3, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    _createClass(Collapse, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$3;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$1;
      }
    }]);

    return Collapse;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event$3.CLICK_DATA_API, Selector$3.DATA_TOGGLE, function (event) {
    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
    if (event.currentTarget.tagName === 'A') {
      event.preventDefault();
    }

    var $trigger = $(this);
    var selector = Util.getSelectorFromElement(this);
    var selectors = [].slice.call(document.querySelectorAll(selector));
    $(selectors).each(function () {
      var $target = $(this);
      var data = $target.data(DATA_KEY$3);
      var config = data ? 'toggle' : $trigger.data();

      Collapse._jQueryInterface.call($target, config);
    });
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME$3] = Collapse._jQueryInterface;
  $.fn[NAME$3].Constructor = Collapse;

  $.fn[NAME$3].noConflict = function () {
    $.fn[NAME$3] = JQUERY_NO_CONFLICT$3;
    return Collapse._jQueryInterface;
  };
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME$4 = 'dropdown';
  var VERSION$4 = '4.4.1';
  var DATA_KEY$4 = 'bs.dropdown';
  var EVENT_KEY$4 = "." + DATA_KEY$4;
  var DATA_API_KEY$4 = '.data-api';
  var JQUERY_NO_CONFLICT$4 = $.fn[NAME$4];
  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key

  var SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key

  var TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key

  var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key

  var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key

  var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)

  var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + "|" + ARROW_DOWN_KEYCODE + "|" + ESCAPE_KEYCODE);
  var Event$4 = {
    HIDE: "hide" + EVENT_KEY$4,
    HIDDEN: "hidden" + EVENT_KEY$4,
    SHOW: "show" + EVENT_KEY$4,
    SHOWN: "shown" + EVENT_KEY$4,
    CLICK: "click" + EVENT_KEY$4,
    CLICK_DATA_API: "click" + EVENT_KEY$4 + DATA_API_KEY$4,
    KEYDOWN_DATA_API: "keydown" + EVENT_KEY$4 + DATA_API_KEY$4,
    KEYUP_DATA_API: "keyup" + EVENT_KEY$4 + DATA_API_KEY$4
  };
  var ClassName$4 = {
    DISABLED: 'disabled',
    SHOW: 'show',
    DROPUP: 'dropup',
    DROPRIGHT: 'dropright',
    DROPLEFT: 'dropleft',
    MENURIGHT: 'dropdown-menu-right',
    MENULEFT: 'dropdown-menu-left',
    POSITION_STATIC: 'position-static'
  };
  var Selector$4 = {
    DATA_TOGGLE: '[data-toggle="dropdown"]',
    FORM_CHILD: '.dropdown form',
    MENU: '.dropdown-menu',
    NAVBAR_NAV: '.navbar-nav',
    VISIBLE_ITEMS: '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)'
  };
  var AttachmentMap = {
    TOP: 'top-start',
    TOPEND: 'top-end',
    BOTTOM: 'bottom-start',
    BOTTOMEND: 'bottom-end',
    RIGHT: 'right-start',
    RIGHTEND: 'right-end',
    LEFT: 'left-start',
    LEFTEND: 'left-end'
  };
  var Default$2 = {
    offset: 0,
    flip: true,
    boundary: 'scrollParent',
    reference: 'toggle',
    display: 'dynamic',
    popperConfig: null
  };
  var DefaultType$2 = {
    offset: '(number|string|function)',
    flip: 'boolean',
    boundary: '(string|element)',
    reference: '(string|element)',
    display: 'string',
    popperConfig: '(null|object)'
  };
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Dropdown =
  /*#__PURE__*/
  function () {
    function Dropdown(element, config) {
      this._element = element;
      this._popper = null;
      this._config = this._getConfig(config);
      this._menu = this._getMenuElement();
      this._inNavbar = this._detectNavbar();

      this._addEventListeners();
    } // Getters


    var _proto = Dropdown.prototype; // Public

    _proto.toggle = function toggle() {
      if (this._element.disabled || $(this._element).hasClass(ClassName$4.DISABLED)) {
        return;
      }

      var isActive = $(this._menu).hasClass(ClassName$4.SHOW);

      Dropdown._clearMenus();

      if (isActive) {
        return;
      }

      this.show(true);
    };

    _proto.show = function show(usePopper) {
      if (usePopper === void 0) {
        usePopper = false;
      }

      if (this._element.disabled || $(this._element).hasClass(ClassName$4.DISABLED) || $(this._menu).hasClass(ClassName$4.SHOW)) {
        return;
      }

      var relatedTarget = {
        relatedTarget: this._element
      };
      var showEvent = $.Event(Event$4.SHOW, relatedTarget);

      var parent = Dropdown._getParentFromElement(this._element);

      $(parent).trigger(showEvent);

      if (showEvent.isDefaultPrevented()) {
        return;
      } // Disable totally Popper.js for Dropdown in Navbar


      if (!this._inNavbar && usePopper) {
        /**
         * Check for Popper dependency
         * Popper - https://popper.js.org
         */
        if (typeof Popper === 'undefined') {
          throw new TypeError('Bootstrap\'s dropdowns require Popper.js (https://popper.js.org/)');
        }

        var referenceElement = this._element;

        if (this._config.reference === 'parent') {
          referenceElement = parent;
        } else if (Util.isElement(this._config.reference)) {
          referenceElement = this._config.reference; // Check if it's jQuery element

          if (typeof this._config.reference.jquery !== 'undefined') {
            referenceElement = this._config.reference[0];
          }
        } // If boundary is not `scrollParent`, then set position to `static`
        // to allow the menu to "escape" the scroll parent's boundaries
        // https://github.com/twbs/bootstrap/issues/24251


        if (this._config.boundary !== 'scrollParent') {
          $(parent).addClass(ClassName$4.POSITION_STATIC);
        }

        this._popper = new Popper(referenceElement, this._menu, this._getPopperConfig());
      } // If this is a touch-enabled device we add extra
      // empty mouseover listeners to the body's immediate children;
      // only needed because of broken event delegation on iOS
      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html


      if ('ontouchstart' in document.documentElement && $(parent).closest(Selector$4.NAVBAR_NAV).length === 0) {
        $(document.body).children().on('mouseover', null, $.noop);
      }

      this._element.focus();

      this._element.setAttribute('aria-expanded', true);

      $(this._menu).toggleClass(ClassName$4.SHOW);
      $(parent).toggleClass(ClassName$4.SHOW).trigger($.Event(Event$4.SHOWN, relatedTarget));
    };

    _proto.hide = function hide() {
      if (this._element.disabled || $(this._element).hasClass(ClassName$4.DISABLED) || !$(this._menu).hasClass(ClassName$4.SHOW)) {
        return;
      }

      var relatedTarget = {
        relatedTarget: this._element
      };
      var hideEvent = $.Event(Event$4.HIDE, relatedTarget);

      var parent = Dropdown._getParentFromElement(this._element);

      $(parent).trigger(hideEvent);

      if (hideEvent.isDefaultPrevented()) {
        return;
      }

      if (this._popper) {
        this._popper.destroy();
      }

      $(this._menu).toggleClass(ClassName$4.SHOW);
      $(parent).toggleClass(ClassName$4.SHOW).trigger($.Event(Event$4.HIDDEN, relatedTarget));
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY$4);
      $(this._element).off(EVENT_KEY$4);
      this._element = null;
      this._menu = null;

      if (this._popper !== null) {
        this._popper.destroy();

        this._popper = null;
      }
    };

    _proto.update = function update() {
      this._inNavbar = this._detectNavbar();

      if (this._popper !== null) {
        this._popper.scheduleUpdate();
      }
    } // Private
    ;

    _proto._addEventListeners = function _addEventListeners() {
      var _this = this;

      $(this._element).on(Event$4.CLICK, function (event) {
        event.preventDefault();
        event.stopPropagation();

        _this.toggle();
      });
    };

    _proto._getConfig = function _getConfig(config) {
      config = _objectSpread2({}, this.constructor.Default, {}, $(this._element).data(), {}, config);
      Util.typeCheckConfig(NAME$4, config, this.constructor.DefaultType);
      return config;
    };

    _proto._getMenuElement = function _getMenuElement() {
      if (!this._menu) {
        var parent = Dropdown._getParentFromElement(this._element);

        if (parent) {
          this._menu = parent.querySelector(Selector$4.MENU);
        }
      }

      return this._menu;
    };

    _proto._getPlacement = function _getPlacement() {
      var $parentDropdown = $(this._element.parentNode);
      var placement = AttachmentMap.BOTTOM; // Handle dropup

      if ($parentDropdown.hasClass(ClassName$4.DROPUP)) {
        placement = AttachmentMap.TOP;

        if ($(this._menu).hasClass(ClassName$4.MENURIGHT)) {
          placement = AttachmentMap.TOPEND;
        }
      } else if ($parentDropdown.hasClass(ClassName$4.DROPRIGHT)) {
        placement = AttachmentMap.RIGHT;
      } else if ($parentDropdown.hasClass(ClassName$4.DROPLEFT)) {
        placement = AttachmentMap.LEFT;
      } else if ($(this._menu).hasClass(ClassName$4.MENURIGHT)) {
        placement = AttachmentMap.BOTTOMEND;
      }

      return placement;
    };

    _proto._detectNavbar = function _detectNavbar() {
      return $(this._element).closest('.navbar').length > 0;
    };

    _proto._getOffset = function _getOffset() {
      var _this2 = this;

      var offset = {};

      if (typeof this._config.offset === 'function') {
        offset.fn = function (data) {
          data.offsets = _objectSpread2({}, data.offsets, {}, _this2._config.offset(data.offsets, _this2._element) || {});
          return data;
        };
      } else {
        offset.offset = this._config.offset;
      }

      return offset;
    };

    _proto._getPopperConfig = function _getPopperConfig() {
      var popperConfig = {
        placement: this._getPlacement(),
        modifiers: {
          offset: this._getOffset(),
          flip: {
            enabled: this._config.flip
          },
          preventOverflow: {
            boundariesElement: this._config.boundary
          }
        }
      }; // Disable Popper.js if we have a static display

      if (this._config.display === 'static') {
        popperConfig.modifiers.applyStyle = {
          enabled: false
        };
      }

      return _objectSpread2({}, popperConfig, {}, this._config.popperConfig);
    } // Static
    ;

    Dropdown._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$4);

        var _config = _typeof(config) === 'object' ? config : null;

        if (!data) {
          data = new Dropdown(this, _config);
          $(this).data(DATA_KEY$4, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    Dropdown._clearMenus = function _clearMenus(event) {
      if (event && (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === 'keyup' && event.which !== TAB_KEYCODE)) {
        return;
      }

      var toggles = [].slice.call(document.querySelectorAll(Selector$4.DATA_TOGGLE));

      for (var i = 0, len = toggles.length; i < len; i++) {
        var parent = Dropdown._getParentFromElement(toggles[i]);

        var context = $(toggles[i]).data(DATA_KEY$4);
        var relatedTarget = {
          relatedTarget: toggles[i]
        };

        if (event && event.type === 'click') {
          relatedTarget.clickEvent = event;
        }

        if (!context) {
          continue;
        }

        var dropdownMenu = context._menu;

        if (!$(parent).hasClass(ClassName$4.SHOW)) {
          continue;
        }

        if (event && (event.type === 'click' && /input|textarea/i.test(event.target.tagName) || event.type === 'keyup' && event.which === TAB_KEYCODE) && $.contains(parent, event.target)) {
          continue;
        }

        var hideEvent = $.Event(Event$4.HIDE, relatedTarget);
        $(parent).trigger(hideEvent);

        if (hideEvent.isDefaultPrevented()) {
          continue;
        } // If this is a touch-enabled device we remove the extra
        // empty mouseover listeners we added for iOS support


        if ('ontouchstart' in document.documentElement) {
          $(document.body).children().off('mouseover', null, $.noop);
        }

        toggles[i].setAttribute('aria-expanded', 'false');

        if (context._popper) {
          context._popper.destroy();
        }

        $(dropdownMenu).removeClass(ClassName$4.SHOW);
        $(parent).removeClass(ClassName$4.SHOW).trigger($.Event(Event$4.HIDDEN, relatedTarget));
      }
    };

    Dropdown._getParentFromElement = function _getParentFromElement(element) {
      var parent;
      var selector = Util.getSelectorFromElement(element);

      if (selector) {
        parent = document.querySelector(selector);
      }

      return parent || element.parentNode;
    } // eslint-disable-next-line complexity
    ;

    Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {
      // If not input/textarea:
      //  - And not a key in REGEXP_KEYDOWN => not a dropdown command
      // If input/textarea:
      //  - If space key => not a dropdown command
      //  - If key is other than escape
      //    - If key is not up or down => not a dropdown command
      //    - If trigger inside the menu => not a dropdown command
      if (/input|textarea/i.test(event.target.tagName) ? event.which === SPACE_KEYCODE || event.which !== ESCAPE_KEYCODE && (event.which !== ARROW_DOWN_KEYCODE && event.which !== ARROW_UP_KEYCODE || $(event.target).closest(Selector$4.MENU).length) : !REGEXP_KEYDOWN.test(event.which)) {
        return;
      }

      event.preventDefault();
      event.stopPropagation();

      if (this.disabled || $(this).hasClass(ClassName$4.DISABLED)) {
        return;
      }

      var parent = Dropdown._getParentFromElement(this);

      var isActive = $(parent).hasClass(ClassName$4.SHOW);

      if (!isActive && event.which === ESCAPE_KEYCODE) {
        return;
      }

      if (!isActive || isActive && (event.which === ESCAPE_KEYCODE || event.which === SPACE_KEYCODE)) {
        if (event.which === ESCAPE_KEYCODE) {
          var toggle = parent.querySelector(Selector$4.DATA_TOGGLE);
          $(toggle).trigger('focus');
        }

        $(this).trigger('click');
        return;
      }

      var items = [].slice.call(parent.querySelectorAll(Selector$4.VISIBLE_ITEMS)).filter(function (item) {
        return $(item).is(':visible');
      });

      if (items.length === 0) {
        return;
      }

      var index = items.indexOf(event.target);

      if (event.which === ARROW_UP_KEYCODE && index > 0) {
        // Up
        index--;
      }

      if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {
        // Down
        index++;
      }

      if (index < 0) {
        index = 0;
      }

      items[index].focus();
    };

    _createClass(Dropdown, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$4;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$2;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$2;
      }
    }]);

    return Dropdown;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event$4.KEYDOWN_DATA_API, Selector$4.DATA_TOGGLE, Dropdown._dataApiKeydownHandler).on(Event$4.KEYDOWN_DATA_API, Selector$4.MENU, Dropdown._dataApiKeydownHandler).on(Event$4.CLICK_DATA_API + " " + Event$4.KEYUP_DATA_API, Dropdown._clearMenus).on(Event$4.CLICK_DATA_API, Selector$4.DATA_TOGGLE, function (event) {
    event.preventDefault();
    event.stopPropagation();

    Dropdown._jQueryInterface.call($(this), 'toggle');
  }).on(Event$4.CLICK_DATA_API, Selector$4.FORM_CHILD, function (e) {
    e.stopPropagation();
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME$4] = Dropdown._jQueryInterface;
  $.fn[NAME$4].Constructor = Dropdown;

  $.fn[NAME$4].noConflict = function () {
    $.fn[NAME$4] = JQUERY_NO_CONFLICT$4;
    return Dropdown._jQueryInterface;
  };
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME$5 = 'modal';
  var VERSION$5 = '4.4.1';
  var DATA_KEY$5 = 'bs.modal';
  var EVENT_KEY$5 = "." + DATA_KEY$5;
  var DATA_API_KEY$5 = '.data-api';
  var JQUERY_NO_CONFLICT$5 = $.fn[NAME$5];
  var ESCAPE_KEYCODE$1 = 27; // KeyboardEvent.which value for Escape (Esc) key

  var Default$3 = {
    backdrop: true,
    keyboard: true,
    focus: true,
    show: true
  };
  var DefaultType$3 = {
    backdrop: '(boolean|string)',
    keyboard: 'boolean',
    focus: 'boolean',
    show: 'boolean'
  };
  var Event$5 = {
    HIDE: "hide" + EVENT_KEY$5,
    HIDE_PREVENTED: "hidePrevented" + EVENT_KEY$5,
    HIDDEN: "hidden" + EVENT_KEY$5,
    SHOW: "show" + EVENT_KEY$5,
    SHOWN: "shown" + EVENT_KEY$5,
    FOCUSIN: "focusin" + EVENT_KEY$5,
    RESIZE: "resize" + EVENT_KEY$5,
    CLICK_DISMISS: "click.dismiss" + EVENT_KEY$5,
    KEYDOWN_DISMISS: "keydown.dismiss" + EVENT_KEY$5,
    MOUSEUP_DISMISS: "mouseup.dismiss" + EVENT_KEY$5,
    MOUSEDOWN_DISMISS: "mousedown.dismiss" + EVENT_KEY$5,
    CLICK_DATA_API: "click" + EVENT_KEY$5 + DATA_API_KEY$5
  };
  var ClassName$5 = {
    SCROLLABLE: 'modal-dialog-scrollable',
    SCROLLBAR_MEASURER: 'modal-scrollbar-measure',
    BACKDROP: 'modal-backdrop',
    OPEN: 'modal-open',
    FADE: 'fade',
    SHOW: 'show',
    STATIC: 'modal-static'
  };
  var Selector$5 = {
    DIALOG: '.modal-dialog',
    MODAL_BODY: '.modal-body',
    DATA_TOGGLE: '[data-toggle="modal"]',
    DATA_DISMISS: '[data-dismiss="modal"]',
    FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',
    STICKY_CONTENT: '.sticky-top'
  };
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Modal =
  /*#__PURE__*/
  function () {
    function Modal(element, config) {
      this._config = this._getConfig(config);
      this._element = element;
      this._dialog = element.querySelector(Selector$5.DIALOG);
      this._backdrop = null;
      this._isShown = false;
      this._isBodyOverflowing = false;
      this._ignoreBackdropClick = false;
      this._isTransitioning = false;
      this._scrollbarWidth = 0;
    } // Getters


    var _proto = Modal.prototype; // Public

    _proto.toggle = function toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    };

    _proto.show = function show(relatedTarget) {
      var _this = this;

      if (this._isShown || this._isTransitioning) {
        return;
      }

      if ($(this._element).hasClass(ClassName$5.FADE)) {
        this._isTransitioning = true;
      }

      var showEvent = $.Event(Event$5.SHOW, {
        relatedTarget: relatedTarget
      });
      $(this._element).trigger(showEvent);

      if (this._isShown || showEvent.isDefaultPrevented()) {
        return;
      }

      this._isShown = true;

      this._checkScrollbar();

      this._setScrollbar();

      this._adjustDialog();

      this._setEscapeEvent();

      this._setResizeEvent();

      $(this._element).on(Event$5.CLICK_DISMISS, Selector$5.DATA_DISMISS, function (event) {
        return _this.hide(event);
      });
      $(this._dialog).on(Event$5.MOUSEDOWN_DISMISS, function () {
        $(_this._element).one(Event$5.MOUSEUP_DISMISS, function (event) {
          if ($(event.target).is(_this._element)) {
            _this._ignoreBackdropClick = true;
          }
        });
      });

      this._showBackdrop(function () {
        return _this._showElement(relatedTarget);
      });
    };

    _proto.hide = function hide(event) {
      var _this2 = this;

      if (event) {
        event.preventDefault();
      }

      if (!this._isShown || this._isTransitioning) {
        return;
      }

      var hideEvent = $.Event(Event$5.HIDE);
      $(this._element).trigger(hideEvent);

      if (!this._isShown || hideEvent.isDefaultPrevented()) {
        return;
      }

      this._isShown = false;
      var transition = $(this._element).hasClass(ClassName$5.FADE);

      if (transition) {
        this._isTransitioning = true;
      }

      this._setEscapeEvent();

      this._setResizeEvent();

      $(document).off(Event$5.FOCUSIN);
      $(this._element).removeClass(ClassName$5.SHOW);
      $(this._element).off(Event$5.CLICK_DISMISS);
      $(this._dialog).off(Event$5.MOUSEDOWN_DISMISS);

      if (transition) {
        var transitionDuration = Util.getTransitionDurationFromElement(this._element);
        $(this._element).one(Util.TRANSITION_END, function (event) {
          return _this2._hideModal(event);
        }).emulateTransitionEnd(transitionDuration);
      } else {
        this._hideModal();
      }
    };

    _proto.dispose = function dispose() {
      [window, this._element, this._dialog].forEach(function (htmlElement) {
        return $(htmlElement).off(EVENT_KEY$5);
      });
      /**
       * `document` has 2 events `Event.FOCUSIN` and `Event.CLICK_DATA_API`
       * Do not move `document` in `htmlElements` array
       * It will remove `Event.CLICK_DATA_API` event that should remain
       */

      $(document).off(Event$5.FOCUSIN);
      $.removeData(this._element, DATA_KEY$5);
      this._config = null;
      this._element = null;
      this._dialog = null;
      this._backdrop = null;
      this._isShown = null;
      this._isBodyOverflowing = null;
      this._ignoreBackdropClick = null;
      this._isTransitioning = null;
      this._scrollbarWidth = null;
    };

    _proto.handleUpdate = function handleUpdate() {
      this._adjustDialog();
    } // Private
    ;

    _proto._getConfig = function _getConfig(config) {
      config = _objectSpread2({}, Default$3, {}, config);
      Util.typeCheckConfig(NAME$5, config, DefaultType$3);
      return config;
    };

    _proto._triggerBackdropTransition = function _triggerBackdropTransition() {
      var _this3 = this;

      if (this._config.backdrop === 'static') {
        var hideEventPrevented = $.Event(Event$5.HIDE_PREVENTED);
        $(this._element).trigger(hideEventPrevented);

        if (hideEventPrevented.defaultPrevented) {
          return;
        }

        this._element.classList.add(ClassName$5.STATIC);

        var modalTransitionDuration = Util.getTransitionDurationFromElement(this._element);
        $(this._element).one(Util.TRANSITION_END, function () {
          _this3._element.classList.remove(ClassName$5.STATIC);
        }).emulateTransitionEnd(modalTransitionDuration);

        this._element.focus();
      } else {
        this.hide();
      }
    };

    _proto._showElement = function _showElement(relatedTarget) {
      var _this4 = this;

      var transition = $(this._element).hasClass(ClassName$5.FADE);
      var modalBody = this._dialog ? this._dialog.querySelector(Selector$5.MODAL_BODY) : null;

      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
        // Don't move modal's DOM position
        document.body.appendChild(this._element);
      }

      this._element.style.display = 'block';

      this._element.removeAttribute('aria-hidden');

      this._element.setAttribute('aria-modal', true);

      if ($(this._dialog).hasClass(ClassName$5.SCROLLABLE) && modalBody) {
        modalBody.scrollTop = 0;
      } else {
        this._element.scrollTop = 0;
      }

      if (transition) {
        Util.reflow(this._element);
      }

      $(this._element).addClass(ClassName$5.SHOW);

      if (this._config.focus) {
        this._enforceFocus();
      }

      var shownEvent = $.Event(Event$5.SHOWN, {
        relatedTarget: relatedTarget
      });

      var transitionComplete = function transitionComplete() {
        if (_this4._config.focus) {
          _this4._element.focus();
        }

        _this4._isTransitioning = false;
        $(_this4._element).trigger(shownEvent);
      };

      if (transition) {
        var transitionDuration = Util.getTransitionDurationFromElement(this._dialog);
        $(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);
      } else {
        transitionComplete();
      }
    };

    _proto._enforceFocus = function _enforceFocus() {
      var _this5 = this;

      $(document).off(Event$5.FOCUSIN) // Guard against infinite focus loop
      .on(Event$5.FOCUSIN, function (event) {
        if (document !== event.target && _this5._element !== event.target && $(_this5._element).has(event.target).length === 0) {
          _this5._element.focus();
        }
      });
    };

    _proto._setEscapeEvent = function _setEscapeEvent() {
      var _this6 = this;

      if (this._isShown && this._config.keyboard) {
        $(this._element).on(Event$5.KEYDOWN_DISMISS, function (event) {
          if (event.which === ESCAPE_KEYCODE$1) {
            _this6._triggerBackdropTransition();
          }
        });
      } else if (!this._isShown) {
        $(this._element).off(Event$5.KEYDOWN_DISMISS);
      }
    };

    _proto._setResizeEvent = function _setResizeEvent() {
      var _this7 = this;

      if (this._isShown) {
        $(window).on(Event$5.RESIZE, function (event) {
          return _this7.handleUpdate(event);
        });
      } else {
        $(window).off(Event$5.RESIZE);
      }
    };

    _proto._hideModal = function _hideModal() {
      var _this8 = this;

      this._element.style.display = 'none';

      this._element.setAttribute('aria-hidden', true);

      this._element.removeAttribute('aria-modal');

      this._isTransitioning = false;

      this._showBackdrop(function () {
        $(document.body).removeClass(ClassName$5.OPEN);

        _this8._resetAdjustments();

        _this8._resetScrollbar();

        $(_this8._element).trigger(Event$5.HIDDEN);
      });
    };

    _proto._removeBackdrop = function _removeBackdrop() {
      if (this._backdrop) {
        $(this._backdrop).remove();
        this._backdrop = null;
      }
    };

    _proto._showBackdrop = function _showBackdrop(callback) {
      var _this9 = this;

      var animate = $(this._element).hasClass(ClassName$5.FADE) ? ClassName$5.FADE : '';

      if (this._isShown && this._config.backdrop) {
        this._backdrop = document.createElement('div');
        this._backdrop.className = ClassName$5.BACKDROP;

        if (animate) {
          this._backdrop.classList.add(animate);
        }

        $(this._backdrop).appendTo(document.body);
        $(this._element).on(Event$5.CLICK_DISMISS, function (event) {
          if (_this9._ignoreBackdropClick) {
            _this9._ignoreBackdropClick = false;
            return;
          }

          if (event.target !== event.currentTarget) {
            return;
          }

          _this9._triggerBackdropTransition();
        });

        if (animate) {
          Util.reflow(this._backdrop);
        }

        $(this._backdrop).addClass(ClassName$5.SHOW);

        if (!callback) {
          return;
        }

        if (!animate) {
          callback();
          return;
        }

        var backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);
        $(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);
      } else if (!this._isShown && this._backdrop) {
        $(this._backdrop).removeClass(ClassName$5.SHOW);

        var callbackRemove = function callbackRemove() {
          _this9._removeBackdrop();

          if (callback) {
            callback();
          }
        };

        if ($(this._element).hasClass(ClassName$5.FADE)) {
          var _backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);

          $(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);
        } else {
          callbackRemove();
        }
      } else if (callback) {
        callback();
      }
    } // ----------------------------------------------------------------------
    // the following methods are used to handle overflowing modals
    // todo (fat): these should probably be refactored out of modal.js
    // ----------------------------------------------------------------------
    ;

    _proto._adjustDialog = function _adjustDialog() {
      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;

      if (!this._isBodyOverflowing && isModalOverflowing) {
        this._element.style.paddingLeft = this._scrollbarWidth + "px";
      }

      if (this._isBodyOverflowing && !isModalOverflowing) {
        this._element.style.paddingRight = this._scrollbarWidth + "px";
      }
    };

    _proto._resetAdjustments = function _resetAdjustments() {
      this._element.style.paddingLeft = '';
      this._element.style.paddingRight = '';
    };

    _proto._checkScrollbar = function _checkScrollbar() {
      var rect = document.body.getBoundingClientRect();
      this._isBodyOverflowing = rect.left + rect.right < window.innerWidth;
      this._scrollbarWidth = this._getScrollbarWidth();
    };

    _proto._setScrollbar = function _setScrollbar() {
      var _this10 = this;

      if (this._isBodyOverflowing) {
        // Note: DOMNode.style.paddingRight returns the actual value or '' if not set
        //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set
        var fixedContent = [].slice.call(document.querySelectorAll(Selector$5.FIXED_CONTENT));
        var stickyContent = [].slice.call(document.querySelectorAll(Selector$5.STICKY_CONTENT)); // Adjust fixed content padding

        $(fixedContent).each(function (index, element) {
          var actualPadding = element.style.paddingRight;
          var calculatedPadding = $(element).css('padding-right');
          $(element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + _this10._scrollbarWidth + "px");
        }); // Adjust sticky content margin

        $(stickyContent).each(function (index, element) {
          var actualMargin = element.style.marginRight;
          var calculatedMargin = $(element).css('margin-right');
          $(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) - _this10._scrollbarWidth + "px");
        }); // Adjust body padding

        var actualPadding = document.body.style.paddingRight;
        var calculatedPadding = $(document.body).css('padding-right');
        $(document.body).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + this._scrollbarWidth + "px");
      }

      $(document.body).addClass(ClassName$5.OPEN);
    };

    _proto._resetScrollbar = function _resetScrollbar() {
      // Restore fixed content padding
      var fixedContent = [].slice.call(document.querySelectorAll(Selector$5.FIXED_CONTENT));
      $(fixedContent).each(function (index, element) {
        var padding = $(element).data('padding-right');
        $(element).removeData('padding-right');
        element.style.paddingRight = padding ? padding : '';
      }); // Restore sticky content

      var elements = [].slice.call(document.querySelectorAll("" + Selector$5.STICKY_CONTENT));
      $(elements).each(function (index, element) {
        var margin = $(element).data('margin-right');

        if (typeof margin !== 'undefined') {
          $(element).css('margin-right', margin).removeData('margin-right');
        }
      }); // Restore body padding

      var padding = $(document.body).data('padding-right');
      $(document.body).removeData('padding-right');
      document.body.style.paddingRight = padding ? padding : '';
    };

    _proto._getScrollbarWidth = function _getScrollbarWidth() {
      // thx d.walsh
      var scrollDiv = document.createElement('div');
      scrollDiv.className = ClassName$5.SCROLLBAR_MEASURER;
      document.body.appendChild(scrollDiv);
      var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
      document.body.removeChild(scrollDiv);
      return scrollbarWidth;
    } // Static
    ;

    Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$5);

        var _config = _objectSpread2({}, Default$3, {}, $(this).data(), {}, _typeof(config) === 'object' && config ? config : {});

        if (!data) {
          data = new Modal(this, _config);
          $(this).data(DATA_KEY$5, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config](relatedTarget);
        } else if (_config.show) {
          data.show(relatedTarget);
        }
      });
    };

    _createClass(Modal, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$5;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$3;
      }
    }]);

    return Modal;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event$5.CLICK_DATA_API, Selector$5.DATA_TOGGLE, function (event) {
    var _this11 = this;

    var target;
    var selector = Util.getSelectorFromElement(this);

    if (selector) {
      target = document.querySelector(selector);
    }

    var config = $(target).data(DATA_KEY$5) ? 'toggle' : _objectSpread2({}, $(target).data(), {}, $(this).data());

    if (this.tagName === 'A' || this.tagName === 'AREA') {
      event.preventDefault();
    }

    var $target = $(target).one(Event$5.SHOW, function (showEvent) {
      if (showEvent.isDefaultPrevented()) {
        // Only register focus restorer if modal will actually get shown
        return;
      }

      $target.one(Event$5.HIDDEN, function () {
        if ($(_this11).is(':visible')) {
          _this11.focus();
        }
      });
    });

    Modal._jQueryInterface.call($(target), config, this);
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME$5] = Modal._jQueryInterface;
  $.fn[NAME$5].Constructor = Modal;

  $.fn[NAME$5].noConflict = function () {
    $.fn[NAME$5] = JQUERY_NO_CONFLICT$5;
    return Modal._jQueryInterface;
  };
  /**
   * --------------------------------------------------------------------------
   * Bootstrap (v4.4.1): tools/sanitizer.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
   * --------------------------------------------------------------------------
   */


  var uriAttrs = ['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href'];
  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
  var DefaultWhitelist = {
    // Global attributes allowed on any supplied element below.
    '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],
    a: ['target', 'href', 'title', 'rel'],
    area: [],
    b: [],
    br: [],
    col: [],
    code: [],
    div: [],
    em: [],
    hr: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    i: [],
    img: ['src', 'alt', 'title', 'width', 'height'],
    li: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    u: [],
    ul: []
  };
  /**
   * A pattern that recognizes a commonly useful subset of URLs that are safe.
   *
   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
   */

  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
  /**
   * A pattern that matches safe data URLs. Only matches image, video and audio types.
   *
   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
   */

  var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i;

  function allowedAttribute(attr, allowedAttributeList) {
    var attrName = attr.nodeName.toLowerCase();

    if (allowedAttributeList.indexOf(attrName) !== -1) {
      if (uriAttrs.indexOf(attrName) !== -1) {
        return Boolean(attr.nodeValue.match(SAFE_URL_PATTERN) || attr.nodeValue.match(DATA_URL_PATTERN));
      }

      return true;
    }

    var regExp = allowedAttributeList.filter(function (attrRegex) {
      return attrRegex instanceof RegExp;
    }); // Check if a regular expression validates the attribute.

    for (var i = 0, l = regExp.length; i < l; i++) {
      if (attrName.match(regExp[i])) {
        return true;
      }
    }

    return false;
  }

  function sanitizeHtml(unsafeHtml, whiteList, sanitizeFn) {
    if (unsafeHtml.length === 0) {
      return unsafeHtml;
    }

    if (sanitizeFn && typeof sanitizeFn === 'function') {
      return sanitizeFn(unsafeHtml);
    }

    var domParser = new window.DOMParser();
    var createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');
    var whitelistKeys = Object.keys(whiteList);
    var elements = [].slice.call(createdDocument.body.querySelectorAll('*'));

    var _loop = function _loop(i, len) {
      var el = elements[i];
      var elName = el.nodeName.toLowerCase();

      if (whitelistKeys.indexOf(el.nodeName.toLowerCase()) === -1) {
        el.parentNode.removeChild(el);
        return "continue";
      }

      var attributeList = [].slice.call(el.attributes);
      var whitelistedAttributes = [].concat(whiteList['*'] || [], whiteList[elName] || []);
      attributeList.forEach(function (attr) {
        if (!allowedAttribute(attr, whitelistedAttributes)) {
          el.removeAttribute(attr.nodeName);
        }
      });
    };

    for (var i = 0, len = elements.length; i < len; i++) {
      var _ret = _loop(i);

      if (_ret === "continue") continue;
    }

    return createdDocument.body.innerHTML;
  }
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME$6 = 'tooltip';
  var VERSION$6 = '4.4.1';
  var DATA_KEY$6 = 'bs.tooltip';
  var EVENT_KEY$6 = "." + DATA_KEY$6;
  var JQUERY_NO_CONFLICT$6 = $.fn[NAME$6];
  var CLASS_PREFIX = 'bs-tooltip';
  var BSCLS_PREFIX_REGEX = new RegExp("(^|\\s)" + CLASS_PREFIX + "\\S+", 'g');
  var DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn'];
  var DefaultType$4 = {
    animation: 'boolean',
    template: 'string',
    title: '(string|element|function)',
    trigger: 'string',
    delay: '(number|object)',
    html: 'boolean',
    selector: '(string|boolean)',
    placement: '(string|function)',
    offset: '(number|string|function)',
    container: '(string|element|boolean)',
    fallbackPlacement: '(string|array)',
    boundary: '(string|element)',
    sanitize: 'boolean',
    sanitizeFn: '(null|function)',
    whiteList: 'object',
    popperConfig: '(null|object)'
  };
  var AttachmentMap$1 = {
    AUTO: 'auto',
    TOP: 'top',
    RIGHT: 'right',
    BOTTOM: 'bottom',
    LEFT: 'left'
  };
  var Default$4 = {
    animation: true,
    template: '<div class="tooltip" role="tooltip">' + '<div class="arrow"></div>' + '<div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    selector: false,
    placement: 'top',
    offset: 0,
    container: false,
    fallbackPlacement: 'flip',
    boundary: 'scrollParent',
    sanitize: true,
    sanitizeFn: null,
    whiteList: DefaultWhitelist,
    popperConfig: null
  };
  var HoverState = {
    SHOW: 'show',
    OUT: 'out'
  };
  var Event$6 = {
    HIDE: "hide" + EVENT_KEY$6,
    HIDDEN: "hidden" + EVENT_KEY$6,
    SHOW: "show" + EVENT_KEY$6,
    SHOWN: "shown" + EVENT_KEY$6,
    INSERTED: "inserted" + EVENT_KEY$6,
    CLICK: "click" + EVENT_KEY$6,
    FOCUSIN: "focusin" + EVENT_KEY$6,
    FOCUSOUT: "focusout" + EVENT_KEY$6,
    MOUSEENTER: "mouseenter" + EVENT_KEY$6,
    MOUSELEAVE: "mouseleave" + EVENT_KEY$6
  };
  var ClassName$6 = {
    FADE: 'fade',
    SHOW: 'show'
  };
  var Selector$6 = {
    TOOLTIP: '.tooltip',
    TOOLTIP_INNER: '.tooltip-inner',
    ARROW: '.arrow'
  };
  var Trigger = {
    HOVER: 'hover',
    FOCUS: 'focus',
    CLICK: 'click',
    MANUAL: 'manual'
  };
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Tooltip =
  /*#__PURE__*/
  function () {
    function Tooltip(element, config) {
      if (typeof Popper === 'undefined') {
        throw new TypeError('Bootstrap\'s tooltips require Popper.js (https://popper.js.org/)');
      } // private


      this._isEnabled = true;
      this._timeout = 0;
      this._hoverState = '';
      this._activeTrigger = {};
      this._popper = null; // Protected

      this.element = element;
      this.config = this._getConfig(config);
      this.tip = null;

      this._setListeners();
    } // Getters


    var _proto = Tooltip.prototype; // Public

    _proto.enable = function enable() {
      this._isEnabled = true;
    };

    _proto.disable = function disable() {
      this._isEnabled = false;
    };

    _proto.toggleEnabled = function toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    };

    _proto.toggle = function toggle(event) {
      if (!this._isEnabled) {
        return;
      }

      if (event) {
        var dataKey = this.constructor.DATA_KEY;
        var context = $(event.currentTarget).data(dataKey);

        if (!context) {
          context = new this.constructor(event.currentTarget, this._getDelegateConfig());
          $(event.currentTarget).data(dataKey, context);
        }

        context._activeTrigger.click = !context._activeTrigger.click;

        if (context._isWithActiveTrigger()) {
          context._enter(null, context);
        } else {
          context._leave(null, context);
        }
      } else {
        if ($(this.getTipElement()).hasClass(ClassName$6.SHOW)) {
          this._leave(null, this);

          return;
        }

        this._enter(null, this);
      }
    };

    _proto.dispose = function dispose() {
      clearTimeout(this._timeout);
      $.removeData(this.element, this.constructor.DATA_KEY);
      $(this.element).off(this.constructor.EVENT_KEY);
      $(this.element).closest('.modal').off('hide.bs.modal', this._hideModalHandler);

      if (this.tip) {
        $(this.tip).remove();
      }

      this._isEnabled = null;
      this._timeout = null;
      this._hoverState = null;
      this._activeTrigger = null;

      if (this._popper) {
        this._popper.destroy();
      }

      this._popper = null;
      this.element = null;
      this.config = null;
      this.tip = null;
    };

    _proto.show = function show() {
      var _this = this;

      if ($(this.element).css('display') === 'none') {
        throw new Error('Please use show on visible elements');
      }

      var showEvent = $.Event(this.constructor.Event.SHOW);

      if (this.isWithContent() && this._isEnabled) {
        $(this.element).trigger(showEvent);
        var shadowRoot = Util.findShadowRoot(this.element);
        var isInTheDom = $.contains(shadowRoot !== null ? shadowRoot : this.element.ownerDocument.documentElement, this.element);

        if (showEvent.isDefaultPrevented() || !isInTheDom) {
          return;
        }

        var tip = this.getTipElement();
        var tipId = Util.getUID(this.constructor.NAME);
        tip.setAttribute('id', tipId);
        this.element.setAttribute('aria-describedby', tipId);
        this.setContent();

        if (this.config.animation) {
          $(tip).addClass(ClassName$6.FADE);
        }

        var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;

        var attachment = this._getAttachment(placement);

        this.addAttachmentClass(attachment);

        var container = this._getContainer();

        $(tip).data(this.constructor.DATA_KEY, this);

        if (!$.contains(this.element.ownerDocument.documentElement, this.tip)) {
          $(tip).appendTo(container);
        }

        $(this.element).trigger(this.constructor.Event.INSERTED);
        this._popper = new Popper(this.element, tip, this._getPopperConfig(attachment));
        $(tip).addClass(ClassName$6.SHOW); // If this is a touch-enabled device we add extra
        // empty mouseover listeners to the body's immediate children;
        // only needed because of broken event delegation on iOS
        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html

        if ('ontouchstart' in document.documentElement) {
          $(document.body).children().on('mouseover', null, $.noop);
        }

        var complete = function complete() {
          if (_this.config.animation) {
            _this._fixTransition();
          }

          var prevHoverState = _this._hoverState;
          _this._hoverState = null;
          $(_this.element).trigger(_this.constructor.Event.SHOWN);

          if (prevHoverState === HoverState.OUT) {
            _this._leave(null, _this);
          }
        };

        if ($(this.tip).hasClass(ClassName$6.FADE)) {
          var transitionDuration = Util.getTransitionDurationFromElement(this.tip);
          $(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
        } else {
          complete();
        }
      }
    };

    _proto.hide = function hide(callback) {
      var _this2 = this;

      var tip = this.getTipElement();
      var hideEvent = $.Event(this.constructor.Event.HIDE);

      var complete = function complete() {
        if (_this2._hoverState !== HoverState.SHOW && tip.parentNode) {
          tip.parentNode.removeChild(tip);
        }

        _this2._cleanTipClass();

        _this2.element.removeAttribute('aria-describedby');

        $(_this2.element).trigger(_this2.constructor.Event.HIDDEN);

        if (_this2._popper !== null) {
          _this2._popper.destroy();
        }

        if (callback) {
          callback();
        }
      };

      $(this.element).trigger(hideEvent);

      if (hideEvent.isDefaultPrevented()) {
        return;
      }

      $(tip).removeClass(ClassName$6.SHOW); // If this is a touch-enabled device we remove the extra
      // empty mouseover listeners we added for iOS support

      if ('ontouchstart' in document.documentElement) {
        $(document.body).children().off('mouseover', null, $.noop);
      }

      this._activeTrigger[Trigger.CLICK] = false;
      this._activeTrigger[Trigger.FOCUS] = false;
      this._activeTrigger[Trigger.HOVER] = false;

      if ($(this.tip).hasClass(ClassName$6.FADE)) {
        var transitionDuration = Util.getTransitionDurationFromElement(tip);
        $(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      } else {
        complete();
      }

      this._hoverState = '';
    };

    _proto.update = function update() {
      if (this._popper !== null) {
        this._popper.scheduleUpdate();
      }
    } // Protected
    ;

    _proto.isWithContent = function isWithContent() {
      return Boolean(this.getTitle());
    };

    _proto.addAttachmentClass = function addAttachmentClass(attachment) {
      $(this.getTipElement()).addClass(CLASS_PREFIX + "-" + attachment);
    };

    _proto.getTipElement = function getTipElement() {
      this.tip = this.tip || $(this.config.template)[0];
      return this.tip;
    };

    _proto.setContent = function setContent() {
      var tip = this.getTipElement();
      this.setElementContent($(tip.querySelectorAll(Selector$6.TOOLTIP_INNER)), this.getTitle());
      $(tip).removeClass(ClassName$6.FADE + " " + ClassName$6.SHOW);
    };

    _proto.setElementContent = function setElementContent($element, content) {
      if (_typeof(content) === 'object' && (content.nodeType || content.jquery)) {
        // Content is a DOM node or a jQuery
        if (this.config.html) {
          if (!$(content).parent().is($element)) {
            $element.empty().append(content);
          }
        } else {
          $element.text($(content).text());
        }

        return;
      }

      if (this.config.html) {
        if (this.config.sanitize) {
          content = sanitizeHtml(content, this.config.whiteList, this.config.sanitizeFn);
        }

        $element.html(content);
      } else {
        $element.text(content);
      }
    };

    _proto.getTitle = function getTitle() {
      var title = this.element.getAttribute('data-original-title');

      if (!title) {
        title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;
      }

      return title;
    } // Private
    ;

    _proto._getPopperConfig = function _getPopperConfig(attachment) {
      var _this3 = this;

      var defaultBsConfig = {
        placement: attachment,
        modifiers: {
          offset: this._getOffset(),
          flip: {
            behavior: this.config.fallbackPlacement
          },
          arrow: {
            element: Selector$6.ARROW
          },
          preventOverflow: {
            boundariesElement: this.config.boundary
          }
        },
        onCreate: function onCreate(data) {
          if (data.originalPlacement !== data.placement) {
            _this3._handlePopperPlacementChange(data);
          }
        },
        onUpdate: function onUpdate(data) {
          return _this3._handlePopperPlacementChange(data);
        }
      };
      return _objectSpread2({}, defaultBsConfig, {}, this.config.popperConfig);
    };

    _proto._getOffset = function _getOffset() {
      var _this4 = this;

      var offset = {};

      if (typeof this.config.offset === 'function') {
        offset.fn = function (data) {
          data.offsets = _objectSpread2({}, data.offsets, {}, _this4.config.offset(data.offsets, _this4.element) || {});
          return data;
        };
      } else {
        offset.offset = this.config.offset;
      }

      return offset;
    };

    _proto._getContainer = function _getContainer() {
      if (this.config.container === false) {
        return document.body;
      }

      if (Util.isElement(this.config.container)) {
        return $(this.config.container);
      }

      return $(document).find(this.config.container);
    };

    _proto._getAttachment = function _getAttachment(placement) {
      return AttachmentMap$1[placement.toUpperCase()];
    };

    _proto._setListeners = function _setListeners() {
      var _this5 = this;

      var triggers = this.config.trigger.split(' ');
      triggers.forEach(function (trigger) {
        if (trigger === 'click') {
          $(_this5.element).on(_this5.constructor.Event.CLICK, _this5.config.selector, function (event) {
            return _this5.toggle(event);
          });
        } else if (trigger !== Trigger.MANUAL) {
          var eventIn = trigger === Trigger.HOVER ? _this5.constructor.Event.MOUSEENTER : _this5.constructor.Event.FOCUSIN;
          var eventOut = trigger === Trigger.HOVER ? _this5.constructor.Event.MOUSELEAVE : _this5.constructor.Event.FOCUSOUT;
          $(_this5.element).on(eventIn, _this5.config.selector, function (event) {
            return _this5._enter(event);
          }).on(eventOut, _this5.config.selector, function (event) {
            return _this5._leave(event);
          });
        }
      });

      this._hideModalHandler = function () {
        if (_this5.element) {
          _this5.hide();
        }
      };

      $(this.element).closest('.modal').on('hide.bs.modal', this._hideModalHandler);

      if (this.config.selector) {
        this.config = _objectSpread2({}, this.config, {
          trigger: 'manual',
          selector: ''
        });
      } else {
        this._fixTitle();
      }
    };

    _proto._fixTitle = function _fixTitle() {
      var titleType = _typeof(this.element.getAttribute('data-original-title'));

      if (this.element.getAttribute('title') || titleType !== 'string') {
        this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');
        this.element.setAttribute('title', '');
      }
    };

    _proto._enter = function _enter(event, context) {
      var dataKey = this.constructor.DATA_KEY;
      context = context || $(event.currentTarget).data(dataKey);

      if (!context) {
        context = new this.constructor(event.currentTarget, this._getDelegateConfig());
        $(event.currentTarget).data(dataKey, context);
      }

      if (event) {
        context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;
      }

      if ($(context.getTipElement()).hasClass(ClassName$6.SHOW) || context._hoverState === HoverState.SHOW) {
        context._hoverState = HoverState.SHOW;
        return;
      }

      clearTimeout(context._timeout);
      context._hoverState = HoverState.SHOW;

      if (!context.config.delay || !context.config.delay.show) {
        context.show();
        return;
      }

      context._timeout = setTimeout(function () {
        if (context._hoverState === HoverState.SHOW) {
          context.show();
        }
      }, context.config.delay.show);
    };

    _proto._leave = function _leave(event, context) {
      var dataKey = this.constructor.DATA_KEY;
      context = context || $(event.currentTarget).data(dataKey);

      if (!context) {
        context = new this.constructor(event.currentTarget, this._getDelegateConfig());
        $(event.currentTarget).data(dataKey, context);
      }

      if (event) {
        context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;
      }

      if (context._isWithActiveTrigger()) {
        return;
      }

      clearTimeout(context._timeout);
      context._hoverState = HoverState.OUT;

      if (!context.config.delay || !context.config.delay.hide) {
        context.hide();
        return;
      }

      context._timeout = setTimeout(function () {
        if (context._hoverState === HoverState.OUT) {
          context.hide();
        }
      }, context.config.delay.hide);
    };

    _proto._isWithActiveTrigger = function _isWithActiveTrigger() {
      for (var trigger in this._activeTrigger) {
        if (this._activeTrigger[trigger]) {
          return true;
        }
      }

      return false;
    };

    _proto._getConfig = function _getConfig(config) {
      var dataAttributes = $(this.element).data();
      Object.keys(dataAttributes).forEach(function (dataAttr) {
        if (DISALLOWED_ATTRIBUTES.indexOf(dataAttr) !== -1) {
          delete dataAttributes[dataAttr];
        }
      });
      config = _objectSpread2({}, this.constructor.Default, {}, dataAttributes, {}, _typeof(config) === 'object' && config ? config : {});

      if (typeof config.delay === 'number') {
        config.delay = {
          show: config.delay,
          hide: config.delay
        };
      }

      if (typeof config.title === 'number') {
        config.title = config.title.toString();
      }

      if (typeof config.content === 'number') {
        config.content = config.content.toString();
      }

      Util.typeCheckConfig(NAME$6, config, this.constructor.DefaultType);

      if (config.sanitize) {
        config.template = sanitizeHtml(config.template, config.whiteList, config.sanitizeFn);
      }

      return config;
    };

    _proto._getDelegateConfig = function _getDelegateConfig() {
      var config = {};

      if (this.config) {
        for (var key in this.config) {
          if (this.constructor.Default[key] !== this.config[key]) {
            config[key] = this.config[key];
          }
        }
      }

      return config;
    };

    _proto._cleanTipClass = function _cleanTipClass() {
      var $tip = $(this.getTipElement());
      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);

      if (tabClass !== null && tabClass.length) {
        $tip.removeClass(tabClass.join(''));
      }
    };

    _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(popperData) {
      var popperInstance = popperData.instance;
      this.tip = popperInstance.popper;

      this._cleanTipClass();

      this.addAttachmentClass(this._getAttachment(popperData.placement));
    };

    _proto._fixTransition = function _fixTransition() {
      var tip = this.getTipElement();
      var initConfigAnimation = this.config.animation;

      if (tip.getAttribute('x-placement') !== null) {
        return;
      }

      $(tip).removeClass(ClassName$6.FADE);
      this.config.animation = false;
      this.hide();
      this.show();
      this.config.animation = initConfigAnimation;
    } // Static
    ;

    Tooltip._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$6);

        var _config = _typeof(config) === 'object' && config;

        if (!data && /dispose|hide/.test(config)) {
          return;
        }

        if (!data) {
          data = new Tooltip(this, _config);
          $(this).data(DATA_KEY$6, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    _createClass(Tooltip, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$6;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$4;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME$6;
      }
    }, {
      key: "DATA_KEY",
      get: function get() {
        return DATA_KEY$6;
      }
    }, {
      key: "Event",
      get: function get() {
        return Event$6;
      }
    }, {
      key: "EVENT_KEY",
      get: function get() {
        return EVENT_KEY$6;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$4;
      }
    }]);

    return Tooltip;
  }();
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */


  $.fn[NAME$6] = Tooltip._jQueryInterface;
  $.fn[NAME$6].Constructor = Tooltip;

  $.fn[NAME$6].noConflict = function () {
    $.fn[NAME$6] = JQUERY_NO_CONFLICT$6;
    return Tooltip._jQueryInterface;
  };
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME$7 = 'popover';
  var VERSION$7 = '4.4.1';
  var DATA_KEY$7 = 'bs.popover';
  var EVENT_KEY$7 = "." + DATA_KEY$7;
  var JQUERY_NO_CONFLICT$7 = $.fn[NAME$7];
  var CLASS_PREFIX$1 = 'bs-popover';
  var BSCLS_PREFIX_REGEX$1 = new RegExp("(^|\\s)" + CLASS_PREFIX$1 + "\\S+", 'g');

  var Default$5 = _objectSpread2({}, Tooltip.Default, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip">' + '<div class="arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div></div>'
  });

  var DefaultType$5 = _objectSpread2({}, Tooltip.DefaultType, {
    content: '(string|element|function)'
  });

  var ClassName$7 = {
    FADE: 'fade',
    SHOW: 'show'
  };
  var Selector$7 = {
    TITLE: '.popover-header',
    CONTENT: '.popover-body'
  };
  var Event$7 = {
    HIDE: "hide" + EVENT_KEY$7,
    HIDDEN: "hidden" + EVENT_KEY$7,
    SHOW: "show" + EVENT_KEY$7,
    SHOWN: "shown" + EVENT_KEY$7,
    INSERTED: "inserted" + EVENT_KEY$7,
    CLICK: "click" + EVENT_KEY$7,
    FOCUSIN: "focusin" + EVENT_KEY$7,
    FOCUSOUT: "focusout" + EVENT_KEY$7,
    MOUSEENTER: "mouseenter" + EVENT_KEY$7,
    MOUSELEAVE: "mouseleave" + EVENT_KEY$7
  };
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Popover =
  /*#__PURE__*/
  function (_Tooltip) {
    _inheritsLoose(Popover, _Tooltip);

    function Popover() {
      return _Tooltip.apply(this, arguments) || this;
    }

    var _proto = Popover.prototype; // Overrides

    _proto.isWithContent = function isWithContent() {
      return this.getTitle() || this._getContent();
    };

    _proto.addAttachmentClass = function addAttachmentClass(attachment) {
      $(this.getTipElement()).addClass(CLASS_PREFIX$1 + "-" + attachment);
    };

    _proto.getTipElement = function getTipElement() {
      this.tip = this.tip || $(this.config.template)[0];
      return this.tip;
    };

    _proto.setContent = function setContent() {
      var $tip = $(this.getTipElement()); // We use append for html objects to maintain js events

      this.setElementContent($tip.find(Selector$7.TITLE), this.getTitle());

      var content = this._getContent();

      if (typeof content === 'function') {
        content = content.call(this.element);
      }

      this.setElementContent($tip.find(Selector$7.CONTENT), content);
      $tip.removeClass(ClassName$7.FADE + " " + ClassName$7.SHOW);
    } // Private
    ;

    _proto._getContent = function _getContent() {
      return this.element.getAttribute('data-content') || this.config.content;
    };

    _proto._cleanTipClass = function _cleanTipClass() {
      var $tip = $(this.getTipElement());
      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX$1);

      if (tabClass !== null && tabClass.length > 0) {
        $tip.removeClass(tabClass.join(''));
      }
    } // Static
    ;

    Popover._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$7);

        var _config = _typeof(config) === 'object' ? config : null;

        if (!data && /dispose|hide/.test(config)) {
          return;
        }

        if (!data) {
          data = new Popover(this, _config);
          $(this).data(DATA_KEY$7, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    _createClass(Popover, null, [{
      key: "VERSION",
      // Getters
      get: function get() {
        return VERSION$7;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$5;
      }
    }, {
      key: "NAME",
      get: function get() {
        return NAME$7;
      }
    }, {
      key: "DATA_KEY",
      get: function get() {
        return DATA_KEY$7;
      }
    }, {
      key: "Event",
      get: function get() {
        return Event$7;
      }
    }, {
      key: "EVENT_KEY",
      get: function get() {
        return EVENT_KEY$7;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$5;
      }
    }]);

    return Popover;
  }(Tooltip);
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */


  $.fn[NAME$7] = Popover._jQueryInterface;
  $.fn[NAME$7].Constructor = Popover;

  $.fn[NAME$7].noConflict = function () {
    $.fn[NAME$7] = JQUERY_NO_CONFLICT$7;
    return Popover._jQueryInterface;
  };
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME$8 = 'scrollspy';
  var VERSION$8 = '4.4.1';
  var DATA_KEY$8 = 'bs.scrollspy';
  var EVENT_KEY$8 = "." + DATA_KEY$8;
  var DATA_API_KEY$6 = '.data-api';
  var JQUERY_NO_CONFLICT$8 = $.fn[NAME$8];
  var Default$6 = {
    offset: 10,
    method: 'auto',
    target: ''
  };
  var DefaultType$6 = {
    offset: 'number',
    method: 'string',
    target: '(string|element)'
  };
  var Event$8 = {
    ACTIVATE: "activate" + EVENT_KEY$8,
    SCROLL: "scroll" + EVENT_KEY$8,
    LOAD_DATA_API: "load" + EVENT_KEY$8 + DATA_API_KEY$6
  };
  var ClassName$8 = {
    DROPDOWN_ITEM: 'dropdown-item',
    DROPDOWN_MENU: 'dropdown-menu',
    ACTIVE: 'active'
  };
  var Selector$8 = {
    DATA_SPY: '[data-spy="scroll"]',
    ACTIVE: '.active',
    NAV_LIST_GROUP: '.nav, .list-group',
    NAV_LINKS: '.nav-link',
    NAV_ITEMS: '.nav-item',
    LIST_ITEMS: '.list-group-item',
    DROPDOWN: '.dropdown',
    DROPDOWN_ITEMS: '.dropdown-item',
    DROPDOWN_TOGGLE: '.dropdown-toggle'
  };
  var OffsetMethod = {
    OFFSET: 'offset',
    POSITION: 'position'
  };
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var ScrollSpy =
  /*#__PURE__*/
  function () {
    function ScrollSpy(element, config) {
      var _this = this;

      this._element = element;
      this._scrollElement = element.tagName === 'BODY' ? window : element;
      this._config = this._getConfig(config);
      this._selector = this._config.target + " " + Selector$8.NAV_LINKS + "," + (this._config.target + " " + Selector$8.LIST_ITEMS + ",") + (this._config.target + " " + Selector$8.DROPDOWN_ITEMS);
      this._offsets = [];
      this._targets = [];
      this._activeTarget = null;
      this._scrollHeight = 0;
      $(this._scrollElement).on(Event$8.SCROLL, function (event) {
        return _this._process(event);
      });
      this.refresh();

      this._process();
    } // Getters


    var _proto = ScrollSpy.prototype; // Public

    _proto.refresh = function refresh() {
      var _this2 = this;

      var autoMethod = this._scrollElement === this._scrollElement.window ? OffsetMethod.OFFSET : OffsetMethod.POSITION;
      var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;
      var offsetBase = offsetMethod === OffsetMethod.POSITION ? this._getScrollTop() : 0;
      this._offsets = [];
      this._targets = [];
      this._scrollHeight = this._getScrollHeight();
      var targets = [].slice.call(document.querySelectorAll(this._selector));
      targets.map(function (element) {
        var target;
        var targetSelector = Util.getSelectorFromElement(element);

        if (targetSelector) {
          target = document.querySelector(targetSelector);
        }

        if (target) {
          var targetBCR = target.getBoundingClientRect();

          if (targetBCR.width || targetBCR.height) {
            // TODO (fat): remove sketch reliance on jQuery position/offset
            return [$(target)[offsetMethod]().top + offsetBase, targetSelector];
          }
        }

        return null;
      }).filter(function (item) {
        return item;
      }).sort(function (a, b) {
        return a[0] - b[0];
      }).forEach(function (item) {
        _this2._offsets.push(item[0]);

        _this2._targets.push(item[1]);
      });
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY$8);
      $(this._scrollElement).off(EVENT_KEY$8);
      this._element = null;
      this._scrollElement = null;
      this._config = null;
      this._selector = null;
      this._offsets = null;
      this._targets = null;
      this._activeTarget = null;
      this._scrollHeight = null;
    } // Private
    ;

    _proto._getConfig = function _getConfig(config) {
      config = _objectSpread2({}, Default$6, {}, _typeof(config) === 'object' && config ? config : {});

      if (typeof config.target !== 'string') {
        var id = $(config.target).attr('id');

        if (!id) {
          id = Util.getUID(NAME$8);
          $(config.target).attr('id', id);
        }

        config.target = "#" + id;
      }

      Util.typeCheckConfig(NAME$8, config, DefaultType$6);
      return config;
    };

    _proto._getScrollTop = function _getScrollTop() {
      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
    };

    _proto._getScrollHeight = function _getScrollHeight() {
      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
    };

    _proto._getOffsetHeight = function _getOffsetHeight() {
      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
    };

    _proto._process = function _process() {
      var scrollTop = this._getScrollTop() + this._config.offset;

      var scrollHeight = this._getScrollHeight();

      var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();

      if (this._scrollHeight !== scrollHeight) {
        this.refresh();
      }

      if (scrollTop >= maxScroll) {
        var target = this._targets[this._targets.length - 1];

        if (this._activeTarget !== target) {
          this._activate(target);
        }

        return;
      }

      if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
        this._activeTarget = null;

        this._clear();

        return;
      }

      var offsetLength = this._offsets.length;

      for (var i = offsetLength; i--;) {
        var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);

        if (isActiveTarget) {
          this._activate(this._targets[i]);
        }
      }
    };

    _proto._activate = function _activate(target) {
      this._activeTarget = target;

      this._clear();

      var queries = this._selector.split(',').map(function (selector) {
        return selector + "[data-target=\"" + target + "\"]," + selector + "[href=\"" + target + "\"]";
      });

      var $link = $([].slice.call(document.querySelectorAll(queries.join(','))));

      if ($link.hasClass(ClassName$8.DROPDOWN_ITEM)) {
        $link.closest(Selector$8.DROPDOWN).find(Selector$8.DROPDOWN_TOGGLE).addClass(ClassName$8.ACTIVE);
        $link.addClass(ClassName$8.ACTIVE);
      } else {
        // Set triggered link as active
        $link.addClass(ClassName$8.ACTIVE); // Set triggered links parents as active
        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor

        $link.parents(Selector$8.NAV_LIST_GROUP).prev(Selector$8.NAV_LINKS + ", " + Selector$8.LIST_ITEMS).addClass(ClassName$8.ACTIVE); // Handle special case when .nav-link is inside .nav-item

        $link.parents(Selector$8.NAV_LIST_GROUP).prev(Selector$8.NAV_ITEMS).children(Selector$8.NAV_LINKS).addClass(ClassName$8.ACTIVE);
      }

      $(this._scrollElement).trigger(Event$8.ACTIVATE, {
        relatedTarget: target
      });
    };

    _proto._clear = function _clear() {
      [].slice.call(document.querySelectorAll(this._selector)).filter(function (node) {
        return node.classList.contains(ClassName$8.ACTIVE);
      }).forEach(function (node) {
        return node.classList.remove(ClassName$8.ACTIVE);
      });
    } // Static
    ;

    ScrollSpy._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var data = $(this).data(DATA_KEY$8);

        var _config = _typeof(config) === 'object' && config;

        if (!data) {
          data = new ScrollSpy(this, _config);
          $(this).data(DATA_KEY$8, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    _createClass(ScrollSpy, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$8;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$6;
      }
    }]);

    return ScrollSpy;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(window).on(Event$8.LOAD_DATA_API, function () {
    var scrollSpys = [].slice.call(document.querySelectorAll(Selector$8.DATA_SPY));
    var scrollSpysLength = scrollSpys.length;

    for (var i = scrollSpysLength; i--;) {
      var $spy = $(scrollSpys[i]);

      ScrollSpy._jQueryInterface.call($spy, $spy.data());
    }
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME$8] = ScrollSpy._jQueryInterface;
  $.fn[NAME$8].Constructor = ScrollSpy;

  $.fn[NAME$8].noConflict = function () {
    $.fn[NAME$8] = JQUERY_NO_CONFLICT$8;
    return ScrollSpy._jQueryInterface;
  };
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME$9 = 'tab';
  var VERSION$9 = '4.4.1';
  var DATA_KEY$9 = 'bs.tab';
  var EVENT_KEY$9 = "." + DATA_KEY$9;
  var DATA_API_KEY$7 = '.data-api';
  var JQUERY_NO_CONFLICT$9 = $.fn[NAME$9];
  var Event$9 = {
    HIDE: "hide" + EVENT_KEY$9,
    HIDDEN: "hidden" + EVENT_KEY$9,
    SHOW: "show" + EVENT_KEY$9,
    SHOWN: "shown" + EVENT_KEY$9,
    CLICK_DATA_API: "click" + EVENT_KEY$9 + DATA_API_KEY$7
  };
  var ClassName$9 = {
    DROPDOWN_MENU: 'dropdown-menu',
    ACTIVE: 'active',
    DISABLED: 'disabled',
    FADE: 'fade',
    SHOW: 'show'
  };
  var Selector$9 = {
    DROPDOWN: '.dropdown',
    NAV_LIST_GROUP: '.nav, .list-group',
    ACTIVE: '.active',
    ACTIVE_UL: '> li > .active',
    DATA_TOGGLE: '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',
    DROPDOWN_TOGGLE: '.dropdown-toggle',
    DROPDOWN_ACTIVE_CHILD: '> .dropdown-menu .active'
  };
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Tab =
  /*#__PURE__*/
  function () {
    function Tab(element) {
      this._element = element;
    } // Getters


    var _proto = Tab.prototype; // Public

    _proto.show = function show() {
      var _this = this;

      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $(this._element).hasClass(ClassName$9.ACTIVE) || $(this._element).hasClass(ClassName$9.DISABLED)) {
        return;
      }

      var target;
      var previous;
      var listElement = $(this._element).closest(Selector$9.NAV_LIST_GROUP)[0];
      var selector = Util.getSelectorFromElement(this._element);

      if (listElement) {
        var itemSelector = listElement.nodeName === 'UL' || listElement.nodeName === 'OL' ? Selector$9.ACTIVE_UL : Selector$9.ACTIVE;
        previous = $.makeArray($(listElement).find(itemSelector));
        previous = previous[previous.length - 1];
      }

      var hideEvent = $.Event(Event$9.HIDE, {
        relatedTarget: this._element
      });
      var showEvent = $.Event(Event$9.SHOW, {
        relatedTarget: previous
      });

      if (previous) {
        $(previous).trigger(hideEvent);
      }

      $(this._element).trigger(showEvent);

      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {
        return;
      }

      if (selector) {
        target = document.querySelector(selector);
      }

      this._activate(this._element, listElement);

      var complete = function complete() {
        var hiddenEvent = $.Event(Event$9.HIDDEN, {
          relatedTarget: _this._element
        });
        var shownEvent = $.Event(Event$9.SHOWN, {
          relatedTarget: previous
        });
        $(previous).trigger(hiddenEvent);
        $(_this._element).trigger(shownEvent);
      };

      if (target) {
        this._activate(target, target.parentNode, complete);
      } else {
        complete();
      }
    };

    _proto.dispose = function dispose() {
      $.removeData(this._element, DATA_KEY$9);
      this._element = null;
    } // Private
    ;

    _proto._activate = function _activate(element, container, callback) {
      var _this2 = this;

      var activeElements = container && (container.nodeName === 'UL' || container.nodeName === 'OL') ? $(container).find(Selector$9.ACTIVE_UL) : $(container).children(Selector$9.ACTIVE);
      var active = activeElements[0];
      var isTransitioning = callback && active && $(active).hasClass(ClassName$9.FADE);

      var complete = function complete() {
        return _this2._transitionComplete(element, active, callback);
      };

      if (active && isTransitioning) {
        var transitionDuration = Util.getTransitionDurationFromElement(active);
        $(active).removeClass(ClassName$9.SHOW).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      } else {
        complete();
      }
    };

    _proto._transitionComplete = function _transitionComplete(element, active, callback) {
      if (active) {
        $(active).removeClass(ClassName$9.ACTIVE);
        var dropdownChild = $(active.parentNode).find(Selector$9.DROPDOWN_ACTIVE_CHILD)[0];

        if (dropdownChild) {
          $(dropdownChild).removeClass(ClassName$9.ACTIVE);
        }

        if (active.getAttribute('role') === 'tab') {
          active.setAttribute('aria-selected', false);
        }
      }

      $(element).addClass(ClassName$9.ACTIVE);

      if (element.getAttribute('role') === 'tab') {
        element.setAttribute('aria-selected', true);
      }

      Util.reflow(element);

      if (element.classList.contains(ClassName$9.FADE)) {
        element.classList.add(ClassName$9.SHOW);
      }

      if (element.parentNode && $(element.parentNode).hasClass(ClassName$9.DROPDOWN_MENU)) {
        var dropdownElement = $(element).closest(Selector$9.DROPDOWN)[0];

        if (dropdownElement) {
          var dropdownToggleList = [].slice.call(dropdownElement.querySelectorAll(Selector$9.DROPDOWN_TOGGLE));
          $(dropdownToggleList).addClass(ClassName$9.ACTIVE);
        }

        element.setAttribute('aria-expanded', true);
      }

      if (callback) {
        callback();
      }
    } // Static
    ;

    Tab._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var $this = $(this);
        var data = $this.data(DATA_KEY$9);

        if (!data) {
          data = new Tab(this);
          $this.data(DATA_KEY$9, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config]();
        }
      });
    };

    _createClass(Tab, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$9;
      }
    }]);

    return Tab;
  }();
  /**
   * ------------------------------------------------------------------------
   * Data Api implementation
   * ------------------------------------------------------------------------
   */


  $(document).on(Event$9.CLICK_DATA_API, Selector$9.DATA_TOGGLE, function (event) {
    event.preventDefault();

    Tab._jQueryInterface.call($(this), 'show');
  });
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME$9] = Tab._jQueryInterface;
  $.fn[NAME$9].Constructor = Tab;

  $.fn[NAME$9].noConflict = function () {
    $.fn[NAME$9] = JQUERY_NO_CONFLICT$9;
    return Tab._jQueryInterface;
  };
  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */


  var NAME$a = 'toast';
  var VERSION$a = '4.4.1';
  var DATA_KEY$a = 'bs.toast';
  var EVENT_KEY$a = "." + DATA_KEY$a;
  var JQUERY_NO_CONFLICT$a = $.fn[NAME$a];
  var Event$a = {
    CLICK_DISMISS: "click.dismiss" + EVENT_KEY$a,
    HIDE: "hide" + EVENT_KEY$a,
    HIDDEN: "hidden" + EVENT_KEY$a,
    SHOW: "show" + EVENT_KEY$a,
    SHOWN: "shown" + EVENT_KEY$a
  };
  var ClassName$a = {
    FADE: 'fade',
    HIDE: 'hide',
    SHOW: 'show',
    SHOWING: 'showing'
  };
  var DefaultType$7 = {
    animation: 'boolean',
    autohide: 'boolean',
    delay: 'number'
  };
  var Default$7 = {
    animation: true,
    autohide: true,
    delay: 500
  };
  var Selector$a = {
    DATA_DISMISS: '[data-dismiss="toast"]'
  };
  /**
   * ------------------------------------------------------------------------
   * Class Definition
   * ------------------------------------------------------------------------
   */

  var Toast =
  /*#__PURE__*/
  function () {
    function Toast(element, config) {
      this._element = element;
      this._config = this._getConfig(config);
      this._timeout = null;

      this._setListeners();
    } // Getters


    var _proto = Toast.prototype; // Public

    _proto.show = function show() {
      var _this = this;

      var showEvent = $.Event(Event$a.SHOW);
      $(this._element).trigger(showEvent);

      if (showEvent.isDefaultPrevented()) {
        return;
      }

      if (this._config.animation) {
        this._element.classList.add(ClassName$a.FADE);
      }

      var complete = function complete() {
        _this._element.classList.remove(ClassName$a.SHOWING);

        _this._element.classList.add(ClassName$a.SHOW);

        $(_this._element).trigger(Event$a.SHOWN);

        if (_this._config.autohide) {
          _this._timeout = setTimeout(function () {
            _this.hide();
          }, _this._config.delay);
        }
      };

      this._element.classList.remove(ClassName$a.HIDE);

      Util.reflow(this._element);

      this._element.classList.add(ClassName$a.SHOWING);

      if (this._config.animation) {
        var transitionDuration = Util.getTransitionDurationFromElement(this._element);
        $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      } else {
        complete();
      }
    };

    _proto.hide = function hide() {
      if (!this._element.classList.contains(ClassName$a.SHOW)) {
        return;
      }

      var hideEvent = $.Event(Event$a.HIDE);
      $(this._element).trigger(hideEvent);

      if (hideEvent.isDefaultPrevented()) {
        return;
      }

      this._close();
    };

    _proto.dispose = function dispose() {
      clearTimeout(this._timeout);
      this._timeout = null;

      if (this._element.classList.contains(ClassName$a.SHOW)) {
        this._element.classList.remove(ClassName$a.SHOW);
      }

      $(this._element).off(Event$a.CLICK_DISMISS);
      $.removeData(this._element, DATA_KEY$a);
      this._element = null;
      this._config = null;
    } // Private
    ;

    _proto._getConfig = function _getConfig(config) {
      config = _objectSpread2({}, Default$7, {}, $(this._element).data(), {}, _typeof(config) === 'object' && config ? config : {});
      Util.typeCheckConfig(NAME$a, config, this.constructor.DefaultType);
      return config;
    };

    _proto._setListeners = function _setListeners() {
      var _this2 = this;

      $(this._element).on(Event$a.CLICK_DISMISS, Selector$a.DATA_DISMISS, function () {
        return _this2.hide();
      });
    };

    _proto._close = function _close() {
      var _this3 = this;

      var complete = function complete() {
        _this3._element.classList.add(ClassName$a.HIDE);

        $(_this3._element).trigger(Event$a.HIDDEN);
      };

      this._element.classList.remove(ClassName$a.SHOW);

      if (this._config.animation) {
        var transitionDuration = Util.getTransitionDurationFromElement(this._element);
        $(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      } else {
        complete();
      }
    } // Static
    ;

    Toast._jQueryInterface = function _jQueryInterface(config) {
      return this.each(function () {
        var $element = $(this);
        var data = $element.data(DATA_KEY$a);

        var _config = _typeof(config) === 'object' && config;

        if (!data) {
          data = new Toast(this, _config);
          $element.data(DATA_KEY$a, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"" + config + "\"");
          }

          data[config](this);
        }
      });
    };

    _createClass(Toast, null, [{
      key: "VERSION",
      get: function get() {
        return VERSION$a;
      }
    }, {
      key: "DefaultType",
      get: function get() {
        return DefaultType$7;
      }
    }, {
      key: "Default",
      get: function get() {
        return Default$7;
      }
    }]);

    return Toast;
  }();
  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */


  $.fn[NAME$a] = Toast._jQueryInterface;
  $.fn[NAME$a].Constructor = Toast;

  $.fn[NAME$a].noConflict = function () {
    $.fn[NAME$a] = JQUERY_NO_CONFLICT$a;
    return Toast._jQueryInterface;
  };

  exports.Alert = Alert;
  exports.Button = Button;
  exports.Carousel = Carousel;
  exports.Collapse = Collapse;
  exports.Dropdown = Dropdown;
  exports.Modal = Modal;
  exports.Popover = Popover;
  exports.Scrollspy = ScrollSpy;
  exports.Tab = Tab;
  exports.Toast = Toast;
  exports.Tooltip = Tooltip;
  exports.Util = Util;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});

/***/ }),

/***/ "./node_modules/owl.carousel/dist/owl.carousel.js":
/*!********************************************************!*\
  !*** ./node_modules/owl.carousel/dist/owl.carousel.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Owl Carousel v2.3.4
 * Copyright 2013-2018 David Deutsch
 * Licensed under: SEE LICENSE IN https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE
 */

/**
 * Owl carousel
 * @version 2.3.4
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 * @todo Lazy Load Icon
 * @todo prevent animationend bubling
 * @todo itemsScaleUp
 * @todo Test Zepto
 * @todo stagePadding calculate wrong active classes
 */
;

(function ($, window, document, undefined) {
  /**
   * Creates a carousel.
   * @class The Owl Carousel.
   * @public
   * @param {HTMLElement|jQuery} element - The element to create the carousel for.
   * @param {Object} [options] - The options
   */
  function Owl(element, options) {
    /**
     * Current settings for the carousel.
     * @public
     */
    this.settings = null;
    /**
     * Current options set by the caller including defaults.
     * @public
     */

    this.options = $.extend({}, Owl.Defaults, options);
    /**
     * Plugin element.
     * @public
     */

    this.$element = $(element);
    /**
     * Proxied event handlers.
     * @protected
     */

    this._handlers = {};
    /**
     * References to the running plugins of this carousel.
     * @protected
     */

    this._plugins = {};
    /**
     * Currently suppressed events to prevent them from being retriggered.
     * @protected
     */

    this._supress = {};
    /**
     * Absolute current position.
     * @protected
     */

    this._current = null;
    /**
     * Animation speed in milliseconds.
     * @protected
     */

    this._speed = null;
    /**
     * Coordinates of all items in pixel.
     * @todo The name of this member is missleading.
     * @protected
     */

    this._coordinates = [];
    /**
     * Current breakpoint.
     * @todo Real media queries would be nice.
     * @protected
     */

    this._breakpoint = null;
    /**
     * Current width of the plugin element.
     */

    this._width = null;
    /**
     * All real items.
     * @protected
     */

    this._items = [];
    /**
     * All cloned items.
     * @protected
     */

    this._clones = [];
    /**
     * Merge values of all items.
     * @todo Maybe this could be part of a plugin.
     * @protected
     */

    this._mergers = [];
    /**
     * Widths of all items.
     */

    this._widths = [];
    /**
     * Invalidated parts within the update process.
     * @protected
     */

    this._invalidated = {};
    /**
     * Ordered list of workers for the update process.
     * @protected
     */

    this._pipe = [];
    /**
     * Current state information for the drag operation.
     * @todo #261
     * @protected
     */

    this._drag = {
      time: null,
      target: null,
      pointer: null,
      stage: {
        start: null,
        current: null
      },
      direction: null
    };
    /**
     * Current state information and their tags.
     * @type {Object}
     * @protected
     */

    this._states = {
      current: {},
      tags: {
        'initializing': ['busy'],
        'animating': ['busy'],
        'dragging': ['interacting']
      }
    };
    $.each(['onResize', 'onThrottledResize'], $.proxy(function (i, handler) {
      this._handlers[handler] = $.proxy(this[handler], this);
    }, this));
    $.each(Owl.Plugins, $.proxy(function (key, plugin) {
      this._plugins[key.charAt(0).toLowerCase() + key.slice(1)] = new plugin(this);
    }, this));
    $.each(Owl.Workers, $.proxy(function (priority, worker) {
      this._pipe.push({
        'filter': worker.filter,
        'run': $.proxy(worker.run, this)
      });
    }, this));
    this.setup();
    this.initialize();
  }
  /**
   * Default options for the carousel.
   * @public
   */


  Owl.Defaults = {
    items: 3,
    loop: false,
    center: false,
    rewind: false,
    checkVisibility: true,
    mouseDrag: true,
    touchDrag: true,
    pullDrag: true,
    freeDrag: false,
    margin: 0,
    stagePadding: 0,
    merge: false,
    mergeFit: true,
    autoWidth: false,
    startPosition: 0,
    rtl: false,
    smartSpeed: 250,
    fluidSpeed: false,
    dragEndSpeed: false,
    responsive: {},
    responsiveRefreshRate: 200,
    responsiveBaseElement: window,
    fallbackEasing: 'swing',
    slideTransition: '',
    info: false,
    nestedItemSelector: false,
    itemElement: 'div',
    stageElement: 'div',
    refreshClass: 'owl-refresh',
    loadedClass: 'owl-loaded',
    loadingClass: 'owl-loading',
    rtlClass: 'owl-rtl',
    responsiveClass: 'owl-responsive',
    dragClass: 'owl-drag',
    itemClass: 'owl-item',
    stageClass: 'owl-stage',
    stageOuterClass: 'owl-stage-outer',
    grabClass: 'owl-grab'
  };
  /**
   * Enumeration for width.
   * @public
   * @readonly
   * @enum {String}
   */

  Owl.Width = {
    Default: 'default',
    Inner: 'inner',
    Outer: 'outer'
  };
  /**
   * Enumeration for types.
   * @public
   * @readonly
   * @enum {String}
   */

  Owl.Type = {
    Event: 'event',
    State: 'state'
  };
  /**
   * Contains all registered plugins.
   * @public
   */

  Owl.Plugins = {};
  /**
   * List of workers involved in the update process.
   */

  Owl.Workers = [{
    filter: ['width', 'settings'],
    run: function run() {
      this._width = this.$element.width();
    }
  }, {
    filter: ['width', 'items', 'settings'],
    run: function run(cache) {
      cache.current = this._items && this._items[this.relative(this._current)];
    }
  }, {
    filter: ['items', 'settings'],
    run: function run() {
      this.$stage.children('.cloned').remove();
    }
  }, {
    filter: ['width', 'items', 'settings'],
    run: function run(cache) {
      var margin = this.settings.margin || '',
          grid = !this.settings.autoWidth,
          rtl = this.settings.rtl,
          css = {
        'width': 'auto',
        'margin-left': rtl ? margin : '',
        'margin-right': rtl ? '' : margin
      };
      !grid && this.$stage.children().css(css);
      cache.css = css;
    }
  }, {
    filter: ['width', 'items', 'settings'],
    run: function run(cache) {
      var width = (this.width() / this.settings.items).toFixed(3) - this.settings.margin,
          merge = null,
          iterator = this._items.length,
          grid = !this.settings.autoWidth,
          widths = [];
      cache.items = {
        merge: false,
        width: width
      };

      while (iterator--) {
        merge = this._mergers[iterator];
        merge = this.settings.mergeFit && Math.min(merge, this.settings.items) || merge;
        cache.items.merge = merge > 1 || cache.items.merge;
        widths[iterator] = !grid ? this._items[iterator].width() : width * merge;
      }

      this._widths = widths;
    }
  }, {
    filter: ['items', 'settings'],
    run: function run() {
      var clones = [],
          items = this._items,
          settings = this.settings,
          // TODO: Should be computed from number of min width items in stage
      view = Math.max(settings.items * 2, 4),
          size = Math.ceil(items.length / 2) * 2,
          repeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0,
          append = '',
          prepend = '';
      repeat /= 2;

      while (repeat > 0) {
        // Switch to only using appended clones
        clones.push(this.normalize(clones.length / 2, true));
        append = append + items[clones[clones.length - 1]][0].outerHTML;
        clones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, true));
        prepend = items[clones[clones.length - 1]][0].outerHTML + prepend;
        repeat -= 1;
      }

      this._clones = clones;
      $(append).addClass('cloned').appendTo(this.$stage);
      $(prepend).addClass('cloned').prependTo(this.$stage);
    }
  }, {
    filter: ['width', 'items', 'settings'],
    run: function run() {
      var rtl = this.settings.rtl ? 1 : -1,
          size = this._clones.length + this._items.length,
          iterator = -1,
          previous = 0,
          current = 0,
          coordinates = [];

      while (++iterator < size) {
        previous = coordinates[iterator - 1] || 0;
        current = this._widths[this.relative(iterator)] + this.settings.margin;
        coordinates.push(previous + current * rtl);
      }

      this._coordinates = coordinates;
    }
  }, {
    filter: ['width', 'items', 'settings'],
    run: function run() {
      var padding = this.settings.stagePadding,
          coordinates = this._coordinates,
          css = {
        'width': Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + padding * 2,
        'padding-left': padding || '',
        'padding-right': padding || ''
      };
      this.$stage.css(css);
    }
  }, {
    filter: ['width', 'items', 'settings'],
    run: function run(cache) {
      var iterator = this._coordinates.length,
          grid = !this.settings.autoWidth,
          items = this.$stage.children();

      if (grid && cache.items.merge) {
        while (iterator--) {
          cache.css.width = this._widths[this.relative(iterator)];
          items.eq(iterator).css(cache.css);
        }
      } else if (grid) {
        cache.css.width = cache.items.width;
        items.css(cache.css);
      }
    }
  }, {
    filter: ['items'],
    run: function run() {
      this._coordinates.length < 1 && this.$stage.removeAttr('style');
    }
  }, {
    filter: ['width', 'items', 'settings'],
    run: function run(cache) {
      cache.current = cache.current ? this.$stage.children().index(cache.current) : 0;
      cache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current));
      this.reset(cache.current);
    }
  }, {
    filter: ['position'],
    run: function run() {
      this.animate(this.coordinates(this._current));
    }
  }, {
    filter: ['width', 'position', 'items', 'settings'],
    run: function run() {
      var rtl = this.settings.rtl ? 1 : -1,
          padding = this.settings.stagePadding * 2,
          begin = this.coordinates(this.current()) + padding,
          end = begin + this.width() * rtl,
          inner,
          outer,
          matches = [],
          i,
          n;

      for (i = 0, n = this._coordinates.length; i < n; i++) {
        inner = this._coordinates[i - 1] || 0;
        outer = Math.abs(this._coordinates[i]) + padding * rtl;

        if (this.op(inner, '<=', begin) && this.op(inner, '>', end) || this.op(outer, '<', begin) && this.op(outer, '>', end)) {
          matches.push(i);
        }
      }

      this.$stage.children('.active').removeClass('active');
      this.$stage.children(':eq(' + matches.join('), :eq(') + ')').addClass('active');
      this.$stage.children('.center').removeClass('center');

      if (this.settings.center) {
        this.$stage.children().eq(this.current()).addClass('center');
      }
    }
  }];
  /**
   * Create the stage DOM element
   */

  Owl.prototype.initializeStage = function () {
    this.$stage = this.$element.find('.' + this.settings.stageClass); // if the stage is already in the DOM, grab it and skip stage initialization

    if (this.$stage.length) {
      return;
    }

    this.$element.addClass(this.options.loadingClass); // create stage

    this.$stage = $('<' + this.settings.stageElement + '>', {
      "class": this.settings.stageClass
    }).wrap($('<div/>', {
      "class": this.settings.stageOuterClass
    })); // append stage

    this.$element.append(this.$stage.parent());
  };
  /**
   * Create item DOM elements
   */


  Owl.prototype.initializeItems = function () {
    var $items = this.$element.find('.owl-item'); // if the items are already in the DOM, grab them and skip item initialization

    if ($items.length) {
      this._items = $items.get().map(function (item) {
        return $(item);
      });
      this._mergers = this._items.map(function () {
        return 1;
      });
      this.refresh();
      return;
    } // append content


    this.replace(this.$element.children().not(this.$stage.parent())); // check visibility

    if (this.isVisible()) {
      // update view
      this.refresh();
    } else {
      // invalidate width
      this.invalidate('width');
    }

    this.$element.removeClass(this.options.loadingClass).addClass(this.options.loadedClass);
  };
  /**
   * Initializes the carousel.
   * @protected
   */


  Owl.prototype.initialize = function () {
    this.enter('initializing');
    this.trigger('initialize');
    this.$element.toggleClass(this.settings.rtlClass, this.settings.rtl);

    if (this.settings.autoWidth && !this.is('pre-loading')) {
      var imgs, nestedSelector, width;
      imgs = this.$element.find('img');
      nestedSelector = this.settings.nestedItemSelector ? '.' + this.settings.nestedItemSelector : undefined;
      width = this.$element.children(nestedSelector).width();

      if (imgs.length && width <= 0) {
        this.preloadAutoWidthImages(imgs);
      }
    }

    this.initializeStage();
    this.initializeItems(); // register event handlers

    this.registerEventHandlers();
    this.leave('initializing');
    this.trigger('initialized');
  };
  /**
   * @returns {Boolean} visibility of $element
   *                    if you know the carousel will always be visible you can set `checkVisibility` to `false` to
   *                    prevent the expensive browser layout forced reflow the $element.is(':visible') does
   */


  Owl.prototype.isVisible = function () {
    return this.settings.checkVisibility ? this.$element.is(':visible') : true;
  };
  /**
   * Setups the current settings.
   * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?
   * @todo Support for media queries by using `matchMedia` would be nice.
   * @public
   */


  Owl.prototype.setup = function () {
    var viewport = this.viewport(),
        overwrites = this.options.responsive,
        match = -1,
        settings = null;

    if (!overwrites) {
      settings = $.extend({}, this.options);
    } else {
      $.each(overwrites, function (breakpoint) {
        if (breakpoint <= viewport && breakpoint > match) {
          match = Number(breakpoint);
        }
      });
      settings = $.extend({}, this.options, overwrites[match]);

      if (typeof settings.stagePadding === 'function') {
        settings.stagePadding = settings.stagePadding();
      }

      delete settings.responsive; // responsive class

      if (settings.responsiveClass) {
        this.$element.attr('class', this.$element.attr('class').replace(new RegExp('(' + this.options.responsiveClass + '-)\\S+\\s', 'g'), '$1' + match));
      }
    }

    this.trigger('change', {
      property: {
        name: 'settings',
        value: settings
      }
    });
    this._breakpoint = match;
    this.settings = settings;
    this.invalidate('settings');
    this.trigger('changed', {
      property: {
        name: 'settings',
        value: this.settings
      }
    });
  };
  /**
   * Updates option logic if necessery.
   * @protected
   */


  Owl.prototype.optionsLogic = function () {
    if (this.settings.autoWidth) {
      this.settings.stagePadding = false;
      this.settings.merge = false;
    }
  };
  /**
   * Prepares an item before add.
   * @todo Rename event parameter `content` to `item`.
   * @protected
   * @returns {jQuery|HTMLElement} - The item container.
   */


  Owl.prototype.prepare = function (item) {
    var event = this.trigger('prepare', {
      content: item
    });

    if (!event.data) {
      event.data = $('<' + this.settings.itemElement + '/>').addClass(this.options.itemClass).append(item);
    }

    this.trigger('prepared', {
      content: event.data
    });
    return event.data;
  };
  /**
   * Updates the view.
   * @public
   */


  Owl.prototype.update = function () {
    var i = 0,
        n = this._pipe.length,
        filter = $.proxy(function (p) {
      return this[p];
    }, this._invalidated),
        cache = {};

    while (i < n) {
      if (this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) {
        this._pipe[i].run(cache);
      }

      i++;
    }

    this._invalidated = {};
    !this.is('valid') && this.enter('valid');
  };
  /**
   * Gets the width of the view.
   * @public
   * @param {Owl.Width} [dimension=Owl.Width.Default] - The dimension to return.
   * @returns {Number} - The width of the view in pixel.
   */


  Owl.prototype.width = function (dimension) {
    dimension = dimension || Owl.Width.Default;

    switch (dimension) {
      case Owl.Width.Inner:
      case Owl.Width.Outer:
        return this._width;

      default:
        return this._width - this.settings.stagePadding * 2 + this.settings.margin;
    }
  };
  /**
   * Refreshes the carousel primarily for adaptive purposes.
   * @public
   */


  Owl.prototype.refresh = function () {
    this.enter('refreshing');
    this.trigger('refresh');
    this.setup();
    this.optionsLogic();
    this.$element.addClass(this.options.refreshClass);
    this.update();
    this.$element.removeClass(this.options.refreshClass);
    this.leave('refreshing');
    this.trigger('refreshed');
  };
  /**
   * Checks window `resize` event.
   * @protected
   */


  Owl.prototype.onThrottledResize = function () {
    window.clearTimeout(this.resizeTimer);
    this.resizeTimer = window.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);
  };
  /**
   * Checks window `resize` event.
   * @protected
   */


  Owl.prototype.onResize = function () {
    if (!this._items.length) {
      return false;
    }

    if (this._width === this.$element.width()) {
      return false;
    }

    if (!this.isVisible()) {
      return false;
    }

    this.enter('resizing');

    if (this.trigger('resize').isDefaultPrevented()) {
      this.leave('resizing');
      return false;
    }

    this.invalidate('width');
    this.refresh();
    this.leave('resizing');
    this.trigger('resized');
  };
  /**
   * Registers event handlers.
   * @todo Check `msPointerEnabled`
   * @todo #261
   * @protected
   */


  Owl.prototype.registerEventHandlers = function () {
    if ($.support.transition) {
      this.$stage.on($.support.transition.end + '.owl.core', $.proxy(this.onTransitionEnd, this));
    }

    if (this.settings.responsive !== false) {
      this.on(window, 'resize', this._handlers.onThrottledResize);
    }

    if (this.settings.mouseDrag) {
      this.$element.addClass(this.options.dragClass);
      this.$stage.on('mousedown.owl.core', $.proxy(this.onDragStart, this));
      this.$stage.on('dragstart.owl.core selectstart.owl.core', function () {
        return false;
      });
    }

    if (this.settings.touchDrag) {
      this.$stage.on('touchstart.owl.core', $.proxy(this.onDragStart, this));
      this.$stage.on('touchcancel.owl.core', $.proxy(this.onDragEnd, this));
    }
  };
  /**
   * Handles `touchstart` and `mousedown` events.
   * @todo Horizontal swipe threshold as option
   * @todo #261
   * @protected
   * @param {Event} event - The event arguments.
   */


  Owl.prototype.onDragStart = function (event) {
    var stage = null;

    if (event.which === 3) {
      return;
    }

    if ($.support.transform) {
      stage = this.$stage.css('transform').replace(/.*\(|\)| /g, '').split(',');
      stage = {
        x: stage[stage.length === 16 ? 12 : 4],
        y: stage[stage.length === 16 ? 13 : 5]
      };
    } else {
      stage = this.$stage.position();
      stage = {
        x: this.settings.rtl ? stage.left + this.$stage.width() - this.width() + this.settings.margin : stage.left,
        y: stage.top
      };
    }

    if (this.is('animating')) {
      $.support.transform ? this.animate(stage.x) : this.$stage.stop();
      this.invalidate('position');
    }

    this.$element.toggleClass(this.options.grabClass, event.type === 'mousedown');
    this.speed(0);
    this._drag.time = new Date().getTime();
    this._drag.target = $(event.target);
    this._drag.stage.start = stage;
    this._drag.stage.current = stage;
    this._drag.pointer = this.pointer(event);
    $(document).on('mouseup.owl.core touchend.owl.core', $.proxy(this.onDragEnd, this));
    $(document).one('mousemove.owl.core touchmove.owl.core', $.proxy(function (event) {
      var delta = this.difference(this._drag.pointer, this.pointer(event));
      $(document).on('mousemove.owl.core touchmove.owl.core', $.proxy(this.onDragMove, this));

      if (Math.abs(delta.x) < Math.abs(delta.y) && this.is('valid')) {
        return;
      }

      event.preventDefault();
      this.enter('dragging');
      this.trigger('drag');
    }, this));
  };
  /**
   * Handles the `touchmove` and `mousemove` events.
   * @todo #261
   * @protected
   * @param {Event} event - The event arguments.
   */


  Owl.prototype.onDragMove = function (event) {
    var minimum = null,
        maximum = null,
        pull = null,
        delta = this.difference(this._drag.pointer, this.pointer(event)),
        stage = this.difference(this._drag.stage.start, delta);

    if (!this.is('dragging')) {
      return;
    }

    event.preventDefault();

    if (this.settings.loop) {
      minimum = this.coordinates(this.minimum());
      maximum = this.coordinates(this.maximum() + 1) - minimum;
      stage.x = ((stage.x - minimum) % maximum + maximum) % maximum + minimum;
    } else {
      minimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());
      maximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());
      pull = this.settings.pullDrag ? -1 * delta.x / 5 : 0;
      stage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull);
    }

    this._drag.stage.current = stage;
    this.animate(stage.x);
  };
  /**
   * Handles the `touchend` and `mouseup` events.
   * @todo #261
   * @todo Threshold for click event
   * @protected
   * @param {Event} event - The event arguments.
   */


  Owl.prototype.onDragEnd = function (event) {
    var delta = this.difference(this._drag.pointer, this.pointer(event)),
        stage = this._drag.stage.current,
        direction = delta.x > 0 ^ this.settings.rtl ? 'left' : 'right';
    $(document).off('.owl.core');
    this.$element.removeClass(this.options.grabClass);

    if (delta.x !== 0 && this.is('dragging') || !this.is('valid')) {
      this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);
      this.current(this.closest(stage.x, delta.x !== 0 ? direction : this._drag.direction));
      this.invalidate('position');
      this.update();
      this._drag.direction = direction;

      if (Math.abs(delta.x) > 3 || new Date().getTime() - this._drag.time > 300) {
        this._drag.target.one('click.owl.core', function () {
          return false;
        });
      }
    }

    if (!this.is('dragging')) {
      return;
    }

    this.leave('dragging');
    this.trigger('dragged');
  };
  /**
   * Gets absolute position of the closest item for a coordinate.
   * @todo Setting `freeDrag` makes `closest` not reusable. See #165.
   * @protected
   * @param {Number} coordinate - The coordinate in pixel.
   * @param {String} direction - The direction to check for the closest item. Ether `left` or `right`.
   * @return {Number} - The absolute position of the closest item.
   */


  Owl.prototype.closest = function (coordinate, direction) {
    var position = -1,
        pull = 30,
        width = this.width(),
        coordinates = this.coordinates();

    if (!this.settings.freeDrag) {
      // check closest item
      $.each(coordinates, $.proxy(function (index, value) {
        // on a left pull, check on current index
        if (direction === 'left' && coordinate > value - pull && coordinate < value + pull) {
          position = index; // on a right pull, check on previous index
          // to do so, subtract width from value and set position = index + 1
        } else if (direction === 'right' && coordinate > value - width - pull && coordinate < value - width + pull) {
          position = index + 1;
        } else if (this.op(coordinate, '<', value) && this.op(coordinate, '>', coordinates[index + 1] !== undefined ? coordinates[index + 1] : value - width)) {
          position = direction === 'left' ? index + 1 : index;
        }

        return position === -1;
      }, this));
    }

    if (!this.settings.loop) {
      // non loop boundries
      if (this.op(coordinate, '>', coordinates[this.minimum()])) {
        position = coordinate = this.minimum();
      } else if (this.op(coordinate, '<', coordinates[this.maximum()])) {
        position = coordinate = this.maximum();
      }
    }

    return position;
  };
  /**
   * Animates the stage.
   * @todo #270
   * @public
   * @param {Number} coordinate - The coordinate in pixels.
   */


  Owl.prototype.animate = function (coordinate) {
    var animate = this.speed() > 0;
    this.is('animating') && this.onTransitionEnd();

    if (animate) {
      this.enter('animating');
      this.trigger('translate');
    }

    if ($.support.transform3d && $.support.transition) {
      this.$stage.css({
        transform: 'translate3d(' + coordinate + 'px,0px,0px)',
        transition: this.speed() / 1000 + 's' + (this.settings.slideTransition ? ' ' + this.settings.slideTransition : '')
      });
    } else if (animate) {
      this.$stage.animate({
        left: coordinate + 'px'
      }, this.speed(), this.settings.fallbackEasing, $.proxy(this.onTransitionEnd, this));
    } else {
      this.$stage.css({
        left: coordinate + 'px'
      });
    }
  };
  /**
   * Checks whether the carousel is in a specific state or not.
   * @param {String} state - The state to check.
   * @returns {Boolean} - The flag which indicates if the carousel is busy.
   */


  Owl.prototype.is = function (state) {
    return this._states.current[state] && this._states.current[state] > 0;
  };
  /**
   * Sets the absolute position of the current item.
   * @public
   * @param {Number} [position] - The new absolute position or nothing to leave it unchanged.
   * @returns {Number} - The absolute position of the current item.
   */


  Owl.prototype.current = function (position) {
    if (position === undefined) {
      return this._current;
    }

    if (this._items.length === 0) {
      return undefined;
    }

    position = this.normalize(position);

    if (this._current !== position) {
      var event = this.trigger('change', {
        property: {
          name: 'position',
          value: position
        }
      });

      if (event.data !== undefined) {
        position = this.normalize(event.data);
      }

      this._current = position;
      this.invalidate('position');
      this.trigger('changed', {
        property: {
          name: 'position',
          value: this._current
        }
      });
    }

    return this._current;
  };
  /**
   * Invalidates the given part of the update routine.
   * @param {String} [part] - The part to invalidate.
   * @returns {Array.<String>} - The invalidated parts.
   */


  Owl.prototype.invalidate = function (part) {
    if ($.type(part) === 'string') {
      this._invalidated[part] = true;
      this.is('valid') && this.leave('valid');
    }

    return $.map(this._invalidated, function (v, i) {
      return i;
    });
  };
  /**
   * Resets the absolute position of the current item.
   * @public
   * @param {Number} position - The absolute position of the new item.
   */


  Owl.prototype.reset = function (position) {
    position = this.normalize(position);

    if (position === undefined) {
      return;
    }

    this._speed = 0;
    this._current = position;
    this.suppress(['translate', 'translated']);
    this.animate(this.coordinates(position));
    this.release(['translate', 'translated']);
  };
  /**
   * Normalizes an absolute or a relative position of an item.
   * @public
   * @param {Number} position - The absolute or relative position to normalize.
   * @param {Boolean} [relative=false] - Whether the given position is relative or not.
   * @returns {Number} - The normalized position.
   */


  Owl.prototype.normalize = function (position, relative) {
    var n = this._items.length,
        m = relative ? 0 : this._clones.length;

    if (!this.isNumeric(position) || n < 1) {
      position = undefined;
    } else if (position < 0 || position >= n + m) {
      position = ((position - m / 2) % n + n) % n + m / 2;
    }

    return position;
  };
  /**
   * Converts an absolute position of an item into a relative one.
   * @public
   * @param {Number} position - The absolute position to convert.
   * @returns {Number} - The converted position.
   */


  Owl.prototype.relative = function (position) {
    position -= this._clones.length / 2;
    return this.normalize(position, true);
  };
  /**
   * Gets the maximum position for the current item.
   * @public
   * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.
   * @returns {Number}
   */


  Owl.prototype.maximum = function (relative) {
    var settings = this.settings,
        maximum = this._coordinates.length,
        iterator,
        reciprocalItemsWidth,
        elementWidth;

    if (settings.loop) {
      maximum = this._clones.length / 2 + this._items.length - 1;
    } else if (settings.autoWidth || settings.merge) {
      iterator = this._items.length;

      if (iterator) {
        reciprocalItemsWidth = this._items[--iterator].width();
        elementWidth = this.$element.width();

        while (iterator--) {
          reciprocalItemsWidth += this._items[iterator].width() + this.settings.margin;

          if (reciprocalItemsWidth > elementWidth) {
            break;
          }
        }
      }

      maximum = iterator + 1;
    } else if (settings.center) {
      maximum = this._items.length - 1;
    } else {
      maximum = this._items.length - settings.items;
    }

    if (relative) {
      maximum -= this._clones.length / 2;
    }

    return Math.max(maximum, 0);
  };
  /**
   * Gets the minimum position for the current item.
   * @public
   * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.
   * @returns {Number}
   */


  Owl.prototype.minimum = function (relative) {
    return relative ? 0 : this._clones.length / 2;
  };
  /**
   * Gets an item at the specified relative position.
   * @public
   * @param {Number} [position] - The relative position of the item.
   * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.
   */


  Owl.prototype.items = function (position) {
    if (position === undefined) {
      return this._items.slice();
    }

    position = this.normalize(position, true);
    return this._items[position];
  };
  /**
   * Gets an item at the specified relative position.
   * @public
   * @param {Number} [position] - The relative position of the item.
   * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.
   */


  Owl.prototype.mergers = function (position) {
    if (position === undefined) {
      return this._mergers.slice();
    }

    position = this.normalize(position, true);
    return this._mergers[position];
  };
  /**
   * Gets the absolute positions of clones for an item.
   * @public
   * @param {Number} [position] - The relative position of the item.
   * @returns {Array.<Number>} - The absolute positions of clones for the item or all if no position was given.
   */


  Owl.prototype.clones = function (position) {
    var odd = this._clones.length / 2,
        even = odd + this._items.length,
        map = function map(index) {
      return index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2;
    };

    if (position === undefined) {
      return $.map(this._clones, function (v, i) {
        return map(i);
      });
    }

    return $.map(this._clones, function (v, i) {
      return v === position ? map(i) : null;
    });
  };
  /**
   * Sets the current animation speed.
   * @public
   * @param {Number} [speed] - The animation speed in milliseconds or nothing to leave it unchanged.
   * @returns {Number} - The current animation speed in milliseconds.
   */


  Owl.prototype.speed = function (speed) {
    if (speed !== undefined) {
      this._speed = speed;
    }

    return this._speed;
  };
  /**
   * Gets the coordinate of an item.
   * @todo The name of this method is missleanding.
   * @public
   * @param {Number} position - The absolute position of the item within `minimum()` and `maximum()`.
   * @returns {Number|Array.<Number>} - The coordinate of the item in pixel or all coordinates.
   */


  Owl.prototype.coordinates = function (position) {
    var multiplier = 1,
        newPosition = position - 1,
        coordinate;

    if (position === undefined) {
      return $.map(this._coordinates, $.proxy(function (coordinate, index) {
        return this.coordinates(index);
      }, this));
    }

    if (this.settings.center) {
      if (this.settings.rtl) {
        multiplier = -1;
        newPosition = position + 1;
      }

      coordinate = this._coordinates[position];
      coordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier;
    } else {
      coordinate = this._coordinates[newPosition] || 0;
    }

    coordinate = Math.ceil(coordinate);
    return coordinate;
  };
  /**
   * Calculates the speed for a translation.
   * @protected
   * @param {Number} from - The absolute position of the start item.
   * @param {Number} to - The absolute position of the target item.
   * @param {Number} [factor=undefined] - The time factor in milliseconds.
   * @returns {Number} - The time in milliseconds for the translation.
   */


  Owl.prototype.duration = function (from, to, factor) {
    if (factor === 0) {
      return 0;
    }

    return Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs(factor || this.settings.smartSpeed);
  };
  /**
   * Slides to the specified item.
   * @public
   * @param {Number} position - The position of the item.
   * @param {Number} [speed] - The time in milliseconds for the transition.
   */


  Owl.prototype.to = function (position, speed) {
    var current = this.current(),
        revert = null,
        distance = position - this.relative(current),
        direction = (distance > 0) - (distance < 0),
        items = this._items.length,
        minimum = this.minimum(),
        maximum = this.maximum();

    if (this.settings.loop) {
      if (!this.settings.rewind && Math.abs(distance) > items / 2) {
        distance += direction * -1 * items;
      }

      position = current + distance;
      revert = ((position - minimum) % items + items) % items + minimum;

      if (revert !== position && revert - distance <= maximum && revert - distance > 0) {
        current = revert - distance;
        position = revert;
        this.reset(current);
      }
    } else if (this.settings.rewind) {
      maximum += 1;
      position = (position % maximum + maximum) % maximum;
    } else {
      position = Math.max(minimum, Math.min(maximum, position));
    }

    this.speed(this.duration(current, position, speed));
    this.current(position);

    if (this.isVisible()) {
      this.update();
    }
  };
  /**
   * Slides to the next item.
   * @public
   * @param {Number} [speed] - The time in milliseconds for the transition.
   */


  Owl.prototype.next = function (speed) {
    speed = speed || false;
    this.to(this.relative(this.current()) + 1, speed);
  };
  /**
   * Slides to the previous item.
   * @public
   * @param {Number} [speed] - The time in milliseconds for the transition.
   */


  Owl.prototype.prev = function (speed) {
    speed = speed || false;
    this.to(this.relative(this.current()) - 1, speed);
  };
  /**
   * Handles the end of an animation.
   * @protected
   * @param {Event} event - The event arguments.
   */


  Owl.prototype.onTransitionEnd = function (event) {
    // if css2 animation then event object is undefined
    if (event !== undefined) {
      event.stopPropagation(); // Catch only owl-stage transitionEnd event

      if ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {
        return false;
      }
    }

    this.leave('animating');
    this.trigger('translated');
  };
  /**
   * Gets viewport width.
   * @protected
   * @return {Number} - The width in pixel.
   */


  Owl.prototype.viewport = function () {
    var width;

    if (this.options.responsiveBaseElement !== window) {
      width = $(this.options.responsiveBaseElement).width();
    } else if (window.innerWidth) {
      width = window.innerWidth;
    } else if (document.documentElement && document.documentElement.clientWidth) {
      width = document.documentElement.clientWidth;
    } else {
      console.warn('Can not detect viewport width.');
    }

    return width;
  };
  /**
   * Replaces the current content.
   * @public
   * @param {HTMLElement|jQuery|String} content - The new content.
   */


  Owl.prototype.replace = function (content) {
    this.$stage.empty();
    this._items = [];

    if (content) {
      content = content instanceof jQuery ? content : $(content);
    }

    if (this.settings.nestedItemSelector) {
      content = content.find('.' + this.settings.nestedItemSelector);
    }

    content.filter(function () {
      return this.nodeType === 1;
    }).each($.proxy(function (index, item) {
      item = this.prepare(item);
      this.$stage.append(item);

      this._items.push(item);

      this._mergers.push(item.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
    }, this));
    this.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);
    this.invalidate('items');
  };
  /**
   * Adds an item.
   * @todo Use `item` instead of `content` for the event arguments.
   * @public
   * @param {HTMLElement|jQuery|String} content - The item content to add.
   * @param {Number} [position] - The relative position at which to insert the item otherwise the item will be added to the end.
   */


  Owl.prototype.add = function (content, position) {
    var current = this.relative(this._current);
    position = position === undefined ? this._items.length : this.normalize(position, true);
    content = content instanceof jQuery ? content : $(content);
    this.trigger('add', {
      content: content,
      position: position
    });
    content = this.prepare(content);

    if (this._items.length === 0 || position === this._items.length) {
      this._items.length === 0 && this.$stage.append(content);
      this._items.length !== 0 && this._items[position - 1].after(content);

      this._items.push(content);

      this._mergers.push(content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
    } else {
      this._items[position].before(content);

      this._items.splice(position, 0, content);

      this._mergers.splice(position, 0, content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
    }

    this._items[current] && this.reset(this._items[current].index());
    this.invalidate('items');
    this.trigger('added', {
      content: content,
      position: position
    });
  };
  /**
   * Removes an item by its position.
   * @todo Use `item` instead of `content` for the event arguments.
   * @public
   * @param {Number} position - The relative position of the item to remove.
   */


  Owl.prototype.remove = function (position) {
    position = this.normalize(position, true);

    if (position === undefined) {
      return;
    }

    this.trigger('remove', {
      content: this._items[position],
      position: position
    });

    this._items[position].remove();

    this._items.splice(position, 1);

    this._mergers.splice(position, 1);

    this.invalidate('items');
    this.trigger('removed', {
      content: null,
      position: position
    });
  };
  /**
   * Preloads images with auto width.
   * @todo Replace by a more generic approach
   * @protected
   */


  Owl.prototype.preloadAutoWidthImages = function (images) {
    images.each($.proxy(function (i, element) {
      this.enter('pre-loading');
      element = $(element);
      $(new Image()).one('load', $.proxy(function (e) {
        element.attr('src', e.target.src);
        element.css('opacity', 1);
        this.leave('pre-loading');
        !this.is('pre-loading') && !this.is('initializing') && this.refresh();
      }, this)).attr('src', element.attr('src') || element.attr('data-src') || element.attr('data-src-retina'));
    }, this));
  };
  /**
   * Destroys the carousel.
   * @public
   */


  Owl.prototype.destroy = function () {
    this.$element.off('.owl.core');
    this.$stage.off('.owl.core');
    $(document).off('.owl.core');

    if (this.settings.responsive !== false) {
      window.clearTimeout(this.resizeTimer);
      this.off(window, 'resize', this._handlers.onThrottledResize);
    }

    for (var i in this._plugins) {
      this._plugins[i].destroy();
    }

    this.$stage.children('.cloned').remove();
    this.$stage.unwrap();
    this.$stage.children().contents().unwrap();
    this.$stage.children().unwrap();
    this.$stage.remove();
    this.$element.removeClass(this.options.refreshClass).removeClass(this.options.loadingClass).removeClass(this.options.loadedClass).removeClass(this.options.rtlClass).removeClass(this.options.dragClass).removeClass(this.options.grabClass).attr('class', this.$element.attr('class').replace(new RegExp(this.options.responsiveClass + '-\\S+\\s', 'g'), '')).removeData('owl.carousel');
  };
  /**
   * Operators to calculate right-to-left and left-to-right.
   * @protected
   * @param {Number} [a] - The left side operand.
   * @param {String} [o] - The operator.
   * @param {Number} [b] - The right side operand.
   */


  Owl.prototype.op = function (a, o, b) {
    var rtl = this.settings.rtl;

    switch (o) {
      case '<':
        return rtl ? a > b : a < b;

      case '>':
        return rtl ? a < b : a > b;

      case '>=':
        return rtl ? a <= b : a >= b;

      case '<=':
        return rtl ? a >= b : a <= b;

      default:
        break;
    }
  };
  /**
   * Attaches to an internal event.
   * @protected
   * @param {HTMLElement} element - The event source.
   * @param {String} event - The event name.
   * @param {Function} listener - The event handler to attach.
   * @param {Boolean} capture - Wether the event should be handled at the capturing phase or not.
   */


  Owl.prototype.on = function (element, event, listener, capture) {
    if (element.addEventListener) {
      element.addEventListener(event, listener, capture);
    } else if (element.attachEvent) {
      element.attachEvent('on' + event, listener);
    }
  };
  /**
   * Detaches from an internal event.
   * @protected
   * @param {HTMLElement} element - The event source.
   * @param {String} event - The event name.
   * @param {Function} listener - The attached event handler to detach.
   * @param {Boolean} capture - Wether the attached event handler was registered as a capturing listener or not.
   */


  Owl.prototype.off = function (element, event, listener, capture) {
    if (element.removeEventListener) {
      element.removeEventListener(event, listener, capture);
    } else if (element.detachEvent) {
      element.detachEvent('on' + event, listener);
    }
  };
  /**
   * Triggers a public event.
   * @todo Remove `status`, `relatedTarget` should be used instead.
   * @protected
   * @param {String} name - The event name.
   * @param {*} [data=null] - The event data.
   * @param {String} [namespace=carousel] - The event namespace.
   * @param {String} [state] - The state which is associated with the event.
   * @param {Boolean} [enter=false] - Indicates if the call enters the specified state or not.
   * @returns {Event} - The event arguments.
   */


  Owl.prototype.trigger = function (name, data, namespace, state, enter) {
    var status = {
      item: {
        count: this._items.length,
        index: this.current()
      }
    },
        handler = $.camelCase($.grep(['on', name, namespace], function (v) {
      return v;
    }).join('-').toLowerCase()),
        event = $.Event([name, 'owl', namespace || 'carousel'].join('.').toLowerCase(), $.extend({
      relatedTarget: this
    }, status, data));

    if (!this._supress[name]) {
      $.each(this._plugins, function (name, plugin) {
        if (plugin.onTrigger) {
          plugin.onTrigger(event);
        }
      });
      this.register({
        type: Owl.Type.Event,
        name: name
      });
      this.$element.trigger(event);

      if (this.settings && typeof this.settings[handler] === 'function') {
        this.settings[handler].call(this, event);
      }
    }

    return event;
  };
  /**
   * Enters a state.
   * @param name - The state name.
   */


  Owl.prototype.enter = function (name) {
    $.each([name].concat(this._states.tags[name] || []), $.proxy(function (i, name) {
      if (this._states.current[name] === undefined) {
        this._states.current[name] = 0;
      }

      this._states.current[name]++;
    }, this));
  };
  /**
   * Leaves a state.
   * @param name - The state name.
   */


  Owl.prototype.leave = function (name) {
    $.each([name].concat(this._states.tags[name] || []), $.proxy(function (i, name) {
      this._states.current[name]--;
    }, this));
  };
  /**
   * Registers an event or state.
   * @public
   * @param {Object} object - The event or state to register.
   */


  Owl.prototype.register = function (object) {
    if (object.type === Owl.Type.Event) {
      if (!$.event.special[object.name]) {
        $.event.special[object.name] = {};
      }

      if (!$.event.special[object.name].owl) {
        var _default = $.event.special[object.name]._default;

        $.event.special[object.name]._default = function (e) {
          if (_default && _default.apply && (!e.namespace || e.namespace.indexOf('owl') === -1)) {
            return _default.apply(this, arguments);
          }

          return e.namespace && e.namespace.indexOf('owl') > -1;
        };

        $.event.special[object.name].owl = true;
      }
    } else if (object.type === Owl.Type.State) {
      if (!this._states.tags[object.name]) {
        this._states.tags[object.name] = object.tags;
      } else {
        this._states.tags[object.name] = this._states.tags[object.name].concat(object.tags);
      }

      this._states.tags[object.name] = $.grep(this._states.tags[object.name], $.proxy(function (tag, i) {
        return $.inArray(tag, this._states.tags[object.name]) === i;
      }, this));
    }
  };
  /**
   * Suppresses events.
   * @protected
   * @param {Array.<String>} events - The events to suppress.
   */


  Owl.prototype.suppress = function (events) {
    $.each(events, $.proxy(function (index, event) {
      this._supress[event] = true;
    }, this));
  };
  /**
   * Releases suppressed events.
   * @protected
   * @param {Array.<String>} events - The events to release.
   */


  Owl.prototype.release = function (events) {
    $.each(events, $.proxy(function (index, event) {
      delete this._supress[event];
    }, this));
  };
  /**
   * Gets unified pointer coordinates from event.
   * @todo #261
   * @protected
   * @param {Event} - The `mousedown` or `touchstart` event.
   * @returns {Object} - Contains `x` and `y` coordinates of current pointer position.
   */


  Owl.prototype.pointer = function (event) {
    var result = {
      x: null,
      y: null
    };
    event = event.originalEvent || event || window.event;
    event = event.touches && event.touches.length ? event.touches[0] : event.changedTouches && event.changedTouches.length ? event.changedTouches[0] : event;

    if (event.pageX) {
      result.x = event.pageX;
      result.y = event.pageY;
    } else {
      result.x = event.clientX;
      result.y = event.clientY;
    }

    return result;
  };
  /**
   * Determines if the input is a Number or something that can be coerced to a Number
   * @protected
   * @param {Number|String|Object|Array|Boolean|RegExp|Function|Symbol} - The input to be tested
   * @returns {Boolean} - An indication if the input is a Number or can be coerced to a Number
   */


  Owl.prototype.isNumeric = function (number) {
    return !isNaN(parseFloat(number));
  };
  /**
   * Gets the difference of two vectors.
   * @todo #261
   * @protected
   * @param {Object} - The first vector.
   * @param {Object} - The second vector.
   * @returns {Object} - The difference.
   */


  Owl.prototype.difference = function (first, second) {
    return {
      x: first.x - second.x,
      y: first.y - second.y
    };
  };
  /**
   * The jQuery Plugin for the Owl Carousel
   * @todo Navigation plugin `next` and `prev`
   * @public
   */


  $.fn.owlCarousel = function (option) {
    var args = Array.prototype.slice.call(arguments, 1);
    return this.each(function () {
      var $this = $(this),
          data = $this.data('owl.carousel');

      if (!data) {
        data = new Owl(this, _typeof(option) == 'object' && option);
        $this.data('owl.carousel', data);
        $.each(['next', 'prev', 'to', 'destroy', 'refresh', 'replace', 'add', 'remove'], function (i, event) {
          data.register({
            type: Owl.Type.Event,
            name: event
          });
          data.$element.on(event + '.owl.carousel.core', $.proxy(function (e) {
            if (e.namespace && e.relatedTarget !== this) {
              this.suppress([event]);
              data[event].apply(this, [].slice.call(arguments, 1));
              this.release([event]);
            }
          }, data));
        });
      }

      if (typeof option == 'string' && option.charAt(0) !== '_') {
        data[option].apply(data, args);
      }
    });
  };
  /**
   * The constructor for the jQuery Plugin
   * @public
   */


  $.fn.owlCarousel.Constructor = Owl;
})(window.Zepto || window.jQuery, window, document);
/**
 * AutoRefresh Plugin
 * @version 2.3.4
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */


;

(function ($, window, document, undefined) {
  /**
   * Creates the auto refresh plugin.
   * @class The Auto Refresh Plugin
   * @param {Owl} carousel - The Owl Carousel
   */
  var AutoRefresh = function AutoRefresh(carousel) {
    /**
     * Reference to the core.
     * @protected
     * @type {Owl}
     */
    this._core = carousel;
    /**
     * Refresh interval.
     * @protected
     * @type {number}
     */

    this._interval = null;
    /**
     * Whether the element is currently visible or not.
     * @protected
     * @type {Boolean}
     */

    this._visible = null;
    /**
     * All event handlers.
     * @protected
     * @type {Object}
     */

    this._handlers = {
      'initialized.owl.carousel': $.proxy(function (e) {
        if (e.namespace && this._core.settings.autoRefresh) {
          this.watch();
        }
      }, this)
    }; // set default options

    this._core.options = $.extend({}, AutoRefresh.Defaults, this._core.options); // register event handlers

    this._core.$element.on(this._handlers);
  };
  /**
   * Default options.
   * @public
   */


  AutoRefresh.Defaults = {
    autoRefresh: true,
    autoRefreshInterval: 500
  };
  /**
   * Watches the element.
   */

  AutoRefresh.prototype.watch = function () {
    if (this._interval) {
      return;
    }

    this._visible = this._core.isVisible();
    this._interval = window.setInterval($.proxy(this.refresh, this), this._core.settings.autoRefreshInterval);
  };
  /**
   * Refreshes the element.
   */


  AutoRefresh.prototype.refresh = function () {
    if (this._core.isVisible() === this._visible) {
      return;
    }

    this._visible = !this._visible;

    this._core.$element.toggleClass('owl-hidden', !this._visible);

    this._visible && this._core.invalidate('width') && this._core.refresh();
  };
  /**
   * Destroys the plugin.
   */


  AutoRefresh.prototype.destroy = function () {
    var handler, property;
    window.clearInterval(this._interval);

    for (handler in this._handlers) {
      this._core.$element.off(handler, this._handlers[handler]);
    }

    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != 'function' && (this[property] = null);
    }
  };

  $.fn.owlCarousel.Constructor.Plugins.AutoRefresh = AutoRefresh;
})(window.Zepto || window.jQuery, window, document);
/**
 * Lazy Plugin
 * @version 2.3.4
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */


;

(function ($, window, document, undefined) {
  /**
   * Creates the lazy plugin.
   * @class The Lazy Plugin
   * @param {Owl} carousel - The Owl Carousel
   */
  var Lazy = function Lazy(carousel) {
    /**
     * Reference to the core.
     * @protected
     * @type {Owl}
     */
    this._core = carousel;
    /**
     * Already loaded items.
     * @protected
     * @type {Array.<jQuery>}
     */

    this._loaded = [];
    /**
     * Event handlers.
     * @protected
     * @type {Object}
     */

    this._handlers = {
      'initialized.owl.carousel change.owl.carousel resized.owl.carousel': $.proxy(function (e) {
        if (!e.namespace) {
          return;
        }

        if (!this._core.settings || !this._core.settings.lazyLoad) {
          return;
        }

        if (e.property && e.property.name == 'position' || e.type == 'initialized') {
          var settings = this._core.settings,
              n = settings.center && Math.ceil(settings.items / 2) || settings.items,
              i = settings.center && n * -1 || 0,
              position = (e.property && e.property.value !== undefined ? e.property.value : this._core.current()) + i,
              clones = this._core.clones().length,
              load = $.proxy(function (i, v) {
            this.load(v);
          }, this); //TODO: Need documentation for this new option


          if (settings.lazyLoadEager > 0) {
            n += settings.lazyLoadEager; // If the carousel is looping also preload images that are to the "left"

            if (settings.loop) {
              position -= settings.lazyLoadEager;
              n++;
            }
          }

          while (i++ < n) {
            this.load(clones / 2 + this._core.relative(position));
            clones && $.each(this._core.clones(this._core.relative(position)), load);
            position++;
          }
        }
      }, this)
    }; // set the default options

    this._core.options = $.extend({}, Lazy.Defaults, this._core.options); // register event handler

    this._core.$element.on(this._handlers);
  };
  /**
   * Default options.
   * @public
   */


  Lazy.Defaults = {
    lazyLoad: false,
    lazyLoadEager: 0
  };
  /**
   * Loads all resources of an item at the specified position.
   * @param {Number} position - The absolute position of the item.
   * @protected
   */

  Lazy.prototype.load = function (position) {
    var $item = this._core.$stage.children().eq(position),
        $elements = $item && $item.find('.owl-lazy');

    if (!$elements || $.inArray($item.get(0), this._loaded) > -1) {
      return;
    }

    $elements.each($.proxy(function (index, element) {
      var $element = $(element),
          image,
          url = window.devicePixelRatio > 1 && $element.attr('data-src-retina') || $element.attr('data-src') || $element.attr('data-srcset');

      this._core.trigger('load', {
        element: $element,
        url: url
      }, 'lazy');

      if ($element.is('img')) {
        $element.one('load.owl.lazy', $.proxy(function () {
          $element.css('opacity', 1);

          this._core.trigger('loaded', {
            element: $element,
            url: url
          }, 'lazy');
        }, this)).attr('src', url);
      } else if ($element.is('source')) {
        $element.one('load.owl.lazy', $.proxy(function () {
          this._core.trigger('loaded', {
            element: $element,
            url: url
          }, 'lazy');
        }, this)).attr('srcset', url);
      } else {
        image = new Image();
        image.onload = $.proxy(function () {
          $element.css({
            'background-image': 'url("' + url + '")',
            'opacity': '1'
          });

          this._core.trigger('loaded', {
            element: $element,
            url: url
          }, 'lazy');
        }, this);
        image.src = url;
      }
    }, this));

    this._loaded.push($item.get(0));
  };
  /**
   * Destroys the plugin.
   * @public
   */


  Lazy.prototype.destroy = function () {
    var handler, property;

    for (handler in this.handlers) {
      this._core.$element.off(handler, this.handlers[handler]);
    }

    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != 'function' && (this[property] = null);
    }
  };

  $.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy;
})(window.Zepto || window.jQuery, window, document);
/**
 * AutoHeight Plugin
 * @version 2.3.4
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */


;

(function ($, window, document, undefined) {
  /**
   * Creates the auto height plugin.
   * @class The Auto Height Plugin
   * @param {Owl} carousel - The Owl Carousel
   */
  var AutoHeight = function AutoHeight(carousel) {
    /**
     * Reference to the core.
     * @protected
     * @type {Owl}
     */
    this._core = carousel;
    this._previousHeight = null;
    /**
     * All event handlers.
     * @protected
     * @type {Object}
     */

    this._handlers = {
      'initialized.owl.carousel refreshed.owl.carousel': $.proxy(function (e) {
        if (e.namespace && this._core.settings.autoHeight) {
          this.update();
        }
      }, this),
      'changed.owl.carousel': $.proxy(function (e) {
        if (e.namespace && this._core.settings.autoHeight && e.property.name === 'position') {
          this.update();
        }
      }, this),
      'loaded.owl.lazy': $.proxy(function (e) {
        if (e.namespace && this._core.settings.autoHeight && e.element.closest('.' + this._core.settings.itemClass).index() === this._core.current()) {
          this.update();
        }
      }, this)
    }; // set default options

    this._core.options = $.extend({}, AutoHeight.Defaults, this._core.options); // register event handlers

    this._core.$element.on(this._handlers);

    this._intervalId = null;
    var refThis = this; // These changes have been taken from a PR by gavrochelegnou proposed in #1575
    // and have been made compatible with the latest jQuery version

    $(window).on('load', function () {
      if (refThis._core.settings.autoHeight) {
        refThis.update();
      }
    }); // Autoresize the height of the carousel when window is resized
    // When carousel has images, the height is dependent on the width
    // and should also change on resize

    $(window).resize(function () {
      if (refThis._core.settings.autoHeight) {
        if (refThis._intervalId != null) {
          clearTimeout(refThis._intervalId);
        }

        refThis._intervalId = setTimeout(function () {
          refThis.update();
        }, 250);
      }
    });
  };
  /**
   * Default options.
   * @public
   */


  AutoHeight.Defaults = {
    autoHeight: false,
    autoHeightClass: 'owl-height'
  };
  /**
   * Updates the view.
   */

  AutoHeight.prototype.update = function () {
    var start = this._core._current,
        end = start + this._core.settings.items,
        lazyLoadEnabled = this._core.settings.lazyLoad,
        visible = this._core.$stage.children().toArray().slice(start, end),
        heights = [],
        maxheight = 0;

    $.each(visible, function (index, item) {
      heights.push($(item).height());
    });
    maxheight = Math.max.apply(null, heights);

    if (maxheight <= 1 && lazyLoadEnabled && this._previousHeight) {
      maxheight = this._previousHeight;
    }

    this._previousHeight = maxheight;

    this._core.$stage.parent().height(maxheight).addClass(this._core.settings.autoHeightClass);
  };

  AutoHeight.prototype.destroy = function () {
    var handler, property;

    for (handler in this._handlers) {
      this._core.$element.off(handler, this._handlers[handler]);
    }

    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] !== 'function' && (this[property] = null);
    }
  };

  $.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight;
})(window.Zepto || window.jQuery, window, document);
/**
 * Video Plugin
 * @version 2.3.4
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */


;

(function ($, window, document, undefined) {
  /**
   * Creates the video plugin.
   * @class The Video Plugin
   * @param {Owl} carousel - The Owl Carousel
   */
  var Video = function Video(carousel) {
    /**
     * Reference to the core.
     * @protected
     * @type {Owl}
     */
    this._core = carousel;
    /**
     * Cache all video URLs.
     * @protected
     * @type {Object}
     */

    this._videos = {};
    /**
     * Current playing item.
     * @protected
     * @type {jQuery}
     */

    this._playing = null;
    /**
     * All event handlers.
     * @todo The cloned content removale is too late
     * @protected
     * @type {Object}
     */

    this._handlers = {
      'initialized.owl.carousel': $.proxy(function (e) {
        if (e.namespace) {
          this._core.register({
            type: 'state',
            name: 'playing',
            tags: ['interacting']
          });
        }
      }, this),
      'resize.owl.carousel': $.proxy(function (e) {
        if (e.namespace && this._core.settings.video && this.isInFullScreen()) {
          e.preventDefault();
        }
      }, this),
      'refreshed.owl.carousel': $.proxy(function (e) {
        if (e.namespace && this._core.is('resizing')) {
          this._core.$stage.find('.cloned .owl-video-frame').remove();
        }
      }, this),
      'changed.owl.carousel': $.proxy(function (e) {
        if (e.namespace && e.property.name === 'position' && this._playing) {
          this.stop();
        }
      }, this),
      'prepared.owl.carousel': $.proxy(function (e) {
        if (!e.namespace) {
          return;
        }

        var $element = $(e.content).find('.owl-video');

        if ($element.length) {
          $element.css('display', 'none');
          this.fetch($element, $(e.content));
        }
      }, this)
    }; // set default options

    this._core.options = $.extend({}, Video.Defaults, this._core.options); // register event handlers

    this._core.$element.on(this._handlers);

    this._core.$element.on('click.owl.video', '.owl-video-play-icon', $.proxy(function (e) {
      this.play(e);
    }, this));
  };
  /**
   * Default options.
   * @public
   */


  Video.Defaults = {
    video: false,
    videoHeight: false,
    videoWidth: false
  };
  /**
   * Gets the video ID and the type (YouTube/Vimeo/vzaar only).
   * @protected
   * @param {jQuery} target - The target containing the video data.
   * @param {jQuery} item - The item containing the video.
   */

  Video.prototype.fetch = function (target, item) {
    var type = function () {
      if (target.attr('data-vimeo-id')) {
        return 'vimeo';
      } else if (target.attr('data-vzaar-id')) {
        return 'vzaar';
      } else {
        return 'youtube';
      }
    }(),
        id = target.attr('data-vimeo-id') || target.attr('data-youtube-id') || target.attr('data-vzaar-id'),
        width = target.attr('data-width') || this._core.settings.videoWidth,
        height = target.attr('data-height') || this._core.settings.videoHeight,
        url = target.attr('href');

    if (url) {
      /*
      		Parses the id's out of the following urls (and probably more):
      		https://www.youtube.com/watch?v=:id
      		https://youtu.be/:id
      		https://vimeo.com/:id
      		https://vimeo.com/channels/:channel/:id
      		https://vimeo.com/groups/:group/videos/:id
      		https://app.vzaar.com/videos/:id
      			Visual example: https://regexper.com/#(http%3A%7Chttps%3A%7C)%5C%2F%5C%2F(player.%7Cwww.%7Capp.)%3F(vimeo%5C.com%7Cyoutu(be%5C.com%7C%5C.be%7Cbe%5C.googleapis%5C.com)%7Cvzaar%5C.com)%5C%2F(video%5C%2F%7Cvideos%5C%2F%7Cembed%5C%2F%7Cchannels%5C%2F.%2B%5C%2F%7Cgroups%5C%2F.%2B%5C%2F%7Cwatch%5C%3Fv%3D%7Cv%5C%2F)%3F(%5BA-Za-z0-9._%25-%5D*)(%5C%26%5CS%2B)%3F
      */
      id = url.match(/(http:|https:|)\/\/(player.|www.|app.)?(vimeo\.com|youtu(be\.com|\.be|be\.googleapis\.com|be\-nocookie\.com)|vzaar\.com)\/(video\/|videos\/|embed\/|channels\/.+\/|groups\/.+\/|watch\?v=|v\/)?([A-Za-z0-9._%-]*)(\&\S+)?/);

      if (id[3].indexOf('youtu') > -1) {
        type = 'youtube';
      } else if (id[3].indexOf('vimeo') > -1) {
        type = 'vimeo';
      } else if (id[3].indexOf('vzaar') > -1) {
        type = 'vzaar';
      } else {
        throw new Error('Video URL not supported.');
      }

      id = id[6];
    } else {
      throw new Error('Missing video URL.');
    }

    this._videos[url] = {
      type: type,
      id: id,
      width: width,
      height: height
    };
    item.attr('data-video', url);
    this.thumbnail(target, this._videos[url]);
  };
  /**
   * Creates video thumbnail.
   * @protected
   * @param {jQuery} target - The target containing the video data.
   * @param {Object} info - The video info object.
   * @see `fetch`
   */


  Video.prototype.thumbnail = function (target, video) {
    var tnLink,
        icon,
        path,
        dimensions = video.width && video.height ? 'width:' + video.width + 'px;height:' + video.height + 'px;' : '',
        customTn = target.find('img'),
        srcType = 'src',
        lazyClass = '',
        settings = this._core.settings,
        create = function create(path) {
      icon = '<div class="owl-video-play-icon"></div>';

      if (settings.lazyLoad) {
        tnLink = $('<div/>', {
          "class": 'owl-video-tn ' + lazyClass,
          "srcType": path
        });
      } else {
        tnLink = $('<div/>', {
          "class": "owl-video-tn",
          "style": 'opacity:1;background-image:url(' + path + ')'
        });
      }

      target.after(tnLink);
      target.after(icon);
    }; // wrap video content into owl-video-wrapper div


    target.wrap($('<div/>', {
      "class": "owl-video-wrapper",
      "style": dimensions
    }));

    if (this._core.settings.lazyLoad) {
      srcType = 'data-src';
      lazyClass = 'owl-lazy';
    } // custom thumbnail


    if (customTn.length) {
      create(customTn.attr(srcType));
      customTn.remove();
      return false;
    }

    if (video.type === 'youtube') {
      path = "//img.youtube.com/vi/" + video.id + "/hqdefault.jpg";
      create(path);
    } else if (video.type === 'vimeo') {
      $.ajax({
        type: 'GET',
        url: '//vimeo.com/api/v2/video/' + video.id + '.json',
        jsonp: 'callback',
        dataType: 'jsonp',
        success: function success(data) {
          path = data[0].thumbnail_large;
          create(path);
        }
      });
    } else if (video.type === 'vzaar') {
      $.ajax({
        type: 'GET',
        url: '//vzaar.com/api/videos/' + video.id + '.json',
        jsonp: 'callback',
        dataType: 'jsonp',
        success: function success(data) {
          path = data.framegrab_url;
          create(path);
        }
      });
    }
  };
  /**
   * Stops the current video.
   * @public
   */


  Video.prototype.stop = function () {
    this._core.trigger('stop', null, 'video');

    this._playing.find('.owl-video-frame').remove();

    this._playing.removeClass('owl-video-playing');

    this._playing = null;

    this._core.leave('playing');

    this._core.trigger('stopped', null, 'video');
  };
  /**
   * Starts the current video.
   * @public
   * @param {Event} event - The event arguments.
   */


  Video.prototype.play = function (event) {
    var target = $(event.target),
        item = target.closest('.' + this._core.settings.itemClass),
        video = this._videos[item.attr('data-video')],
        width = video.width || '100%',
        height = video.height || this._core.$stage.height(),
        html,
        iframe;

    if (this._playing) {
      return;
    }

    this._core.enter('playing');

    this._core.trigger('play', null, 'video');

    item = this._core.items(this._core.relative(item.index()));

    this._core.reset(item.index());

    html = $('<iframe frameborder="0" allowfullscreen mozallowfullscreen webkitAllowFullScreen ></iframe>');
    html.attr('height', height);
    html.attr('width', width);

    if (video.type === 'youtube') {
      html.attr('src', '//www.youtube.com/embed/' + video.id + '?autoplay=1&rel=0&v=' + video.id);
    } else if (video.type === 'vimeo') {
      html.attr('src', '//player.vimeo.com/video/' + video.id + '?autoplay=1');
    } else if (video.type === 'vzaar') {
      html.attr('src', '//view.vzaar.com/' + video.id + '/player?autoplay=true');
    }

    iframe = $(html).wrap('<div class="owl-video-frame" />').insertAfter(item.find('.owl-video'));
    this._playing = item.addClass('owl-video-playing');
  };
  /**
   * Checks whether an video is currently in full screen mode or not.
   * @todo Bad style because looks like a readonly method but changes members.
   * @protected
   * @returns {Boolean}
   */


  Video.prototype.isInFullScreen = function () {
    var element = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;
    return element && $(element).parent().hasClass('owl-video-frame');
  };
  /**
   * Destroys the plugin.
   */


  Video.prototype.destroy = function () {
    var handler, property;

    this._core.$element.off('click.owl.video');

    for (handler in this._handlers) {
      this._core.$element.off(handler, this._handlers[handler]);
    }

    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != 'function' && (this[property] = null);
    }
  };

  $.fn.owlCarousel.Constructor.Plugins.Video = Video;
})(window.Zepto || window.jQuery, window, document);
/**
 * Animate Plugin
 * @version 2.3.4
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */


;

(function ($, window, document, undefined) {
  /**
   * Creates the animate plugin.
   * @class The Navigation Plugin
   * @param {Owl} scope - The Owl Carousel
   */
  var Animate = function Animate(scope) {
    this.core = scope;
    this.core.options = $.extend({}, Animate.Defaults, this.core.options);
    this.swapping = true;
    this.previous = undefined;
    this.next = undefined;
    this.handlers = {
      'change.owl.carousel': $.proxy(function (e) {
        if (e.namespace && e.property.name == 'position') {
          this.previous = this.core.current();
          this.next = e.property.value;
        }
      }, this),
      'drag.owl.carousel dragged.owl.carousel translated.owl.carousel': $.proxy(function (e) {
        if (e.namespace) {
          this.swapping = e.type == 'translated';
        }
      }, this),
      'translate.owl.carousel': $.proxy(function (e) {
        if (e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {
          this.swap();
        }
      }, this)
    };
    this.core.$element.on(this.handlers);
  };
  /**
   * Default options.
   * @public
   */


  Animate.Defaults = {
    animateOut: false,
    animateIn: false
  };
  /**
   * Toggles the animation classes whenever an translations starts.
   * @protected
   * @returns {Boolean|undefined}
   */

  Animate.prototype.swap = function () {
    if (this.core.settings.items !== 1) {
      return;
    }

    if (!$.support.animation || !$.support.transition) {
      return;
    }

    this.core.speed(0);
    var left,
        clear = $.proxy(this.clear, this),
        previous = this.core.$stage.children().eq(this.previous),
        next = this.core.$stage.children().eq(this.next),
        incoming = this.core.settings.animateIn,
        outgoing = this.core.settings.animateOut;

    if (this.core.current() === this.previous) {
      return;
    }

    if (outgoing) {
      left = this.core.coordinates(this.previous) - this.core.coordinates(this.next);
      previous.one($.support.animation.end, clear).css({
        'left': left + 'px'
      }).addClass('animated owl-animated-out').addClass(outgoing);
    }

    if (incoming) {
      next.one($.support.animation.end, clear).addClass('animated owl-animated-in').addClass(incoming);
    }
  };

  Animate.prototype.clear = function (e) {
    $(e.target).css({
      'left': ''
    }).removeClass('animated owl-animated-out owl-animated-in').removeClass(this.core.settings.animateIn).removeClass(this.core.settings.animateOut);
    this.core.onTransitionEnd();
  };
  /**
   * Destroys the plugin.
   * @public
   */


  Animate.prototype.destroy = function () {
    var handler, property;

    for (handler in this.handlers) {
      this.core.$element.off(handler, this.handlers[handler]);
    }

    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != 'function' && (this[property] = null);
    }
  };

  $.fn.owlCarousel.Constructor.Plugins.Animate = Animate;
})(window.Zepto || window.jQuery, window, document);
/**
 * Autoplay Plugin
 * @version 2.3.4
 * @author Bartosz Wojciechowski
 * @author Artus Kolanowski
 * @author David Deutsch
 * @author Tom De Caluwé
 * @license The MIT License (MIT)
 */


;

(function ($, window, document, undefined) {
  /**
   * Creates the autoplay plugin.
   * @class The Autoplay Plugin
   * @param {Owl} scope - The Owl Carousel
   */
  var Autoplay = function Autoplay(carousel) {
    /**
     * Reference to the core.
     * @protected
     * @type {Owl}
     */
    this._core = carousel;
    /**
     * The autoplay timeout id.
     * @type {Number}
     */

    this._call = null;
    /**
     * Depending on the state of the plugin, this variable contains either
     * the start time of the timer or the current timer value if it's
     * paused. Since we start in a paused state we initialize the timer
     * value.
     * @type {Number}
     */

    this._time = 0;
    /**
     * Stores the timeout currently used.
     * @type {Number}
     */

    this._timeout = 0;
    /**
     * Indicates whenever the autoplay is paused.
     * @type {Boolean}
     */

    this._paused = true;
    /**
     * All event handlers.
     * @protected
     * @type {Object}
     */

    this._handlers = {
      'changed.owl.carousel': $.proxy(function (e) {
        if (e.namespace && e.property.name === 'settings') {
          if (this._core.settings.autoplay) {
            this.play();
          } else {
            this.stop();
          }
        } else if (e.namespace && e.property.name === 'position' && this._paused) {
          // Reset the timer. This code is triggered when the position
          // of the carousel was changed through user interaction.
          this._time = 0;
        }
      }, this),
      'initialized.owl.carousel': $.proxy(function (e) {
        if (e.namespace && this._core.settings.autoplay) {
          this.play();
        }
      }, this),
      'play.owl.autoplay': $.proxy(function (e, t, s) {
        if (e.namespace) {
          this.play(t, s);
        }
      }, this),
      'stop.owl.autoplay': $.proxy(function (e) {
        if (e.namespace) {
          this.stop();
        }
      }, this),
      'mouseover.owl.autoplay': $.proxy(function () {
        if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
          this.pause();
        }
      }, this),
      'mouseleave.owl.autoplay': $.proxy(function () {
        if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
          this.play();
        }
      }, this),
      'touchstart.owl.core': $.proxy(function () {
        if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
          this.pause();
        }
      }, this),
      'touchend.owl.core': $.proxy(function () {
        if (this._core.settings.autoplayHoverPause) {
          this.play();
        }
      }, this)
    }; // register event handlers

    this._core.$element.on(this._handlers); // set default options


    this._core.options = $.extend({}, Autoplay.Defaults, this._core.options);
  };
  /**
   * Default options.
   * @public
   */


  Autoplay.Defaults = {
    autoplay: false,
    autoplayTimeout: 5000,
    autoplayHoverPause: false,
    autoplaySpeed: false
  };
  /**
   * Transition to the next slide and set a timeout for the next transition.
   * @private
   * @param {Number} [speed] - The animation speed for the animations.
   */

  Autoplay.prototype._next = function (speed) {
    this._call = window.setTimeout($.proxy(this._next, this, speed), this._timeout * (Math.round(this.read() / this._timeout) + 1) - this.read());

    if (this._core.is('interacting') || document.hidden) {
      return;
    }

    this._core.next(speed || this._core.settings.autoplaySpeed);
  };
  /**
   * Reads the current timer value when the timer is playing.
   * @public
   */


  Autoplay.prototype.read = function () {
    return new Date().getTime() - this._time;
  };
  /**
   * Starts the autoplay.
   * @public
   * @param {Number} [timeout] - The interval before the next animation starts.
   * @param {Number} [speed] - The animation speed for the animations.
   */


  Autoplay.prototype.play = function (timeout, speed) {
    var elapsed;

    if (!this._core.is('rotating')) {
      this._core.enter('rotating');
    }

    timeout = timeout || this._core.settings.autoplayTimeout; // Calculate the elapsed time since the last transition. If the carousel
    // wasn't playing this calculation will yield zero.

    elapsed = Math.min(this._time % (this._timeout || timeout), timeout);

    if (this._paused) {
      // Start the clock.
      this._time = this.read();
      this._paused = false;
    } else {
      // Clear the active timeout to allow replacement.
      window.clearTimeout(this._call);
    } // Adjust the origin of the timer to match the new timeout value.


    this._time += this.read() % timeout - elapsed;
    this._timeout = timeout;
    this._call = window.setTimeout($.proxy(this._next, this, speed), timeout - elapsed);
  };
  /**
   * Stops the autoplay.
   * @public
   */


  Autoplay.prototype.stop = function () {
    if (this._core.is('rotating')) {
      // Reset the clock.
      this._time = 0;
      this._paused = true;
      window.clearTimeout(this._call);

      this._core.leave('rotating');
    }
  };
  /**
   * Pauses the autoplay.
   * @public
   */


  Autoplay.prototype.pause = function () {
    if (this._core.is('rotating') && !this._paused) {
      // Pause the clock.
      this._time = this.read();
      this._paused = true;
      window.clearTimeout(this._call);
    }
  };
  /**
   * Destroys the plugin.
   */


  Autoplay.prototype.destroy = function () {
    var handler, property;
    this.stop();

    for (handler in this._handlers) {
      this._core.$element.off(handler, this._handlers[handler]);
    }

    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != 'function' && (this[property] = null);
    }
  };

  $.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;
})(window.Zepto || window.jQuery, window, document);
/**
 * Navigation Plugin
 * @version 2.3.4
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */


;

(function ($, window, document, undefined) {
  'use strict';
  /**
   * Creates the navigation plugin.
   * @class The Navigation Plugin
   * @param {Owl} carousel - The Owl Carousel.
   */

  var Navigation = function Navigation(carousel) {
    /**
     * Reference to the core.
     * @protected
     * @type {Owl}
     */
    this._core = carousel;
    /**
     * Indicates whether the plugin is initialized or not.
     * @protected
     * @type {Boolean}
     */

    this._initialized = false;
    /**
     * The current paging indexes.
     * @protected
     * @type {Array}
     */

    this._pages = [];
    /**
     * All DOM elements of the user interface.
     * @protected
     * @type {Object}
     */

    this._controls = {};
    /**
     * Markup for an indicator.
     * @protected
     * @type {Array.<String>}
     */

    this._templates = [];
    /**
     * The carousel element.
     * @type {jQuery}
     */

    this.$element = this._core.$element;
    /**
     * Overridden methods of the carousel.
     * @protected
     * @type {Object}
     */

    this._overrides = {
      next: this._core.next,
      prev: this._core.prev,
      to: this._core.to
    };
    /**
     * All event handlers.
     * @protected
     * @type {Object}
     */

    this._handlers = {
      'prepared.owl.carousel': $.proxy(function (e) {
        if (e.namespace && this._core.settings.dotsData) {
          this._templates.push('<div class="' + this._core.settings.dotClass + '">' + $(e.content).find('[data-dot]').addBack('[data-dot]').attr('data-dot') + '</div>');
        }
      }, this),
      'added.owl.carousel': $.proxy(function (e) {
        if (e.namespace && this._core.settings.dotsData) {
          this._templates.splice(e.position, 0, this._templates.pop());
        }
      }, this),
      'remove.owl.carousel': $.proxy(function (e) {
        if (e.namespace && this._core.settings.dotsData) {
          this._templates.splice(e.position, 1);
        }
      }, this),
      'changed.owl.carousel': $.proxy(function (e) {
        if (e.namespace && e.property.name == 'position') {
          this.draw();
        }
      }, this),
      'initialized.owl.carousel': $.proxy(function (e) {
        if (e.namespace && !this._initialized) {
          this._core.trigger('initialize', null, 'navigation');

          this.initialize();
          this.update();
          this.draw();
          this._initialized = true;

          this._core.trigger('initialized', null, 'navigation');
        }
      }, this),
      'refreshed.owl.carousel': $.proxy(function (e) {
        if (e.namespace && this._initialized) {
          this._core.trigger('refresh', null, 'navigation');

          this.update();
          this.draw();

          this._core.trigger('refreshed', null, 'navigation');
        }
      }, this)
    }; // set default options

    this._core.options = $.extend({}, Navigation.Defaults, this._core.options); // register event handlers

    this.$element.on(this._handlers);
  };
  /**
   * Default options.
   * @public
   * @todo Rename `slideBy` to `navBy`
   */


  Navigation.Defaults = {
    nav: false,
    navText: ['<span aria-label="' + 'Previous' + '">&#x2039;</span>', '<span aria-label="' + 'Next' + '">&#x203a;</span>'],
    navSpeed: false,
    navElement: 'button type="button" role="presentation"',
    navContainer: false,
    navContainerClass: 'owl-nav',
    navClass: ['owl-prev', 'owl-next'],
    slideBy: 1,
    dotClass: 'owl-dot',
    dotsClass: 'owl-dots',
    dots: true,
    dotsEach: false,
    dotsData: false,
    dotsSpeed: false,
    dotsContainer: false
  };
  /**
   * Initializes the layout of the plugin and extends the carousel.
   * @protected
   */

  Navigation.prototype.initialize = function () {
    var override,
        settings = this._core.settings; // create DOM structure for relative navigation

    this._controls.$relative = (settings.navContainer ? $(settings.navContainer) : $('<div>').addClass(settings.navContainerClass).appendTo(this.$element)).addClass('disabled');
    this._controls.$previous = $('<' + settings.navElement + '>').addClass(settings.navClass[0]).html(settings.navText[0]).prependTo(this._controls.$relative).on('click', $.proxy(function (e) {
      this.prev(settings.navSpeed);
    }, this));
    this._controls.$next = $('<' + settings.navElement + '>').addClass(settings.navClass[1]).html(settings.navText[1]).appendTo(this._controls.$relative).on('click', $.proxy(function (e) {
      this.next(settings.navSpeed);
    }, this)); // create DOM structure for absolute navigation

    if (!settings.dotsData) {
      this._templates = [$('<button role="button">').addClass(settings.dotClass).append($('<span>')).prop('outerHTML')];
    }

    this._controls.$absolute = (settings.dotsContainer ? $(settings.dotsContainer) : $('<div>').addClass(settings.dotsClass).appendTo(this.$element)).addClass('disabled');

    this._controls.$absolute.on('click', 'button', $.proxy(function (e) {
      var index = $(e.target).parent().is(this._controls.$absolute) ? $(e.target).index() : $(e.target).parent().index();
      e.preventDefault();
      this.to(index, settings.dotsSpeed);
    }, this));
    /*$el.on('focusin', function() {
    	$(document).off(".carousel");
    		$(document).on('keydown.carousel', function(e) {
    		if(e.keyCode == 37) {
    			$el.trigger('prev.owl')
    		}
    		if(e.keyCode == 39) {
    			$el.trigger('next.owl')
    		}
    	});
    });*/
    // override public methods of the carousel


    for (override in this._overrides) {
      this._core[override] = $.proxy(this[override], this);
    }
  };
  /**
   * Destroys the plugin.
   * @protected
   */


  Navigation.prototype.destroy = function () {
    var handler, control, property, override, settings;
    settings = this._core.settings;

    for (handler in this._handlers) {
      this.$element.off(handler, this._handlers[handler]);
    }

    for (control in this._controls) {
      if (control === '$relative' && settings.navContainer) {
        this._controls[control].html('');
      } else {
        this._controls[control].remove();
      }
    }

    for (override in this.overides) {
      this._core[override] = this._overrides[override];
    }

    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != 'function' && (this[property] = null);
    }
  };
  /**
   * Updates the internal state.
   * @protected
   */


  Navigation.prototype.update = function () {
    var i,
        j,
        k,
        lower = this._core.clones().length / 2,
        upper = lower + this._core.items().length,
        maximum = this._core.maximum(true),
        settings = this._core.settings,
        size = settings.center || settings.autoWidth || settings.dotsData ? 1 : settings.dotsEach || settings.items;

    if (settings.slideBy !== 'page') {
      settings.slideBy = Math.min(settings.slideBy, settings.items);
    }

    if (settings.dots || settings.slideBy == 'page') {
      this._pages = [];

      for (i = lower, j = 0, k = 0; i < upper; i++) {
        if (j >= size || j === 0) {
          this._pages.push({
            start: Math.min(maximum, i - lower),
            end: i - lower + size - 1
          });

          if (Math.min(maximum, i - lower) === maximum) {
            break;
          }

          j = 0, ++k;
        }

        j += this._core.mergers(this._core.relative(i));
      }
    }
  };
  /**
   * Draws the user interface.
   * @todo The option `dotsData` wont work.
   * @protected
   */


  Navigation.prototype.draw = function () {
    var difference,
        settings = this._core.settings,
        disabled = this._core.items().length <= settings.items,
        index = this._core.relative(this._core.current()),
        loop = settings.loop || settings.rewind;

    this._controls.$relative.toggleClass('disabled', !settings.nav || disabled);

    if (settings.nav) {
      this._controls.$previous.toggleClass('disabled', !loop && index <= this._core.minimum(true));

      this._controls.$next.toggleClass('disabled', !loop && index >= this._core.maximum(true));
    }

    this._controls.$absolute.toggleClass('disabled', !settings.dots || disabled);

    if (settings.dots) {
      difference = this._pages.length - this._controls.$absolute.children().length;

      if (settings.dotsData && difference !== 0) {
        this._controls.$absolute.html(this._templates.join(''));
      } else if (difference > 0) {
        this._controls.$absolute.append(new Array(difference + 1).join(this._templates[0]));
      } else if (difference < 0) {
        this._controls.$absolute.children().slice(difference).remove();
      }

      this._controls.$absolute.find('.active').removeClass('active');

      this._controls.$absolute.children().eq($.inArray(this.current(), this._pages)).addClass('active');
    }
  };
  /**
   * Extends event data.
   * @protected
   * @param {Event} event - The event object which gets thrown.
   */


  Navigation.prototype.onTrigger = function (event) {
    var settings = this._core.settings;
    event.page = {
      index: $.inArray(this.current(), this._pages),
      count: this._pages.length,
      size: settings && (settings.center || settings.autoWidth || settings.dotsData ? 1 : settings.dotsEach || settings.items)
    };
  };
  /**
   * Gets the current page position of the carousel.
   * @protected
   * @returns {Number}
   */


  Navigation.prototype.current = function () {
    var current = this._core.relative(this._core.current());

    return $.grep(this._pages, $.proxy(function (page, index) {
      return page.start <= current && page.end >= current;
    }, this)).pop();
  };
  /**
   * Gets the current succesor/predecessor position.
   * @protected
   * @returns {Number}
   */


  Navigation.prototype.getPosition = function (successor) {
    var position,
        length,
        settings = this._core.settings;

    if (settings.slideBy == 'page') {
      position = $.inArray(this.current(), this._pages);
      length = this._pages.length;
      successor ? ++position : --position;
      position = this._pages[(position % length + length) % length].start;
    } else {
      position = this._core.relative(this._core.current());
      length = this._core.items().length;
      successor ? position += settings.slideBy : position -= settings.slideBy;
    }

    return position;
  };
  /**
   * Slides to the next item or page.
   * @public
   * @param {Number} [speed=false] - The time in milliseconds for the transition.
   */


  Navigation.prototype.next = function (speed) {
    $.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);
  };
  /**
   * Slides to the previous item or page.
   * @public
   * @param {Number} [speed=false] - The time in milliseconds for the transition.
   */


  Navigation.prototype.prev = function (speed) {
    $.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);
  };
  /**
   * Slides to the specified item or page.
   * @public
   * @param {Number} position - The position of the item or page.
   * @param {Number} [speed] - The time in milliseconds for the transition.
   * @param {Boolean} [standard=false] - Whether to use the standard behaviour or not.
   */


  Navigation.prototype.to = function (position, speed, standard) {
    var length;

    if (!standard && this._pages.length) {
      length = this._pages.length;
      $.proxy(this._overrides.to, this._core)(this._pages[(position % length + length) % length].start, speed);
    } else {
      $.proxy(this._overrides.to, this._core)(position, speed);
    }
  };

  $.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation;
})(window.Zepto || window.jQuery, window, document);
/**
 * Hash Plugin
 * @version 2.3.4
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */


;

(function ($, window, document, undefined) {
  'use strict';
  /**
   * Creates the hash plugin.
   * @class The Hash Plugin
   * @param {Owl} carousel - The Owl Carousel
   */

  var Hash = function Hash(carousel) {
    /**
     * Reference to the core.
     * @protected
     * @type {Owl}
     */
    this._core = carousel;
    /**
     * Hash index for the items.
     * @protected
     * @type {Object}
     */

    this._hashes = {};
    /**
     * The carousel element.
     * @type {jQuery}
     */

    this.$element = this._core.$element;
    /**
     * All event handlers.
     * @protected
     * @type {Object}
     */

    this._handlers = {
      'initialized.owl.carousel': $.proxy(function (e) {
        if (e.namespace && this._core.settings.startPosition === 'URLHash') {
          $(window).trigger('hashchange.owl.navigation');
        }
      }, this),
      'prepared.owl.carousel': $.proxy(function (e) {
        if (e.namespace) {
          var hash = $(e.content).find('[data-hash]').addBack('[data-hash]').attr('data-hash');

          if (!hash) {
            return;
          }

          this._hashes[hash] = e.content;
        }
      }, this),
      'changed.owl.carousel': $.proxy(function (e) {
        if (e.namespace && e.property.name === 'position') {
          var current = this._core.items(this._core.relative(this._core.current())),
              hash = $.map(this._hashes, function (item, hash) {
            return item === current ? hash : null;
          }).join();

          if (!hash || window.location.hash.slice(1) === hash) {
            return;
          }

          window.location.hash = hash;
        }
      }, this)
    }; // set default options

    this._core.options = $.extend({}, Hash.Defaults, this._core.options); // register the event handlers

    this.$element.on(this._handlers); // register event listener for hash navigation

    $(window).on('hashchange.owl.navigation', $.proxy(function (e) {
      var hash = window.location.hash.substring(1),
          items = this._core.$stage.children(),
          position = this._hashes[hash] && items.index(this._hashes[hash]);

      if (position === undefined || position === this._core.current()) {
        return;
      }

      this._core.to(this._core.relative(position), false, true);
    }, this));
  };
  /**
   * Default options.
   * @public
   */


  Hash.Defaults = {
    URLhashListener: false
  };
  /**
   * Destroys the plugin.
   * @public
   */

  Hash.prototype.destroy = function () {
    var handler, property;
    $(window).off('hashchange.owl.navigation');

    for (handler in this._handlers) {
      this._core.$element.off(handler, this._handlers[handler]);
    }

    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != 'function' && (this[property] = null);
    }
  };

  $.fn.owlCarousel.Constructor.Plugins.Hash = Hash;
})(window.Zepto || window.jQuery, window, document);
/**
 * Support Plugin
 *
 * @version 2.3.4
 * @author Vivid Planet Software GmbH
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */


;

(function ($, window, document, undefined) {
  var style = $('<support>').get(0).style,
      prefixes = 'Webkit Moz O ms'.split(' '),
      events = {
    transition: {
      end: {
        WebkitTransition: 'webkitTransitionEnd',
        MozTransition: 'transitionend',
        OTransition: 'oTransitionEnd',
        transition: 'transitionend'
      }
    },
    animation: {
      end: {
        WebkitAnimation: 'webkitAnimationEnd',
        MozAnimation: 'animationend',
        OAnimation: 'oAnimationEnd',
        animation: 'animationend'
      }
    }
  },
      tests = {
    csstransforms: function csstransforms() {
      return !!test('transform');
    },
    csstransforms3d: function csstransforms3d() {
      return !!test('perspective');
    },
    csstransitions: function csstransitions() {
      return !!test('transition');
    },
    cssanimations: function cssanimations() {
      return !!test('animation');
    }
  };

  function test(property, prefixed) {
    var result = false,
        upper = property.charAt(0).toUpperCase() + property.slice(1);
    $.each((property + ' ' + prefixes.join(upper + ' ') + upper).split(' '), function (i, property) {
      if (style[property] !== undefined) {
        result = prefixed ? property : true;
        return false;
      }
    });
    return result;
  }

  function prefixed(property) {
    return test(property, true);
  }

  if (tests.csstransitions()) {
    /* jshint -W053 */
    $.support.transition = new String(prefixed('transition'));
    $.support.transition.end = events.transition.end[$.support.transition];
  }

  if (tests.cssanimations()) {
    /* jshint -W053 */
    $.support.animation = new String(prefixed('animation'));
    $.support.animation.end = events.animation.end[$.support.animation];
  }

  if (tests.csstransforms()) {
    /* jshint -W053 */
    $.support.transform = new String(prefixed('transform'));
    $.support.transform3d = tests.csstransforms3d();
  }
})(window.Zepto || window.jQuery, window, document);

/***/ }),

/***/ "./node_modules/popper.js/dist/esm/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/popper.js/dist/esm/popper.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.0
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

var timeoutDuration = function () {
  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];

  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      return 1;
    }
  }

  return 0;
}();

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }

    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;
/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/

var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */

function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}
/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */


function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  } // NOTE: 1 DOM access here


  var window = element.ownerDocument.defaultView;
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}
/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */


function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }

  return element.parentNode || element.host;
}
/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */


function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;

    case '#document':
      return element.body;
  } // Firefox want us to check `-x` and `-y` variations as well


  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}
/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */


function getReferenceNode(reference) {
  return reference && reference.referenceNode ? reference.referenceNode : reference;
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */

function isIE(version) {
  if (version === 11) {
    return isIE11;
  }

  if (version === 10) {
    return isIE10;
  }

  return isIE11 || isIE10;
}
/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */


function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null; // NOTE: 1 DOM access here

  var offsetParent = element.offsetParent || null; // Skip hidden elements which don't have an offsetParent

  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  } // .offsetParent will return the closest TH, TD or TABLE in case
  // no offsetParent is present, I hate this job...


  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }

  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}
/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */


function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}
/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */


function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  } // Here we make sure to give as "start" the element that comes first in the DOM


  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1; // Get common ancestor container

  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer; // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  } // one of the nodes is inside shadowDOM, find which one


  var element1root = getRoot(element1);

  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}
/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */


function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}
/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */


function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}
/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */


function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';
  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
}

function getWindowSizes(document) {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);
  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var defineProperty = function defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};
/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */


function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}
/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */


function getBoundingClientRect(element) {
  var rect = {}; // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11

  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  }; // subtract scrollbar size from sizes

  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.width;
  var height = sizes.height || element.clientHeight || result.height;
  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height; // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons

  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');
    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);
  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10); // In cases where the parent is fixed, we must ignore negative scroll in offset calc

  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }

  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0; // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.

  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop, 10);
    var marginLeft = parseFloat(styles.marginLeft, 10);
    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft; // Attach marginTop and marginLeft because in some circumstances we may need them

    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);
  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;
  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };
  return getClientRect(offset);
}
/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */


function isFixed(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }

  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }

  var parentNode = getParentNode(element);

  if (!parentNode) {
    return false;
  }

  return isFixed(parentNode);
}
/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */


function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }

  var el = element.parentElement;

  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }

  return el || document.documentElement;
}
/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */


function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false; // NOTE: 1 DOM access here

  var boundaries = {
    top: 0,
    left: 0
  };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference)); // Handle viewport case

  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;

    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));

      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition); // In case of HTML, we need a different computation

    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  } // Add paddings


  padding = padding || 0;
  var isPaddingNumber = typeof padding === 'number';
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;
  return width * height;
}
/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };
  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });
  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });
  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
  var variation = placement.split('-')[1];
  return computedPlacement + (variation ? '-' + variation : '');
}
/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */


function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}
/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */


function getOuterSizes(element) {
  var window = element.ownerDocument.defaultView;
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}
/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */


function getOppositePlacement(placement) {
  var hash = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
  };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}
/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */


function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0]; // Get popper node sizes

  var popperRect = getOuterSizes(popper); // Add position, width and height to our offsets object

  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  }; // depending by the popper placement we have to compute its offsets slightly differently

  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';
  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;

  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}
/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */


function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  } // use `filter` to obtain the same behavior of `find`


  return arr.filter(check)[0];
}
/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */


function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  } // use `find` + `indexOf` if `findIndex` isn't supported


  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}
/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */


function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));
  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }

    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation

    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);
      data = fn(data, modifier);
    }
  });
  return data;
}
/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */


function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  }; // compute reference element offsets

  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed); // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value

  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding); // store the computed placement inside `originalPlacement`

  data.originalPlacement = data.placement;
  data.positionFixed = this.options.positionFixed; // compute the popper offsets

  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute'; // run the modifiers

  data = runModifiers(this.modifiers, data); // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback

  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}
/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */


function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}
/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */


function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;

    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }

  return null;
}
/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */


function destroy() {
  this.state.isDestroyed = true; // touch DOM only if `applyStyle` modifier is enabled

  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners(); // remove the popper if user explicitly asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it

  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }

  return this;
}
/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */


function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, {
    passive: true
  });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }

  scrollParents.push(target);
}
/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */


function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, {
    passive: true
  }); // Scroll event listener on scroll parents

  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;
  return state;
}
/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */


function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}
/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */


function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound); // Remove scroll event listener on scroll parents

  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  }); // Reset state

  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}
/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */


function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}
/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */


function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}
/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */


function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = ''; // add unit if the value is numeric and is one of the following

    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }

    element.style[prop] = styles[prop] + unit;
  });
}
/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */


function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];

    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */


function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles); // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element

  setAttributes(data.instance.popper, data.attributes); // if arrowElement is defined and arrowStyles has some properties

  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}
/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */


function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed); // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value

  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
  popper.setAttribute('x-placement', placement); // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations

  setStyles(popper, {
    position: options.positionFixed ? 'fixed' : 'absolute'
  });
  return options;
}
/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */


function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var round = Math.round,
      floor = Math.floor;

  var noRound = function noRound(v) {
    return v;
  };

  var referenceWidth = round(reference.width);
  var popperWidth = round(popper.width);
  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf('-') !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;
  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}

var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */

function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper; // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;

  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }

  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent); // Styles

  var styles = {
    position: popper.position
  };
  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right'; // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed

  var prefixedProperty = getSupportedPropertyName('transform'); // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.

  var left = void 0,
      top = void 0;

  if (sideA === 'bottom') {
    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
    // and not the bottom of the html element
    if (offsetParent.nodeName === 'HTML') {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }

  if (sideB === 'right') {
    if (offsetParent.nodeName === 'HTML') {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }

  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  } // Attributes


  var attributes = {
    'x-placement': data.placement
  }; // Update `data` attributes, styles and arrowStyles

  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
  return data;
}
/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */


function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });
  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';

    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }

  return isRequired;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function arrow(data, options) {
  var _data$offsets$arrow; // arrow depends on keepTogether in order to work


  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element; // if arrowElement is a string, suppose it's a CSS selector

  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement); // if arrowElement is not found, don't run the modifier

    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var isVertical = ['left', 'right'].indexOf(placement) !== -1;
  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len]; //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjunction
  //
  // top/left side

  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  } // bottom/right side


  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }

  data.offsets.popper = getClientRect(data.offsets.popper); // compute center of the popper

  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2; // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available

  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide; // prevent arrowElement from being placed not contiguously to its popper

  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);
  return data;
}
/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */


function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }

  return variation;
}
/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */


var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start']; // Get rid of `auto` `auto-start` and `auto-end`

var validPlacements = placements.slice(3);
/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */

function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */

function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';
  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;

    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;

    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;

    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);
    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference; // using floor because the reference offsets may contain decimals we are not going to consider here

    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);
    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom; // flip the variation if required

    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1; // flips variation if reference element overflows boundaries

    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom); // flips variation if popper content overflows boundaries

    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);
    var flippedVariation = flippedVariationByRef || flippedVariationByContent;

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : ''); // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future

      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }

  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}
/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */


function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2]; // If it's not a number it's an operator, I guess

  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;

    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;

      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;

    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }

    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}
/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */


function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0]; // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one

  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1; // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)

  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  }); // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space

  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  } // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.


  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments]; // Convert the values with units to absolute pixels to allow our computations

  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, []) // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  }); // Loop trough the offsets arrays and execute the operations

  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */


function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var basePlacement = placement.split('-')[0];
  var offsets = void 0;

  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper); // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken

  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  } // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself


  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification

  var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];
  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';
  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed); // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed

  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;
  options.boundaries = boundaries;
  var order = options.priority;
  var popper = data.offsets.popper;
  var check = {
    primary: function primary(placement) {
      var value = popper[placement];

      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }

      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];

      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }

      return defineProperty({}, mainSide, value);
    }
  };
  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });
  data.offsets.popper = popper;
  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1]; // if shift shiftvariation is specified, run the modifier

  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;
    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';
    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };
    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;
  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;
  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);
  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);
  return data;
}
/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */


var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: offset,

    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: preventOverflow,

    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],

    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,

    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: arrow,

    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: flip,

    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: 'flip',

    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,

    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: 'viewport',

    /**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariations: false,

    /**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariationsByContent: false
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,

    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,

    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: computeStyle,

    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,

    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',

    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: applyStyle,

    /** @prop {Function} */
    onLoad: applyStyleOnLoad,

    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: undefined
  }
};
/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */

var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers: modifiers
};
/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */
// Utils
// Methods

var Popper = function () {
  /**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    }; // make update() debounced, so that it only runs at most once-per-tick


    this.update = debounce(this.update.bind(this)); // with {} we create a new object with the options inside it

    this.options = _extends({}, Popper.Defaults, options); // init state

    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    }; // get reference and popper elements (allow jQuery wrappers)

    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper; // Deep merge modifiers options

    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    }); // Refactoring modifiers' list (Object => Array)

    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    }) // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    }); // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!

    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    }); // fire the first update to position the popper in the right place

    this.update();
    var eventsEnabled = this.options.eventsEnabled;

    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  } // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }
    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */

    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();
/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;
/* harmony default export */ __webpack_exports__["default"] = (Popper);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "./src/js/main.js":
/*!************************!*\
  !*** ./src/js/main.js ***!
  \************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "jquery");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var bootstrap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bootstrap */ "./node_modules/bootstrap/dist/js/bootstrap.js");
/* harmony import */ var bootstrap__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(bootstrap__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var owl_carousel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! owl.carousel */ "./node_modules/owl.carousel/dist/owl.carousel.js");
/* harmony import */ var owl_carousel__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(owl_carousel__WEBPACK_IMPORTED_MODULE_2__);

 // j'importe bootstrap.js depuis node_modules


jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).ready(function () {
  var js_accordion = jquery__WEBPACK_IMPORTED_MODULE_0___default()(".js-accordion"),
      collapse_trigger = js_accordion.find(".btn-link");

  if (js_accordion.length > 0) {
    //   Open first accordion by default
    js_accordion.find(".card").first().find(".collapse").css("display", "block"); //   Add class expanded on first accordion by default

    js_accordion.find(".card").first().find(".btn-link").addClass("expanded"); //   click event for accordion

    collapse_trigger.click(function () {
      var currentCollapse = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).closest(".card").find(".collapse"),
          remainingCollapse = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).closest(js_accordion).find(".collapse").not(currentCollapse),
          remainingBtn = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).closest(js_accordion).find(".btn-link").not(this); //     toggle the clicked accordion

      currentCollapse.slideToggle();
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).toggleClass("expanded"); //     close all other accordion if any.

      remainingCollapse.slideUp();
      remainingBtn.removeClass("expanded");
    });
  }

  jquery__WEBPACK_IMPORTED_MODULE_0___default()(".carousel_partenaires").owlCarousel({
    items: 3,
    loop: true,
    margin: 30,
    nav: true,
    navText: ['<i class="fa fa-chevron-left fa-2x" aria-hidden="true"></i>', '<i class="fa fa-chevron-right fa-2x" aria-hidden="true"></i>'],
    responsive: {
      0: {
        items: 1
      },
      768: {
        items: 2
      },
      992: {
        items: 3
      }
    }
  });
});

/***/ }),

/***/ 0:
/*!******************************!*\
  !*** multi ./src/js/main.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! /Volumes/Data/Formation DCPro/PROJET/eval_mod2/integration/projetEatIt/src/js/main.js */"./src/js/main.js");


/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = jQuery;

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4uLy4uL2pzL3NyYy91dGlsLmpzIiwid2VicGFjazovLy8uLi8uLi9qcy9zcmMvYWxlcnQuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL2pzL3NyYy9idXR0b24uanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL2pzL3NyYy9jYXJvdXNlbC5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vanMvc3JjL2NvbGxhcHNlLmpzIiwid2VicGFjazovLy8uLi8uLi9qcy9zcmMvZHJvcGRvd24uanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL2pzL3NyYy9tb2RhbC5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vanMvc3JjL3Rvb2xzL3Nhbml0aXplci5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vanMvc3JjL3Rvb2x0aXAuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL2pzL3NyYy9wb3BvdmVyLmpzIiwid2VicGFjazovLy8uLi8uLi9qcy9zcmMvc2Nyb2xsc3B5LmpzIiwid2VicGFjazovLy8uLi8uLi9qcy9zcmMvdGFiLmpzIiwid2VicGFjazovLy8uLi8uLi9qcy9zcmMvdG9hc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL293bC5jYXJvdXNlbC9kaXN0L293bC5jYXJvdXNlbC5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL2lzQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL2RlYm91bmNlLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvdXRpbHMvaXNGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL2dldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL2dldFBhcmVudE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRTY3JvbGxQYXJlbnQuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRSZWZlcmVuY2VOb2RlLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvdXRpbHMvaXNJRS5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL2dldE9mZnNldFBhcmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL2lzT2Zmc2V0Q29udGFpbmVyLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvdXRpbHMvZ2V0Um9vdC5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL2ZpbmRDb21tb25PZmZzZXRQYXJlbnQuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRTY3JvbGwuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9pbmNsdWRlU2Nyb2xsLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvdXRpbHMvZ2V0Qm9yZGVyc1NpemUuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRXaW5kb3dTaXplcy5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL2dldENsaWVudFJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9pc0ZpeGVkLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvdXRpbHMvZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudC5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL2dldEJvdW5kYXJpZXMuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL2dldFJlZmVyZW5jZU9mZnNldHMuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRPdXRlclNpemVzLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRQb3BwZXJPZmZzZXRzLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvdXRpbHMvZmluZC5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL2ZpbmRJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL3J1bk1vZGlmaWVycy5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL21ldGhvZHMvdXBkYXRlLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvdXRpbHMvaXNNb2RpZmllckVuYWJsZWQuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9tZXRob2RzL2Rlc3Ryb3kuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRXaW5kb3cuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9zZXR1cEV2ZW50TGlzdGVuZXJzLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvbWV0aG9kcy9lbmFibGVFdmVudExpc3RlbmVycy5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL3JlbW92ZUV2ZW50TGlzdGVuZXJzLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvbWV0aG9kcy9kaXNhYmxlRXZlbnRMaXN0ZW5lcnMuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9pc051bWVyaWMuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9zZXRTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9zZXRBdHRyaWJ1dGVzLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvbW9kaWZpZXJzL2FwcGx5U3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRSb3VuZGVkT2Zmc2V0cy5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL21vZGlmaWVycy9jb21wdXRlU3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9pc01vZGlmaWVyUmVxdWlyZWQuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9tb2RpZmllcnMvYXJyb3cuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL21ldGhvZHMvcGxhY2VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL2Nsb2Nrd2lzZS5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL21vZGlmaWVycy9mbGlwLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvbW9kaWZpZXJzL2tlZXBUb2dldGhlci5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL21vZGlmaWVycy9vZmZzZXQuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvbW9kaWZpZXJzL3NoaWZ0LmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvbW9kaWZpZXJzL2hpZGUuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9tb2RpZmllcnMvaW5uZXIuanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9tb2RpZmllcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9tZXRob2RzL2RlZmF1bHRzLmpzIiwid2VicGFjazovLy8uLi8uLi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbWFpbi5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJqUXVlcnlcIiJdLCJuYW1lcyI6WyJUUkFOU0lUSU9OX0VORCIsIk1BWF9VSUQiLCJNSUxMSVNFQ09ORFNfTVVMVElQTElFUiIsImJpbmRUeXBlIiwiZGVsZWdhdGVUeXBlIiwiaGFuZGxlIiwiJCIsImV2ZW50IiwiY2FsbGVkIiwiVXRpbCIsInNldFRpbWVvdXQiLCJnZXRTcGVjaWFsVHJhbnNpdGlvbkVuZEV2ZW50IiwiZ2V0VUlEIiwicHJlZml4IiwiTWF0aCIsImRvY3VtZW50IiwiZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCIsInNlbGVjdG9yIiwiZWxlbWVudCIsImhyZWZBdHRyIiwiZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQiLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJ0cmFuc2l0aW9uRGVsYXkiLCJmbG9hdFRyYW5zaXRpb25EdXJhdGlvbiIsInBhcnNlRmxvYXQiLCJmbG9hdFRyYW5zaXRpb25EZWxheSIsInJlZmxvdyIsInRyaWdnZXJUcmFuc2l0aW9uRW5kIiwic3VwcG9ydHNUcmFuc2l0aW9uRW5kIiwiQm9vbGVhbiIsImlzRWxlbWVudCIsIm9iaiIsInR5cGVDaGVja0NvbmZpZyIsIk9iamVjdCIsImV4cGVjdGVkVHlwZXMiLCJjb25maWdUeXBlcyIsInZhbHVlIiwiY29uZmlnIiwidmFsdWVUeXBlIiwidG9UeXBlIiwiY29tcG9uZW50TmFtZSIsImZpbmRTaGFkb3dSb290Iiwicm9vdCIsImpRdWVyeURldGVjdGlvbiIsInZlcnNpb24iLCJtaW5NYWpvciIsImx0TWFqb3IiLCJtaW5NaW5vciIsIm1pblBhdGNoIiwibWF4TWFqb3IiLCJzZXRUcmFuc2l0aW9uRW5kU3VwcG9ydCIsIk5BTUUiLCJWRVJTSU9OIiwiREFUQV9LRVkiLCJFVkVOVF9LRVkiLCJEQVRBX0FQSV9LRVkiLCJKUVVFUllfTk9fQ09ORkxJQ1QiLCJTZWxlY3RvciIsIkRJU01JU1MiLCJFdmVudCIsIkNMT1NFIiwiQ0xPU0VEIiwiQ0xJQ0tfREFUQV9BUEkiLCJDbGFzc05hbWUiLCJBTEVSVCIsIkZBREUiLCJTSE9XIiwiQWxlcnQiLCJjbG9zZSIsInJvb3RFbGVtZW50IiwiY3VzdG9tRXZlbnQiLCJkaXNwb3NlIiwiX2dldFJvb3RFbGVtZW50IiwicGFyZW50IiwiX3RyaWdnZXJDbG9zZUV2ZW50IiwiY2xvc2VFdmVudCIsIl9yZW1vdmVFbGVtZW50IiwiX2Rlc3Ryb3lFbGVtZW50IiwiX2pRdWVyeUludGVyZmFjZSIsIiRlbGVtZW50IiwiZGF0YSIsIl9oYW5kbGVEaXNtaXNzIiwiYWxlcnRJbnN0YW5jZSIsIkFDVElWRSIsIkJVVFRPTiIsIkZPQ1VTIiwiREFUQV9UT0dHTEVfQ0FSUk9UIiwiREFUQV9UT0dHTEVTIiwiREFUQV9UT0dHTEUiLCJEQVRBX1RPR0dMRVNfQlVUVE9OUyIsIklOUFVUIiwiRk9DVVNfQkxVUl9EQVRBX0FQSSIsIkxPQURfREFUQV9BUEkiLCJCdXR0b24iLCJ0b2dnbGUiLCJ0cmlnZ2VyQ2hhbmdlRXZlbnQiLCJhZGRBcmlhUHJlc3NlZCIsImlucHV0IiwiYWN0aXZlRWxlbWVudCIsImJ1dHRvbiIsImlucHV0QnRuIiwiYnV0dG9ucyIsImkiLCJsZW4iLCJBUlJPV19MRUZUX0tFWUNPREUiLCJBUlJPV19SSUdIVF9LRVlDT0RFIiwiVE9VQ0hFVkVOVF9DT01QQVRfV0FJVCIsIlNXSVBFX1RIUkVTSE9MRCIsIkRlZmF1bHQiLCJpbnRlcnZhbCIsImtleWJvYXJkIiwic2xpZGUiLCJwYXVzZSIsIndyYXAiLCJ0b3VjaCIsIkRlZmF1bHRUeXBlIiwiRGlyZWN0aW9uIiwiTkVYVCIsIlBSRVYiLCJMRUZUIiwiUklHSFQiLCJTTElERSIsIlNMSUQiLCJLRVlET1dOIiwiTU9VU0VFTlRFUiIsIk1PVVNFTEVBVkUiLCJUT1VDSFNUQVJUIiwiVE9VQ0hNT1ZFIiwiVE9VQ0hFTkQiLCJQT0lOVEVSRE9XTiIsIlBPSU5URVJVUCIsIkRSQUdfU1RBUlQiLCJDQVJPVVNFTCIsIklURU0iLCJQT0lOVEVSX0VWRU5UIiwiQUNUSVZFX0lURU0iLCJJVEVNX0lNRyIsIk5FWFRfUFJFViIsIklORElDQVRPUlMiLCJEQVRBX1NMSURFIiwiREFUQV9SSURFIiwiUG9pbnRlclR5cGUiLCJUT1VDSCIsIlBFTiIsIkNhcm91c2VsIiwibmF2aWdhdG9yIiwid2luZG93IiwibmV4dCIsIm5leHRXaGVuVmlzaWJsZSIsInByZXYiLCJjbGVhckludGVydmFsIiwiY3ljbGUiLCJzZXRJbnRlcnZhbCIsInRvIiwiYWN0aXZlSW5kZXgiLCJpbmRleCIsImRpcmVjdGlvbiIsIl9nZXRDb25maWciLCJfaGFuZGxlU3dpcGUiLCJhYnNEZWx0YXgiLCJfYWRkRXZlbnRMaXN0ZW5lcnMiLCJfYWRkVG91Y2hFdmVudExpc3RlbmVycyIsInN0YXJ0IiwibW92ZSIsImVuZCIsImNsZWFyVGltZW91dCIsImUiLCJfa2V5ZG93biIsIl9nZXRJdGVtSW5kZXgiLCJfZ2V0SXRlbUJ5RGlyZWN0aW9uIiwiaXNOZXh0RGlyZWN0aW9uIiwiaXNQcmV2RGlyZWN0aW9uIiwibGFzdEl0ZW1JbmRleCIsImlzR29pbmdUb1dyYXAiLCJkZWx0YSIsIml0ZW1JbmRleCIsIl90cmlnZ2VyU2xpZGVFdmVudCIsInRhcmdldEluZGV4IiwiZnJvbUluZGV4Iiwic2xpZGVFdmVudCIsInJlbGF0ZWRUYXJnZXQiLCJmcm9tIiwiX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQiLCJpbmRpY2F0b3JzIiwibmV4dEluZGljYXRvciIsIl9zbGlkZSIsImFjdGl2ZUVsZW1lbnRJbmRleCIsIm5leHRFbGVtZW50IiwibmV4dEVsZW1lbnRJbmRleCIsImlzQ3ljbGluZyIsImRpcmVjdGlvbmFsQ2xhc3NOYW1lIiwib3JkZXJDbGFzc05hbWUiLCJldmVudERpcmVjdGlvbk5hbWUiLCJzbGlkRXZlbnQiLCJuZXh0RWxlbWVudEludGVydmFsIiwicGFyc2VJbnQiLCJfY29uZmlnIiwiYWN0aW9uIiwiX2RhdGFBcGlDbGlja0hhbmRsZXIiLCJ0YXJnZXQiLCJzbGlkZUluZGV4IiwiY2Fyb3VzZWxzIiwiJGNhcm91c2VsIiwiU0hPV04iLCJISURFIiwiSElEREVOIiwiQ09MTEFQU0UiLCJDT0xMQVBTSU5HIiwiQ09MTEFQU0VEIiwiRGltZW5zaW9uIiwiV0lEVEgiLCJIRUlHSFQiLCJBQ1RJVkVTIiwiQ29sbGFwc2UiLCJ0b2dnbGVMaXN0IiwiZWxlbSIsImZpbHRlckVsZW1lbnQiLCJmb3VuZEVsZW0iLCJzaG93IiwiYWN0aXZlcyIsImFjdGl2ZXNEYXRhIiwic3RhcnRFdmVudCIsImRpbWVuc2lvbiIsImNvbXBsZXRlIiwiY2FwaXRhbGl6ZWREaW1lbnNpb24iLCJzY3JvbGxTaXplIiwiaGlkZSIsInRyaWdnZXJBcnJheUxlbmd0aCIsInRyaWdnZXIiLCIkZWxlbSIsInNldFRyYW5zaXRpb25pbmciLCJfZ2V0RGltZW5zaW9uIiwiaGFzV2lkdGgiLCJfZ2V0UGFyZW50IiwiY2hpbGRyZW4iLCJfYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzIiwiaXNPcGVuIiwidHJpZ2dlckFycmF5IiwiX2dldFRhcmdldEZyb21FbGVtZW50IiwiJHRoaXMiLCIkdHJpZ2dlciIsInNlbGVjdG9ycyIsIiR0YXJnZXQiLCJFU0NBUEVfS0VZQ09ERSIsIlNQQUNFX0tFWUNPREUiLCJUQUJfS0VZQ09ERSIsIkFSUk9XX1VQX0tFWUNPREUiLCJBUlJPV19ET1dOX0tFWUNPREUiLCJSSUdIVF9NT1VTRV9CVVRUT05fV0hJQ0giLCJSRUdFWFBfS0VZRE9XTiIsIkNMSUNLIiwiS0VZRE9XTl9EQVRBX0FQSSIsIktFWVVQX0RBVEFfQVBJIiwiRElTQUJMRUQiLCJEUk9QVVAiLCJEUk9QUklHSFQiLCJEUk9QTEVGVCIsIk1FTlVSSUdIVCIsIk1FTlVMRUZUIiwiUE9TSVRJT05fU1RBVElDIiwiRk9STV9DSElMRCIsIk1FTlUiLCJOQVZCQVJfTkFWIiwiVklTSUJMRV9JVEVNUyIsIkF0dGFjaG1lbnRNYXAiLCJUT1AiLCJUT1BFTkQiLCJCT1RUT00iLCJCT1RUT01FTkQiLCJSSUdIVEVORCIsIkxFRlRFTkQiLCJvZmZzZXQiLCJmbGlwIiwiYm91bmRhcnkiLCJyZWZlcmVuY2UiLCJkaXNwbGF5IiwicG9wcGVyQ29uZmlnIiwiRHJvcGRvd24iLCJpc0FjdGl2ZSIsInVzZVBvcHBlciIsIl9lbGVtZW50Iiwic2hvd0V2ZW50IiwicmVmZXJlbmNlRWxlbWVudCIsImhpZGVFdmVudCIsInVwZGF0ZSIsIl9nZXRNZW51RWxlbWVudCIsIl9nZXRQbGFjZW1lbnQiLCIkcGFyZW50RHJvcGRvd24iLCJwbGFjZW1lbnQiLCJfZGV0ZWN0TmF2YmFyIiwiX2dldE9mZnNldCIsIl9nZXRQb3BwZXJDb25maWciLCJtb2RpZmllcnMiLCJlbmFibGVkIiwicHJldmVudE92ZXJmbG93IiwiYm91bmRhcmllc0VsZW1lbnQiLCJfY2xlYXJNZW51cyIsInRvZ2dsZXMiLCJjb250ZXh0IiwiZHJvcGRvd25NZW51IiwiX2dldFBhcmVudEZyb21FbGVtZW50IiwiX2RhdGFBcGlLZXlkb3duSGFuZGxlciIsIml0ZW1zIiwiYmFja2Ryb3AiLCJmb2N1cyIsIkhJREVfUFJFVkVOVEVEIiwiRk9DVVNJTiIsIlJFU0laRSIsIkNMSUNLX0RJU01JU1MiLCJLRVlET1dOX0RJU01JU1MiLCJNT1VTRVVQX0RJU01JU1MiLCJNT1VTRURPV05fRElTTUlTUyIsIlNDUk9MTEFCTEUiLCJTQ1JPTExCQVJfTUVBU1VSRVIiLCJCQUNLRFJPUCIsIk9QRU4iLCJTVEFUSUMiLCJESUFMT0ciLCJNT0RBTF9CT0RZIiwiREFUQV9ESVNNSVNTIiwiRklYRURfQ09OVEVOVCIsIlNUSUNLWV9DT05URU5UIiwiTW9kYWwiLCJ0cmFuc2l0aW9uIiwiaGFuZGxlVXBkYXRlIiwiX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24iLCJoaWRlRXZlbnRQcmV2ZW50ZWQiLCJtb2RhbFRyYW5zaXRpb25EdXJhdGlvbiIsIl9zaG93RWxlbWVudCIsIm1vZGFsQm9keSIsIk5vZGUiLCJzaG93bkV2ZW50IiwidHJhbnNpdGlvbkNvbXBsZXRlIiwiX2VuZm9yY2VGb2N1cyIsIl9zZXRFc2NhcGVFdmVudCIsIl9zZXRSZXNpemVFdmVudCIsIl9oaWRlTW9kYWwiLCJfcmVtb3ZlQmFja2Ryb3AiLCJfc2hvd0JhY2tkcm9wIiwiYW5pbWF0ZSIsImNhbGxiYWNrIiwiYmFja2Ryb3BUcmFuc2l0aW9uRHVyYXRpb24iLCJjYWxsYmFja1JlbW92ZSIsIl9hZGp1c3REaWFsb2ciLCJpc01vZGFsT3ZlcmZsb3dpbmciLCJfcmVzZXRBZGp1c3RtZW50cyIsIl9jaGVja1Njcm9sbGJhciIsInJlY3QiLCJfc2V0U2Nyb2xsYmFyIiwiZml4ZWRDb250ZW50Iiwic3RpY2t5Q29udGVudCIsImFjdHVhbFBhZGRpbmciLCJjYWxjdWxhdGVkUGFkZGluZyIsImFjdHVhbE1hcmdpbiIsImNhbGN1bGF0ZWRNYXJnaW4iLCJfcmVzZXRTY3JvbGxiYXIiLCJwYWRkaW5nIiwiZWxlbWVudHMiLCJtYXJnaW4iLCJfZ2V0U2Nyb2xsYmFyV2lkdGgiLCJzY3JvbGxEaXYiLCJzY3JvbGxiYXJXaWR0aCIsInVyaUF0dHJzIiwiQVJJQV9BVFRSSUJVVEVfUEFUVEVSTiIsIkRlZmF1bHRXaGl0ZWxpc3QiLCJhIiwiYXJlYSIsImIiLCJiciIsImNvbCIsImNvZGUiLCJkaXYiLCJlbSIsImhyIiwiaDEiLCJoMiIsImgzIiwiaDQiLCJoNSIsImg2IiwiaW1nIiwibGkiLCJvbCIsInAiLCJwcmUiLCJzIiwic21hbGwiLCJzcGFuIiwic3ViIiwic3VwIiwic3Ryb25nIiwidSIsInVsIiwiU0FGRV9VUkxfUEFUVEVSTiIsIkRBVEFfVVJMX1BBVFRFUk4iLCJhdHRyTmFtZSIsImF0dHIiLCJhbGxvd2VkQXR0cmlidXRlTGlzdCIsInJlZ0V4cCIsImF0dHJSZWdleCIsImwiLCJ1bnNhZmVIdG1sIiwic2FuaXRpemVGbiIsImRvbVBhcnNlciIsImNyZWF0ZWREb2N1bWVudCIsIndoaXRlbGlzdEtleXMiLCJlbCIsImVsTmFtZSIsImF0dHJpYnV0ZUxpc3QiLCJ3aGl0ZWxpc3RlZEF0dHJpYnV0ZXMiLCJ3aGl0ZUxpc3QiLCJhbGxvd2VkQXR0cmlidXRlIiwiQ0xBU1NfUFJFRklYIiwiQlNDTFNfUFJFRklYX1JFR0VYIiwiRElTQUxMT1dFRF9BVFRSSUJVVEVTIiwiYW5pbWF0aW9uIiwidGVtcGxhdGUiLCJ0aXRsZSIsImRlbGF5IiwiaHRtbCIsImNvbnRhaW5lciIsImZhbGxiYWNrUGxhY2VtZW50Iiwic2FuaXRpemUiLCJBVVRPIiwiSG92ZXJTdGF0ZSIsIk9VVCIsIklOU0VSVEVEIiwiRk9DVVNPVVQiLCJUT09MVElQIiwiVE9PTFRJUF9JTk5FUiIsIkFSUk9XIiwiVHJpZ2dlciIsIkhPVkVSIiwiTUFOVUFMIiwiVG9vbHRpcCIsImVuYWJsZSIsImRpc2FibGUiLCJ0b2dnbGVFbmFibGVkIiwiZGF0YUtleSIsInNoYWRvd1Jvb3QiLCJpc0luVGhlRG9tIiwidGlwIiwidGlwSWQiLCJhdHRhY2htZW50IiwicHJldkhvdmVyU3RhdGUiLCJpc1dpdGhDb250ZW50IiwiYWRkQXR0YWNobWVudENsYXNzIiwiZ2V0VGlwRWxlbWVudCIsInNldENvbnRlbnQiLCJzZXRFbGVtZW50Q29udGVudCIsImNvbnRlbnQiLCJzYW5pdGl6ZUh0bWwiLCJnZXRUaXRsZSIsImRlZmF1bHRCc0NvbmZpZyIsImJlaGF2aW9yIiwiYXJyb3ciLCJvbkNyZWF0ZSIsIm9uVXBkYXRlIiwiX2dldENvbnRhaW5lciIsIl9nZXRBdHRhY2htZW50IiwiX3NldExpc3RlbmVycyIsInRyaWdnZXJzIiwiZXZlbnRJbiIsImV2ZW50T3V0IiwiX2ZpeFRpdGxlIiwidGl0bGVUeXBlIiwiX2VudGVyIiwiX2xlYXZlIiwiX2lzV2l0aEFjdGl2ZVRyaWdnZXIiLCJkYXRhQXR0cmlidXRlcyIsIl9nZXREZWxlZ2F0ZUNvbmZpZyIsIl9jbGVhblRpcENsYXNzIiwiJHRpcCIsInRhYkNsYXNzIiwiX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZSIsInBvcHBlckluc3RhbmNlIiwicG9wcGVyRGF0YSIsIl9maXhUcmFuc2l0aW9uIiwiaW5pdENvbmZpZ0FuaW1hdGlvbiIsIlRJVExFIiwiQ09OVEVOVCIsIlBvcG92ZXIiLCJfZ2V0Q29udGVudCIsIm1ldGhvZCIsIkFDVElWQVRFIiwiU0NST0xMIiwiRFJPUERPV05fSVRFTSIsIkRST1BET1dOX01FTlUiLCJEQVRBX1NQWSIsIk5BVl9MSVNUX0dST1VQIiwiTkFWX0xJTktTIiwiTkFWX0lURU1TIiwiTElTVF9JVEVNUyIsIkRST1BET1dOIiwiRFJPUERPV05fSVRFTVMiLCJEUk9QRE9XTl9UT0dHTEUiLCJPZmZzZXRNZXRob2QiLCJPRkZTRVQiLCJQT1NJVElPTiIsIlNjcm9sbFNweSIsInJlZnJlc2giLCJhdXRvTWV0aG9kIiwib2Zmc2V0TWV0aG9kIiwib2Zmc2V0QmFzZSIsInRhcmdldHMiLCJ0YXJnZXRTZWxlY3RvciIsInRhcmdldEJDUiIsIml0ZW0iLCJpZCIsIl9nZXRTY3JvbGxUb3AiLCJfZ2V0U2Nyb2xsSGVpZ2h0IiwiX2dldE9mZnNldEhlaWdodCIsIl9wcm9jZXNzIiwic2Nyb2xsVG9wIiwic2Nyb2xsSGVpZ2h0IiwibWF4U2Nyb2xsIiwib2Zmc2V0TGVuZ3RoIiwiaXNBY3RpdmVUYXJnZXQiLCJfYWN0aXZhdGUiLCJxdWVyaWVzIiwiJGxpbmsiLCJfY2xlYXIiLCJub2RlIiwic2Nyb2xsU3B5cyIsInNjcm9sbFNweXNMZW5ndGgiLCIkc3B5IiwiQUNUSVZFX1VMIiwiRFJPUERPV05fQUNUSVZFX0NISUxEIiwiVGFiIiwibGlzdEVsZW1lbnQiLCJpdGVtU2VsZWN0b3IiLCJwcmV2aW91cyIsImhpZGRlbkV2ZW50IiwiYWN0aXZlRWxlbWVudHMiLCJhY3RpdmUiLCJpc1RyYW5zaXRpb25pbmciLCJfdHJhbnNpdGlvbkNvbXBsZXRlIiwiZHJvcGRvd25DaGlsZCIsImRyb3Bkb3duRWxlbWVudCIsImRyb3Bkb3duVG9nZ2xlTGlzdCIsIlNIT1dJTkciLCJhdXRvaGlkZSIsIlRvYXN0IiwiX2Nsb3NlIiwidW5kZWZpbmVkIiwiT3dsIiwib3B0aW9ucyIsInNldHRpbmdzIiwiZXh0ZW5kIiwiRGVmYXVsdHMiLCJfaGFuZGxlcnMiLCJfcGx1Z2lucyIsIl9zdXByZXNzIiwiX2N1cnJlbnQiLCJfc3BlZWQiLCJfY29vcmRpbmF0ZXMiLCJfYnJlYWtwb2ludCIsIl93aWR0aCIsIl9pdGVtcyIsIl9jbG9uZXMiLCJfbWVyZ2VycyIsIl93aWR0aHMiLCJfaW52YWxpZGF0ZWQiLCJfcGlwZSIsIl9kcmFnIiwidGltZSIsInBvaW50ZXIiLCJzdGFnZSIsImN1cnJlbnQiLCJfc3RhdGVzIiwidGFncyIsImVhY2giLCJwcm94eSIsImhhbmRsZXIiLCJQbHVnaW5zIiwia2V5IiwicGx1Z2luIiwiY2hhckF0IiwidG9Mb3dlckNhc2UiLCJzbGljZSIsIldvcmtlcnMiLCJwcmlvcml0eSIsIndvcmtlciIsInB1c2giLCJmaWx0ZXIiLCJydW4iLCJzZXR1cCIsImluaXRpYWxpemUiLCJsb29wIiwiY2VudGVyIiwicmV3aW5kIiwiY2hlY2tWaXNpYmlsaXR5IiwibW91c2VEcmFnIiwidG91Y2hEcmFnIiwicHVsbERyYWciLCJmcmVlRHJhZyIsInN0YWdlUGFkZGluZyIsIm1lcmdlIiwibWVyZ2VGaXQiLCJhdXRvV2lkdGgiLCJzdGFydFBvc2l0aW9uIiwicnRsIiwic21hcnRTcGVlZCIsImZsdWlkU3BlZWQiLCJkcmFnRW5kU3BlZWQiLCJyZXNwb25zaXZlIiwicmVzcG9uc2l2ZVJlZnJlc2hSYXRlIiwicmVzcG9uc2l2ZUJhc2VFbGVtZW50IiwiZmFsbGJhY2tFYXNpbmciLCJzbGlkZVRyYW5zaXRpb24iLCJpbmZvIiwibmVzdGVkSXRlbVNlbGVjdG9yIiwiaXRlbUVsZW1lbnQiLCJzdGFnZUVsZW1lbnQiLCJyZWZyZXNoQ2xhc3MiLCJsb2FkZWRDbGFzcyIsImxvYWRpbmdDbGFzcyIsInJ0bENsYXNzIiwicmVzcG9uc2l2ZUNsYXNzIiwiZHJhZ0NsYXNzIiwiaXRlbUNsYXNzIiwic3RhZ2VDbGFzcyIsInN0YWdlT3V0ZXJDbGFzcyIsImdyYWJDbGFzcyIsIldpZHRoIiwiSW5uZXIiLCJPdXRlciIsIlR5cGUiLCJTdGF0ZSIsIndpZHRoIiwiY2FjaGUiLCJyZWxhdGl2ZSIsIiRzdGFnZSIsInJlbW92ZSIsImdyaWQiLCJjc3MiLCJ0b0ZpeGVkIiwiaXRlcmF0b3IiLCJsZW5ndGgiLCJ3aWR0aHMiLCJtaW4iLCJjbG9uZXMiLCJ2aWV3IiwibWF4Iiwic2l6ZSIsImNlaWwiLCJyZXBlYXQiLCJhcHBlbmQiLCJwcmVwZW5kIiwibm9ybWFsaXplIiwib3V0ZXJIVE1MIiwiYWRkQ2xhc3MiLCJhcHBlbmRUbyIsInByZXBlbmRUbyIsImNvb3JkaW5hdGVzIiwiYWJzIiwiZXEiLCJyZW1vdmVBdHRyIiwibWluaW11bSIsIm1heGltdW0iLCJyZXNldCIsImJlZ2luIiwiaW5uZXIiLCJvdXRlciIsIm1hdGNoZXMiLCJuIiwib3AiLCJyZW1vdmVDbGFzcyIsImpvaW4iLCJwcm90b3R5cGUiLCJpbml0aWFsaXplU3RhZ2UiLCJmaW5kIiwiaW5pdGlhbGl6ZUl0ZW1zIiwiJGl0ZW1zIiwiZ2V0IiwibWFwIiwicmVwbGFjZSIsIm5vdCIsImlzVmlzaWJsZSIsImludmFsaWRhdGUiLCJlbnRlciIsInRvZ2dsZUNsYXNzIiwiaXMiLCJpbWdzIiwibmVzdGVkU2VsZWN0b3IiLCJwcmVsb2FkQXV0b1dpZHRoSW1hZ2VzIiwicmVnaXN0ZXJFdmVudEhhbmRsZXJzIiwibGVhdmUiLCJ2aWV3cG9ydCIsIm92ZXJ3cml0ZXMiLCJtYXRjaCIsImJyZWFrcG9pbnQiLCJOdW1iZXIiLCJSZWdFeHAiLCJwcm9wZXJ0eSIsIm5hbWUiLCJvcHRpb25zTG9naWMiLCJwcmVwYXJlIiwiYWxsIiwiZ3JlcCIsIm9uVGhyb3R0bGVkUmVzaXplIiwicmVzaXplVGltZXIiLCJvblJlc2l6ZSIsImlzRGVmYXVsdFByZXZlbnRlZCIsInN1cHBvcnQiLCJvbiIsIm9uVHJhbnNpdGlvbkVuZCIsIm9uRHJhZ1N0YXJ0Iiwib25EcmFnRW5kIiwid2hpY2giLCJ0cmFuc2Zvcm0iLCJzcGxpdCIsIngiLCJ5IiwicG9zaXRpb24iLCJsZWZ0IiwidG9wIiwic3RvcCIsInR5cGUiLCJzcGVlZCIsIkRhdGUiLCJnZXRUaW1lIiwib25lIiwiZGlmZmVyZW5jZSIsIm9uRHJhZ01vdmUiLCJwcmV2ZW50RGVmYXVsdCIsInB1bGwiLCJvZmYiLCJjbG9zZXN0IiwiY29vcmRpbmF0ZSIsInRyYW5zZm9ybTNkIiwic3RhdGUiLCJwYXJ0IiwidiIsInN1cHByZXNzIiwicmVsZWFzZSIsIm0iLCJpc051bWVyaWMiLCJyZWNpcHJvY2FsSXRlbXNXaWR0aCIsImVsZW1lbnRXaWR0aCIsIm1lcmdlcnMiLCJvZGQiLCJldmVuIiwibXVsdGlwbGllciIsIm5ld1Bvc2l0aW9uIiwiZHVyYXRpb24iLCJmYWN0b3IiLCJyZXZlcnQiLCJkaXN0YW5jZSIsInN0b3BQcm9wYWdhdGlvbiIsInNyY0VsZW1lbnQiLCJvcmlnaW5hbFRhcmdldCIsImlubmVyV2lkdGgiLCJkb2N1bWVudEVsZW1lbnQiLCJjbGllbnRXaWR0aCIsImNvbnNvbGUiLCJ3YXJuIiwiZW1wdHkiLCJqUXVlcnkiLCJub2RlVHlwZSIsImFkZEJhY2siLCJhZGQiLCJhZnRlciIsImJlZm9yZSIsInNwbGljZSIsImltYWdlcyIsIkltYWdlIiwic3JjIiwiZGVzdHJveSIsInVud3JhcCIsImNvbnRlbnRzIiwicmVtb3ZlRGF0YSIsIm8iLCJsaXN0ZW5lciIsImNhcHR1cmUiLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGV0YWNoRXZlbnQiLCJuYW1lc3BhY2UiLCJzdGF0dXMiLCJjb3VudCIsImNhbWVsQ2FzZSIsIm9uVHJpZ2dlciIsInJlZ2lzdGVyIiwiY2FsbCIsImNvbmNhdCIsIm9iamVjdCIsInNwZWNpYWwiLCJvd2wiLCJfZGVmYXVsdCIsImFwcGx5IiwiaW5kZXhPZiIsImFyZ3VtZW50cyIsInRhZyIsImluQXJyYXkiLCJldmVudHMiLCJyZXN1bHQiLCJvcmlnaW5hbEV2ZW50IiwidG91Y2hlcyIsImNoYW5nZWRUb3VjaGVzIiwicGFnZVgiLCJwYWdlWSIsImNsaWVudFgiLCJjbGllbnRZIiwibnVtYmVyIiwiaXNOYU4iLCJmaXJzdCIsInNlY29uZCIsImZuIiwib3dsQ2Fyb3VzZWwiLCJvcHRpb24iLCJhcmdzIiwiQXJyYXkiLCJDb25zdHJ1Y3RvciIsIlplcHRvIiwiQXV0b1JlZnJlc2giLCJjYXJvdXNlbCIsIl9jb3JlIiwiX2ludGVydmFsIiwiX3Zpc2libGUiLCJhdXRvUmVmcmVzaCIsIndhdGNoIiwiYXV0b1JlZnJlc2hJbnRlcnZhbCIsImdldE93blByb3BlcnR5TmFtZXMiLCJMYXp5IiwiX2xvYWRlZCIsImxhenlMb2FkIiwibG9hZCIsImxhenlMb2FkRWFnZXIiLCIkaXRlbSIsIiRlbGVtZW50cyIsImltYWdlIiwidXJsIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIm9ubG9hZCIsImhhbmRsZXJzIiwiQXV0b0hlaWdodCIsIl9wcmV2aW91c0hlaWdodCIsImF1dG9IZWlnaHQiLCJfaW50ZXJ2YWxJZCIsInJlZlRoaXMiLCJyZXNpemUiLCJhdXRvSGVpZ2h0Q2xhc3MiLCJsYXp5TG9hZEVuYWJsZWQiLCJ2aXNpYmxlIiwidG9BcnJheSIsImhlaWdodHMiLCJtYXhoZWlnaHQiLCJoZWlnaHQiLCJWaWRlbyIsIl92aWRlb3MiLCJfcGxheWluZyIsInZpZGVvIiwiaXNJbkZ1bGxTY3JlZW4iLCJmZXRjaCIsInBsYXkiLCJ2aWRlb0hlaWdodCIsInZpZGVvV2lkdGgiLCJFcnJvciIsInRodW1ibmFpbCIsInRuTGluayIsImljb24iLCJwYXRoIiwiZGltZW5zaW9ucyIsImN1c3RvbVRuIiwic3JjVHlwZSIsImxhenlDbGFzcyIsImNyZWF0ZSIsImFqYXgiLCJqc29ucCIsImRhdGFUeXBlIiwic3VjY2VzcyIsInRodW1ibmFpbF9sYXJnZSIsImZyYW1lZ3JhYl91cmwiLCJpZnJhbWUiLCJpbnNlcnRBZnRlciIsImZ1bGxzY3JlZW5FbGVtZW50IiwibW96RnVsbFNjcmVlbkVsZW1lbnQiLCJ3ZWJraXRGdWxsc2NyZWVuRWxlbWVudCIsImhhc0NsYXNzIiwiQW5pbWF0ZSIsInNjb3BlIiwiY29yZSIsInN3YXBwaW5nIiwiYW5pbWF0ZU91dCIsImFuaW1hdGVJbiIsInN3YXAiLCJjbGVhciIsImluY29taW5nIiwib3V0Z29pbmciLCJBdXRvcGxheSIsIl9jYWxsIiwiX3RpbWUiLCJfdGltZW91dCIsIl9wYXVzZWQiLCJhdXRvcGxheSIsInQiLCJhdXRvcGxheUhvdmVyUGF1c2UiLCJhdXRvcGxheVRpbWVvdXQiLCJhdXRvcGxheVNwZWVkIiwiX25leHQiLCJyb3VuZCIsInJlYWQiLCJoaWRkZW4iLCJ0aW1lb3V0IiwiZWxhcHNlZCIsIk5hdmlnYXRpb24iLCJfaW5pdGlhbGl6ZWQiLCJfcGFnZXMiLCJfY29udHJvbHMiLCJfdGVtcGxhdGVzIiwiX292ZXJyaWRlcyIsImRvdHNEYXRhIiwiZG90Q2xhc3MiLCJwb3AiLCJkcmF3IiwibmF2IiwibmF2VGV4dCIsIm5hdlNwZWVkIiwibmF2RWxlbWVudCIsIm5hdkNvbnRhaW5lciIsIm5hdkNvbnRhaW5lckNsYXNzIiwibmF2Q2xhc3MiLCJzbGlkZUJ5IiwiZG90c0NsYXNzIiwiZG90cyIsImRvdHNFYWNoIiwiZG90c1NwZWVkIiwiZG90c0NvbnRhaW5lciIsIm92ZXJyaWRlIiwiJHJlbGF0aXZlIiwiJHByZXZpb3VzIiwiJG5leHQiLCJwcm9wIiwiJGFic29sdXRlIiwiY29udHJvbCIsIm92ZXJpZGVzIiwiaiIsImsiLCJsb3dlciIsInVwcGVyIiwiZGlzYWJsZWQiLCJwYWdlIiwiZ2V0UG9zaXRpb24iLCJzdWNjZXNzb3IiLCJzdGFuZGFyZCIsIkhhc2giLCJfaGFzaGVzIiwiaGFzaCIsImxvY2F0aW9uIiwic3Vic3RyaW5nIiwiVVJMaGFzaExpc3RlbmVyIiwic3R5bGUiLCJwcmVmaXhlcyIsIldlYmtpdFRyYW5zaXRpb24iLCJNb3pUcmFuc2l0aW9uIiwiT1RyYW5zaXRpb24iLCJXZWJraXRBbmltYXRpb24iLCJNb3pBbmltYXRpb24iLCJPQW5pbWF0aW9uIiwidGVzdHMiLCJjc3N0cmFuc2Zvcm1zIiwidGVzdCIsImNzc3RyYW5zZm9ybXMzZCIsImNzc3RyYW5zaXRpb25zIiwiY3NzYW5pbWF0aW9ucyIsInByZWZpeGVkIiwidG9VcHBlckNhc2UiLCJTdHJpbmciLCJ0aW1lb3V0RHVyYXRpb24iLCJsb25nZXJUaW1lb3V0QnJvd3NlcnMiLCJpc0Jyb3dzZXIiLCJzY2hlZHVsZWQiLCJzdXBwb3J0c01pY3JvVGFza3MiLCJnZXRUeXBlIiwiZnVuY3Rpb25Ub0NoZWNrIiwiZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5Iiwib3ZlcmZsb3ciLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJnZXRTY3JvbGxQYXJlbnQiLCJnZXRQYXJlbnROb2RlIiwiaXNJRTExIiwiaXNJRTEwIiwibm9PZmZzZXRQYXJlbnQiLCJpc0lFIiwib2Zmc2V0UGFyZW50Iiwibm9kZU5hbWUiLCJnZXRPZmZzZXRQYXJlbnQiLCJnZXRSb290IiwiZWxlbWVudDEiLCJlbGVtZW50MiIsIm9yZGVyIiwicmFuZ2UiLCJjb21tb25BbmNlc3RvckNvbnRhaW5lciIsImlzT2Zmc2V0Q29udGFpbmVyIiwiZWxlbWVudDFyb290IiwiZmluZENvbW1vbk9mZnNldFBhcmVudCIsInNpZGUiLCJ1cHBlclNpZGUiLCJzY3JvbGxpbmdFbGVtZW50Iiwic3VidHJhY3QiLCJnZXRTY3JvbGwiLCJzY3JvbGxMZWZ0IiwibW9kaWZpZXIiLCJzaWRlQSIsImF4aXMiLCJzaWRlQiIsInN0eWxlcyIsImJvZHkiLCJjb21wdXRlZFN0eWxlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFNpemUiLCJvZmZzZXRzIiwic2l6ZXMiLCJnZXRXaW5kb3dTaXplcyIsImhvcml6U2Nyb2xsYmFyIiwidmVydFNjcm9sbGJhciIsImdldEJvcmRlcnNTaXplIiwiZ2V0Q2xpZW50UmVjdCIsImZpeGVkUG9zaXRpb24iLCJydW5Jc0lFIiwiaXNIVE1MIiwiY2hpbGRyZW5SZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicGFyZW50UmVjdCIsInNjcm9sbFBhcmVudCIsImJvcmRlclRvcFdpZHRoIiwiYm9yZGVyTGVmdFdpZHRoIiwibWFyZ2luVG9wIiwibWFyZ2luTGVmdCIsImluY2x1ZGVTY3JvbGwiLCJleGNsdWRlU2Nyb2xsIiwicmVsYXRpdmVPZmZzZXQiLCJnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUiLCJwYXJlbnROb2RlIiwiaXNGaXhlZCIsImJvdW5kYXJpZXMiLCJnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50IiwiZ2V0UmVmZXJlbmNlTm9kZSIsImdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZSIsImJvdW5kYXJpZXNOb2RlIiwicG9wcGVyIiwiaXNQYWRkaW5nTnVtYmVyIiwiZ2V0Qm91bmRhcmllcyIsInJlY3RzIiwicmVmUmVjdCIsImJvdHRvbSIsInNvcnRlZEFyZWFzIiwiZ2V0QXJlYSIsImZpbHRlcmVkQXJlYXMiLCJjb21wdXRlZFBsYWNlbWVudCIsInZhcmlhdGlvbiIsImNvbW1vbk9mZnNldFBhcmVudCIsInJpZ2h0IiwicG9wcGVyUmVjdCIsImdldE91dGVyU2l6ZXMiLCJwb3BwZXJPZmZzZXRzIiwiaXNIb3JpeiIsIm1haW5TaWRlIiwic2Vjb25kYXJ5U2lkZSIsIm1lYXN1cmVtZW50Iiwic2Vjb25kYXJ5TWVhc3VyZW1lbnQiLCJyZWZlcmVuY2VPZmZzZXRzIiwiZ2V0T3Bwb3NpdGVQbGFjZW1lbnQiLCJhcnIiLCJjdXIiLCJtb2RpZmllcnNUb1J1biIsImVuZHMiLCJmaW5kSW5kZXgiLCJpc0Z1bmN0aW9uIiwiZ2V0UmVmZXJlbmNlT2Zmc2V0cyIsImNvbXB1dGVBdXRvUGxhY2VtZW50IiwiZ2V0UG9wcGVyT2Zmc2V0cyIsInJ1bk1vZGlmaWVycyIsInVwcGVyUHJvcCIsInRvQ2hlY2siLCJpc01vZGlmaWVyRW5hYmxlZCIsImdldFN1cHBvcnRlZFByb3BlcnR5TmFtZSIsIm93bmVyRG9jdW1lbnQiLCJpc0JvZHkiLCJwYXNzaXZlIiwic2Nyb2xsRWxlbWVudCIsInNldHVwRXZlbnRMaXN0ZW5lcnMiLCJyZW1vdmVFdmVudExpc3RlbmVycyIsImlzRmluaXRlIiwidW5pdCIsImF0dHJpYnV0ZXMiLCJmbG9vciIsIm5vUm91bmQiLCJyZWZlcmVuY2VXaWR0aCIsInBvcHBlcldpZHRoIiwiaXNWZXJ0aWNhbCIsImlzVmFyaWF0aW9uIiwic2FtZVdpZHRoUGFyaXR5IiwiYm90aE9kZFdpZHRoIiwiaG9yaXpvbnRhbFRvSW50ZWdlciIsInZlcnRpY2FsVG9JbnRlZ2VyIiwiaXNGaXJlZm94IiwibGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uIiwiZ3B1QWNjZWxlcmF0aW9uIiwib2Zmc2V0UGFyZW50UmVjdCIsImdldFJvdW5kZWRPZmZzZXRzIiwicHJlZml4ZWRQcm9wZXJ0eSIsImludmVydFRvcCIsImludmVydExlZnQiLCJyZXF1ZXN0aW5nIiwiaXNSZXF1aXJlZCIsInJlcXVlc3RlZCIsImlzTW9kaWZpZXJSZXF1aXJlZCIsImFycm93RWxlbWVudCIsInNpZGVDYXBpdGFsaXplZCIsImFsdFNpZGUiLCJvcFNpZGUiLCJhcnJvd0VsZW1lbnRTaXplIiwicG9wcGVyTWFyZ2luU2lkZSIsInBvcHBlckJvcmRlclNpZGUiLCJzaWRlVmFsdWUiLCJ2YWxpZFBsYWNlbWVudHMiLCJwbGFjZW1lbnRzIiwiY291bnRlciIsIkJFSEFWSU9SUyIsInBsYWNlbWVudE9wcG9zaXRlIiwiZmxpcE9yZGVyIiwiY2xvY2t3aXNlIiwicmVmT2Zmc2V0cyIsIm92ZXJsYXBzUmVmIiwib3ZlcmZsb3dzTGVmdCIsIm92ZXJmbG93c1JpZ2h0Iiwib3ZlcmZsb3dzVG9wIiwib3ZlcmZsb3dzQm90dG9tIiwib3ZlcmZsb3dzQm91bmRhcmllcyIsImZsaXBwZWRWYXJpYXRpb25CeVJlZiIsImZsaXBwZWRWYXJpYXRpb25CeUNvbnRlbnQiLCJmbGlwcGVkVmFyaWF0aW9uIiwiZ2V0T3Bwb3NpdGVWYXJpYXRpb24iLCJzdHIiLCJ1c2VIZWlnaHQiLCJmcmFnbWVudHMiLCJmcmFnIiwiZGl2aWRlciIsInNwbGl0UmVnZXgiLCJvcHMiLCJtZXJnZVdpdGhQcmV2aW91cyIsInRvVmFsdWUiLCJpbmRleDIiLCJiYXNlUGxhY2VtZW50IiwicGFyc2VPZmZzZXQiLCJ0cmFuc2Zvcm1Qcm9wIiwicG9wcGVyU3R5bGVzIiwiY2hlY2siLCJzaGlmdHZhcmlhdGlvbiIsInNoaWZ0T2Zmc2V0cyIsImJvdW5kIiwic3VidHJhY3RMZW5ndGgiLCJzaGlmdCIsImtlZXBUb2dldGhlciIsIlBvcHBlciIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImRlYm91bmNlIiwibW9kaWZpZXJPcHRpb25zIiwiZXZlbnRzRW5hYmxlZCIsImVuYWJsZUV2ZW50TGlzdGVuZXJzIiwiZGlzYWJsZUV2ZW50TGlzdGVuZXJzIiwiVXRpbHMiLCJQb3BwZXJVdGlscyIsImciLCJGdW5jdGlvbiIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZWFkeSIsImpzX2FjY29yZGlvbiIsImNvbGxhcHNlX3RyaWdnZXIiLCJjbGljayIsImN1cnJlbnRDb2xsYXBzZSIsInJlbWFpbmluZ0NvbGxhcHNlIiwicmVtYWluaW5nQnRuIiwic2xpZGVUb2dnbGUiLCJzbGlkZVVwIl0sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7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QVBLO0FBTjBCLEdBQXZDO0FBb0JELENBakVELEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUEEsd0IiLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuNC4xKTogdXRpbC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5J1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogUHJpdmF0ZSBUcmFuc2l0aW9uRW5kIEhlbHBlcnNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IFRSQU5TSVRJT05fRU5EID0gJ3RyYW5zaXRpb25lbmQnXG5jb25zdCBNQVhfVUlEID0gMTAwMDAwMFxuY29uc3QgTUlMTElTRUNPTkRTX01VTFRJUExJRVIgPSAxMDAwXG5cbi8vIFNob3V0b3V0IEFuZ3VzQ3JvbGwgKGh0dHBzOi8vZ29vLmdsL3B4d1FHcClcbmZ1bmN0aW9uIHRvVHlwZShvYmopIHtcbiAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwob2JqKS5tYXRjaCgvXFxzKFthLXpdKykvaSlbMV0udG9Mb3dlckNhc2UoKVxufVxuXG5mdW5jdGlvbiBnZXRTcGVjaWFsVHJhbnNpdGlvbkVuZEV2ZW50KCkge1xuICByZXR1cm4ge1xuICAgIGJpbmRUeXBlOiBUUkFOU0lUSU9OX0VORCxcbiAgICBkZWxlZ2F0ZVR5cGU6IFRSQU5TSVRJT05fRU5ELFxuICAgIGhhbmRsZShldmVudCkge1xuICAgICAgaWYgKCQoZXZlbnQudGFyZ2V0KS5pcyh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZXZlbnQuaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmaW5lZFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uRW5kRW11bGF0b3IoZHVyYXRpb24pIHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlXG5cbiAgJCh0aGlzKS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgKCkgPT4ge1xuICAgIGNhbGxlZCA9IHRydWVcbiAgfSlcblxuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgVXRpbC50cmlnZ2VyVHJhbnNpdGlvbkVuZCh0aGlzKVxuICAgIH1cbiAgfSwgZHVyYXRpb24pXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gc2V0VHJhbnNpdGlvbkVuZFN1cHBvcnQoKSB7XG4gICQuZm4uZW11bGF0ZVRyYW5zaXRpb25FbmQgPSB0cmFuc2l0aW9uRW5kRW11bGF0b3JcbiAgJC5ldmVudC5zcGVjaWFsW1V0aWwuVFJBTlNJVElPTl9FTkRdID0gZ2V0U3BlY2lhbFRyYW5zaXRpb25FbmRFdmVudCgpXG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFB1YmxpYyBVdGlsIEFwaVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBVdGlsID0ge1xuXG4gIFRSQU5TSVRJT05fRU5EOiAnYnNUcmFuc2l0aW9uRW5kJyxcblxuICBnZXRVSUQocHJlZml4KSB7XG4gICAgZG8ge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgIHByZWZpeCArPSB+fihNYXRoLnJhbmRvbSgpICogTUFYX1VJRCkgLy8gXCJ+flwiIGFjdHMgbGlrZSBhIGZhc3RlciBNYXRoLmZsb29yKCkgaGVyZVxuICAgIH0gd2hpbGUgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHByZWZpeCkpXG4gICAgcmV0dXJuIHByZWZpeFxuICB9LFxuXG4gIGdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudCkge1xuICAgIGxldCBzZWxlY3RvciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRhcmdldCcpXG5cbiAgICBpZiAoIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSAnIycpIHtcbiAgICAgIGNvbnN0IGhyZWZBdHRyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKVxuICAgICAgc2VsZWN0b3IgPSBocmVmQXR0ciAmJiBocmVmQXR0ciAhPT0gJyMnID8gaHJlZkF0dHIudHJpbSgpIDogJydcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpID8gc2VsZWN0b3IgOiBudWxsXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfSxcblxuICBnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudChlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIC8vIEdldCB0cmFuc2l0aW9uLWR1cmF0aW9uIG9mIHRoZSBlbGVtZW50XG4gICAgbGV0IHRyYW5zaXRpb25EdXJhdGlvbiA9ICQoZWxlbWVudCkuY3NzKCd0cmFuc2l0aW9uLWR1cmF0aW9uJylcbiAgICBsZXQgdHJhbnNpdGlvbkRlbGF5ID0gJChlbGVtZW50KS5jc3MoJ3RyYW5zaXRpb24tZGVsYXknKVxuXG4gICAgY29uc3QgZmxvYXRUcmFuc2l0aW9uRHVyYXRpb24gPSBwYXJzZUZsb2F0KHRyYW5zaXRpb25EdXJhdGlvbilcbiAgICBjb25zdCBmbG9hdFRyYW5zaXRpb25EZWxheSA9IHBhcnNlRmxvYXQodHJhbnNpdGlvbkRlbGF5KVxuXG4gICAgLy8gUmV0dXJuIDAgaWYgZWxlbWVudCBvciB0cmFuc2l0aW9uIGR1cmF0aW9uIGlzIG5vdCBmb3VuZFxuICAgIGlmICghZmxvYXRUcmFuc2l0aW9uRHVyYXRpb24gJiYgIWZsb2F0VHJhbnNpdGlvbkRlbGF5KSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIC8vIElmIG11bHRpcGxlIGR1cmF0aW9ucyBhcmUgZGVmaW5lZCwgdGFrZSB0aGUgZmlyc3RcbiAgICB0cmFuc2l0aW9uRHVyYXRpb24gPSB0cmFuc2l0aW9uRHVyYXRpb24uc3BsaXQoJywnKVswXVxuICAgIHRyYW5zaXRpb25EZWxheSA9IHRyYW5zaXRpb25EZWxheS5zcGxpdCgnLCcpWzBdXG5cbiAgICByZXR1cm4gKHBhcnNlRmxvYXQodHJhbnNpdGlvbkR1cmF0aW9uKSArIHBhcnNlRmxvYXQodHJhbnNpdGlvbkRlbGF5KSkgKiBNSUxMSVNFQ09ORFNfTVVMVElQTElFUlxuICB9LFxuXG4gIHJlZmxvdyhlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0SGVpZ2h0XG4gIH0sXG5cbiAgdHJpZ2dlclRyYW5zaXRpb25FbmQoZWxlbWVudCkge1xuICAgICQoZWxlbWVudCkudHJpZ2dlcihUUkFOU0lUSU9OX0VORClcbiAgfSxcblxuICAvLyBUT0RPOiBSZW1vdmUgaW4gdjVcbiAgc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkge1xuICAgIHJldHVybiBCb29sZWFuKFRSQU5TSVRJT05fRU5EKVxuICB9LFxuXG4gIGlzRWxlbWVudChvYmopIHtcbiAgICByZXR1cm4gKG9ialswXSB8fCBvYmopLm5vZGVUeXBlXG4gIH0sXG5cbiAgdHlwZUNoZWNrQ29uZmlnKGNvbXBvbmVudE5hbWUsIGNvbmZpZywgY29uZmlnVHlwZXMpIHtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIGNvbmZpZ1R5cGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZ1R5cGVzLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRUeXBlcyA9IGNvbmZpZ1R5cGVzW3Byb3BlcnR5XVxuICAgICAgICBjb25zdCB2YWx1ZSAgICAgICAgID0gY29uZmlnW3Byb3BlcnR5XVxuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgICAgID0gdmFsdWUgJiYgVXRpbC5pc0VsZW1lbnQodmFsdWUpXG4gICAgICAgICAgPyAnZWxlbWVudCcgOiB0b1R5cGUodmFsdWUpXG5cbiAgICAgICAgaWYgKCFuZXcgUmVnRXhwKGV4cGVjdGVkVHlwZXMpLnRlc3QodmFsdWVUeXBlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGAke2NvbXBvbmVudE5hbWUudG9VcHBlckNhc2UoKX06IGAgK1xuICAgICAgICAgICAgYE9wdGlvbiBcIiR7cHJvcGVydHl9XCIgcHJvdmlkZWQgdHlwZSBcIiR7dmFsdWVUeXBlfVwiIGAgK1xuICAgICAgICAgICAgYGJ1dCBleHBlY3RlZCB0eXBlIFwiJHtleHBlY3RlZFR5cGVzfVwiLmApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZmluZFNoYWRvd1Jvb3QoZWxlbWVudCkge1xuICAgIGlmICghZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmF0dGFjaFNoYWRvdykge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvLyBDYW4gZmluZCB0aGUgc2hhZG93IHJvb3Qgb3RoZXJ3aXNlIGl0J2xsIHJldHVybiB0aGUgZG9jdW1lbnRcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQuZ2V0Um9vdE5vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnN0IHJvb3QgPSBlbGVtZW50LmdldFJvb3ROb2RlKClcbiAgICAgIHJldHVybiByb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IHJvb3QgOiBudWxsXG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgICByZXR1cm4gZWxlbWVudFxuICAgIH1cblxuICAgIC8vIHdoZW4gd2UgZG9uJ3QgZmluZCBhIHNoYWRvdyByb290XG4gICAgaWYgKCFlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIFV0aWwuZmluZFNoYWRvd1Jvb3QoZWxlbWVudC5wYXJlbnROb2RlKVxuICB9LFxuXG4gIGpRdWVyeURldGVjdGlvbigpIHtcbiAgICBpZiAodHlwZW9mICQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb290c3RyYXBcXCdzIEphdmFTY3JpcHQgcmVxdWlyZXMgalF1ZXJ5LiBqUXVlcnkgbXVzdCBiZSBpbmNsdWRlZCBiZWZvcmUgQm9vdHN0cmFwXFwncyBKYXZhU2NyaXB0LicpXG4gICAgfVxuXG4gICAgY29uc3QgdmVyc2lvbiA9ICQuZm4uanF1ZXJ5LnNwbGl0KCcgJylbMF0uc3BsaXQoJy4nKVxuICAgIGNvbnN0IG1pbk1ham9yID0gMVxuICAgIGNvbnN0IGx0TWFqb3IgPSAyXG4gICAgY29uc3QgbWluTWlub3IgPSA5XG4gICAgY29uc3QgbWluUGF0Y2ggPSAxXG4gICAgY29uc3QgbWF4TWFqb3IgPSA0XG5cbiAgICBpZiAodmVyc2lvblswXSA8IGx0TWFqb3IgJiYgdmVyc2lvblsxXSA8IG1pbk1pbm9yIHx8IHZlcnNpb25bMF0gPT09IG1pbk1ham9yICYmIHZlcnNpb25bMV0gPT09IG1pbk1pbm9yICYmIHZlcnNpb25bMl0gPCBtaW5QYXRjaCB8fCB2ZXJzaW9uWzBdID49IG1heE1ham9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jvb3RzdHJhcFxcJ3MgSmF2YVNjcmlwdCByZXF1aXJlcyBhdCBsZWFzdCBqUXVlcnkgdjEuOS4xIGJ1dCBsZXNzIHRoYW4gdjQuMC4wJylcbiAgICB9XG4gIH1cbn1cblxuVXRpbC5qUXVlcnlEZXRlY3Rpb24oKVxuc2V0VHJhbnNpdGlvbkVuZFN1cHBvcnQoKVxuXG5leHBvcnQgZGVmYXVsdCBVdGlsXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjQuMSk6IGFsZXJ0LmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknXG5pbXBvcnQgVXRpbCBmcm9tICcuL3V0aWwnXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE5BTUUgICAgICAgICAgICAgICAgPSAnYWxlcnQnXG5jb25zdCBWRVJTSU9OICAgICAgICAgICAgID0gJzQuNC4xJ1xuY29uc3QgREFUQV9LRVkgICAgICAgICAgICA9ICdicy5hbGVydCdcbmNvbnN0IEVWRU5UX0tFWSAgICAgICAgICAgPSBgLiR7REFUQV9LRVl9YFxuY29uc3QgREFUQV9BUElfS0VZICAgICAgICA9ICcuZGF0YS1hcGknXG5jb25zdCBKUVVFUllfTk9fQ09ORkxJQ1QgID0gJC5mbltOQU1FXVxuXG5jb25zdCBTZWxlY3RvciA9IHtcbiAgRElTTUlTUyA6ICdbZGF0YS1kaXNtaXNzPVwiYWxlcnRcIl0nXG59XG5cbmNvbnN0IEV2ZW50ID0ge1xuICBDTE9TRSAgICAgICAgICA6IGBjbG9zZSR7RVZFTlRfS0VZfWAsXG4gIENMT1NFRCAgICAgICAgIDogYGNsb3NlZCR7RVZFTlRfS0VZfWAsXG4gIENMSUNLX0RBVEFfQVBJIDogYGNsaWNrJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxufVxuXG5jb25zdCBDbGFzc05hbWUgPSB7XG4gIEFMRVJUIDogJ2FsZXJ0JyxcbiAgRkFERSAgOiAnZmFkZScsXG4gIFNIT1cgIDogJ3Nob3cnXG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDbGFzcyBEZWZpbml0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jbGFzcyBBbGVydCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudFxuICB9XG5cbiAgLy8gR2V0dGVyc1xuXG4gIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICByZXR1cm4gVkVSU0lPTlxuICB9XG5cbiAgLy8gUHVibGljXG5cbiAgY2xvc2UoZWxlbWVudCkge1xuICAgIGxldCByb290RWxlbWVudCA9IHRoaXMuX2VsZW1lbnRcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgcm9vdEVsZW1lbnQgPSB0aGlzLl9nZXRSb290RWxlbWVudChlbGVtZW50KVxuICAgIH1cblxuICAgIGNvbnN0IGN1c3RvbUV2ZW50ID0gdGhpcy5fdHJpZ2dlckNsb3NlRXZlbnQocm9vdEVsZW1lbnQpXG5cbiAgICBpZiAoY3VzdG9tRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX3JlbW92ZUVsZW1lbnQocm9vdEVsZW1lbnQpXG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgICQucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBEQVRBX0tFWSlcbiAgICB0aGlzLl9lbGVtZW50ID0gbnVsbFxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuXG4gIF9nZXRSb290RWxlbWVudChlbGVtZW50KSB7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudClcbiAgICBsZXQgcGFyZW50ICAgICA9IGZhbHNlXG5cbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIHBhcmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpXG4gICAgfVxuXG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9ICQoZWxlbWVudCkuY2xvc2VzdChgLiR7Q2xhc3NOYW1lLkFMRVJUfWApWzBdXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmVudFxuICB9XG5cbiAgX3RyaWdnZXJDbG9zZUV2ZW50KGVsZW1lbnQpIHtcbiAgICBjb25zdCBjbG9zZUV2ZW50ID0gJC5FdmVudChFdmVudC5DTE9TRSlcblxuICAgICQoZWxlbWVudCkudHJpZ2dlcihjbG9zZUV2ZW50KVxuICAgIHJldHVybiBjbG9zZUV2ZW50XG4gIH1cblxuICBfcmVtb3ZlRWxlbWVudChlbGVtZW50KSB7XG4gICAgJChlbGVtZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuU0hPVylcblxuICAgIGlmICghJChlbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuRkFERSkpIHtcbiAgICAgIHRoaXMuX2Rlc3Ryb3lFbGVtZW50KGVsZW1lbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KGVsZW1lbnQpXG5cbiAgICAkKGVsZW1lbnQpXG4gICAgICAub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIChldmVudCkgPT4gdGhpcy5fZGVzdHJveUVsZW1lbnQoZWxlbWVudCwgZXZlbnQpKVxuICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbilcbiAgfVxuXG4gIF9kZXN0cm95RWxlbWVudChlbGVtZW50KSB7XG4gICAgJChlbGVtZW50KVxuICAgICAgLmRldGFjaCgpXG4gICAgICAudHJpZ2dlcihFdmVudC5DTE9TRUQpXG4gICAgICAucmVtb3ZlKClcbiAgfVxuXG4gIC8vIFN0YXRpY1xuXG4gIHN0YXRpYyBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgJGVsZW1lbnQgPSAkKHRoaXMpXG4gICAgICBsZXQgZGF0YSAgICAgICA9ICRlbGVtZW50LmRhdGEoREFUQV9LRVkpXG5cbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICBkYXRhID0gbmV3IEFsZXJ0KHRoaXMpXG4gICAgICAgICRlbGVtZW50LmRhdGEoREFUQV9LRVksIGRhdGEpXG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcgPT09ICdjbG9zZScpIHtcbiAgICAgICAgZGF0YVtjb25maWddKHRoaXMpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHN0YXRpYyBfaGFuZGxlRGlzbWlzcyhhbGVydEluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgIH1cblxuICAgICAgYWxlcnRJbnN0YW5jZS5jbG9zZSh0aGlzKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbiQoZG9jdW1lbnQpLm9uKFxuICBFdmVudC5DTElDS19EQVRBX0FQSSxcbiAgU2VsZWN0b3IuRElTTUlTUyxcbiAgQWxlcnQuX2hhbmRsZURpc21pc3MobmV3IEFsZXJ0KCkpXG4pXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBqUXVlcnlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbiQuZm5bTkFNRV0gICAgICAgICAgICAgPSBBbGVydC5falF1ZXJ5SW50ZXJmYWNlXG4kLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gQWxlcnRcbiQuZm5bTkFNRV0ubm9Db25mbGljdCAgPSAoKSA9PiB7XG4gICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1RcbiAgcmV0dXJuIEFsZXJ0Ll9qUXVlcnlJbnRlcmZhY2Vcbn1cblxuZXhwb3J0IGRlZmF1bHQgQWxlcnRcbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuNC4xKTogYnV0dG9uLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE5BTUUgICAgICAgICAgICAgICAgPSAnYnV0dG9uJ1xuY29uc3QgVkVSU0lPTiAgICAgICAgICAgICA9ICc0LjQuMSdcbmNvbnN0IERBVEFfS0VZICAgICAgICAgICAgPSAnYnMuYnV0dG9uJ1xuY29uc3QgRVZFTlRfS0VZICAgICAgICAgICA9IGAuJHtEQVRBX0tFWX1gXG5jb25zdCBEQVRBX0FQSV9LRVkgICAgICAgID0gJy5kYXRhLWFwaSdcbmNvbnN0IEpRVUVSWV9OT19DT05GTElDVCAgPSAkLmZuW05BTUVdXG5cbmNvbnN0IENsYXNzTmFtZSA9IHtcbiAgQUNUSVZFIDogJ2FjdGl2ZScsXG4gIEJVVFRPTiA6ICdidG4nLFxuICBGT0NVUyAgOiAnZm9jdXMnXG59XG5cbmNvbnN0IFNlbGVjdG9yID0ge1xuICBEQVRBX1RPR0dMRV9DQVJST1QgICA6ICdbZGF0YS10b2dnbGVePVwiYnV0dG9uXCJdJyxcbiAgREFUQV9UT0dHTEVTICAgICAgICAgOiAnW2RhdGEtdG9nZ2xlPVwiYnV0dG9uc1wiXScsXG4gIERBVEFfVE9HR0xFICAgICAgICAgIDogJ1tkYXRhLXRvZ2dsZT1cImJ1dHRvblwiXScsXG4gIERBVEFfVE9HR0xFU19CVVRUT05TIDogJ1tkYXRhLXRvZ2dsZT1cImJ1dHRvbnNcIl0gLmJ0bicsXG4gIElOUFVUICAgICAgICAgICAgICAgIDogJ2lucHV0Om5vdChbdHlwZT1cImhpZGRlblwiXSknLFxuICBBQ1RJVkUgICAgICAgICAgICAgICA6ICcuYWN0aXZlJyxcbiAgQlVUVE9OICAgICAgICAgICAgICAgOiAnLmJ0bidcbn1cblxuY29uc3QgRXZlbnQgPSB7XG4gIENMSUNLX0RBVEFfQVBJICAgICAgOiBgY2xpY2ske0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gLFxuICBGT0NVU19CTFVSX0RBVEFfQVBJIDogYGZvY3VzJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBgYmx1ciR7RVZFTlRfS0VZfSR7REFUQV9BUElfS0VZfWAsXG4gIExPQURfREFUQV9BUEkgICAgICAgOiBgbG9hZCR7RVZFTlRfS0VZfSR7REFUQV9BUElfS0VZfWBcbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENsYXNzIERlZmluaXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNsYXNzIEJ1dHRvbiB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudFxuICB9XG5cbiAgLy8gR2V0dGVyc1xuXG4gIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICByZXR1cm4gVkVSU0lPTlxuICB9XG5cbiAgLy8gUHVibGljXG5cbiAgdG9nZ2xlKCkge1xuICAgIGxldCB0cmlnZ2VyQ2hhbmdlRXZlbnQgPSB0cnVlXG4gICAgbGV0IGFkZEFyaWFQcmVzc2VkID0gdHJ1ZVxuICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gJCh0aGlzLl9lbGVtZW50KS5jbG9zZXN0KFxuICAgICAgU2VsZWN0b3IuREFUQV9UT0dHTEVTXG4gICAgKVswXVxuXG4gICAgaWYgKHJvb3RFbGVtZW50KSB7XG4gICAgICBjb25zdCBpbnB1dCA9IHRoaXMuX2VsZW1lbnQucXVlcnlTZWxlY3RvcihTZWxlY3Rvci5JTlBVVClcblxuICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC50eXBlID09PSAncmFkaW8nKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoZWNrZWQgJiZcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENsYXNzTmFtZS5BQ1RJVkUpKSB7XG4gICAgICAgICAgICB0cmlnZ2VyQ2hhbmdlRXZlbnQgPSBmYWxzZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gcm9vdEVsZW1lbnQucXVlcnlTZWxlY3RvcihTZWxlY3Rvci5BQ1RJVkUpXG5cbiAgICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICQoYWN0aXZlRWxlbWVudCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQudHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgICAgICAgIGlmICh0aGlzLl9lbGVtZW50LnRhZ05hbWUgPT09ICdMQUJFTCcgJiYgaW5wdXQuY2hlY2tlZCA9PT0gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ2xhc3NOYW1lLkFDVElWRSkpIHtcbiAgICAgICAgICAgIHRyaWdnZXJDaGFuZ2VFdmVudCA9IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGlmIGl0J3Mgbm90IGEgcmFkaW8gYnV0dG9uIG9yIGNoZWNrYm94IGRvbid0IGFkZCBhIHBvaW50bGVzcy9pbnZhbGlkIGNoZWNrZWQgcHJvcGVydHkgdG8gdGhlIGlucHV0XG4gICAgICAgICAgdHJpZ2dlckNoYW5nZUV2ZW50ID0gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgICBpbnB1dC5jaGVja2VkID0gIXRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENsYXNzTmFtZS5BQ1RJVkUpXG4gICAgICAgICAgJChpbnB1dCkudHJpZ2dlcignY2hhbmdlJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0LmZvY3VzKClcbiAgICAgICAgYWRkQXJpYVByZXNzZWQgPSBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghKHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpIHx8IHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSkge1xuICAgICAgaWYgKGFkZEFyaWFQcmVzc2VkKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLXByZXNzZWQnLFxuICAgICAgICAgICF0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDbGFzc05hbWUuQUNUSVZFKSlcbiAgICAgIH1cblxuICAgICAgaWYgKHRyaWdnZXJDaGFuZ2VFdmVudCkge1xuICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLnRvZ2dsZUNsYXNzKENsYXNzTmFtZS5BQ1RJVkUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpXG4gICAgdGhpcy5fZWxlbWVudCA9IG51bGxcbiAgfVxuXG4gIC8vIFN0YXRpY1xuXG4gIHN0YXRpYyBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgbGV0IGRhdGEgPSAkKHRoaXMpLmRhdGEoREFUQV9LRVkpXG5cbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICBkYXRhID0gbmV3IEJ1dHRvbih0aGlzKVxuICAgICAgICAkKHRoaXMpLmRhdGEoREFUQV9LRVksIGRhdGEpXG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcgPT09ICd0b2dnbGUnKSB7XG4gICAgICAgIGRhdGFbY29uZmlnXSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbiQoZG9jdW1lbnQpXG4gIC5vbihFdmVudC5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IuREFUQV9UT0dHTEVfQ0FSUk9ULCAoZXZlbnQpID0+IHtcbiAgICBsZXQgYnV0dG9uID0gZXZlbnQudGFyZ2V0XG5cbiAgICBpZiAoISQoYnV0dG9uKS5oYXNDbGFzcyhDbGFzc05hbWUuQlVUVE9OKSkge1xuICAgICAgYnV0dG9uID0gJChidXR0b24pLmNsb3Nlc3QoU2VsZWN0b3IuQlVUVE9OKVswXVxuICAgIH1cblxuICAgIGlmICghYnV0dG9uIHx8IGJ1dHRvbi5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgfHwgYnV0dG9uLmNsYXNzTGlzdC5jb250YWlucygnZGlzYWJsZWQnKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKSAvLyB3b3JrIGFyb3VuZCBGaXJlZm94IGJ1ZyAjMTU0MDk5NVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpbnB1dEJ0biA9IGJ1dHRvbi5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yLklOUFVUKVxuXG4gICAgICBpZiAoaW5wdXRCdG4gJiYgKGlucHV0QnRuLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSB8fCBpbnB1dEJ0bi5jbGFzc0xpc3QuY29udGFpbnMoJ2Rpc2FibGVkJykpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCkgLy8gd29yayBhcm91bmQgRmlyZWZveCBidWcgIzE1NDA5OTVcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIEJ1dHRvbi5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJChidXR0b24pLCAndG9nZ2xlJylcbiAgICB9XG4gIH0pXG4gIC5vbihFdmVudC5GT0NVU19CTFVSX0RBVEFfQVBJLCBTZWxlY3Rvci5EQVRBX1RPR0dMRV9DQVJST1QsIChldmVudCkgPT4ge1xuICAgIGNvbnN0IGJ1dHRvbiA9ICQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KFNlbGVjdG9yLkJVVFRPTilbMF1cbiAgICAkKGJ1dHRvbikudG9nZ2xlQ2xhc3MoQ2xhc3NOYW1lLkZPQ1VTLCAvXmZvY3VzKGluKT8kLy50ZXN0KGV2ZW50LnR5cGUpKVxuICB9KVxuXG4kKHdpbmRvdykub24oRXZlbnQuTE9BRF9EQVRBX0FQSSwgKCkgPT4ge1xuICAvLyBlbnN1cmUgY29ycmVjdCBhY3RpdmUgY2xhc3MgaXMgc2V0IHRvIG1hdGNoIHRoZSBjb250cm9scycgYWN0dWFsIHZhbHVlcy9zdGF0ZXNcblxuICAvLyBmaW5kIGFsbCBjaGVja2JveGVzL3JlYWRpbyBidXR0b25zIGluc2lkZSBkYXRhLXRvZ2dsZSBncm91cHNcbiAgbGV0IGJ1dHRvbnMgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU2VsZWN0b3IuREFUQV9UT0dHTEVTX0JVVFRPTlMpKVxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gYnV0dG9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGJ1dHRvbiA9IGJ1dHRvbnNbaV1cbiAgICBjb25zdCBpbnB1dCA9IGJ1dHRvbi5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yLklOUFVUKVxuICAgIGlmIChpbnB1dC5jaGVja2VkIHx8IGlucHV0Lmhhc0F0dHJpYnV0ZSgnY2hlY2tlZCcpKSB7XG4gICAgICBidXR0b24uY2xhc3NMaXN0LmFkZChDbGFzc05hbWUuQUNUSVZFKVxuICAgIH0gZWxzZSB7XG4gICAgICBidXR0b24uY2xhc3NMaXN0LnJlbW92ZShDbGFzc05hbWUuQUNUSVZFKVxuICAgIH1cbiAgfVxuXG4gIC8vIGZpbmQgYWxsIGJ1dHRvbiB0b2dnbGVzXG4gIGJ1dHRvbnMgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU2VsZWN0b3IuREFUQV9UT0dHTEUpKVxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gYnV0dG9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGJ1dHRvbiA9IGJ1dHRvbnNbaV1cbiAgICBpZiAoYnV0dG9uLmdldEF0dHJpYnV0ZSgnYXJpYS1wcmVzc2VkJykgPT09ICd0cnVlJykge1xuICAgICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoQ2xhc3NOYW1lLkFDVElWRSlcbiAgICB9IGVsc2Uge1xuICAgICAgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoQ2xhc3NOYW1lLkFDVElWRSlcbiAgICB9XG4gIH1cbn0pXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBqUXVlcnlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbiQuZm5bTkFNRV0gPSBCdXR0b24uX2pRdWVyeUludGVyZmFjZVxuJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IEJ1dHRvblxuJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gKCkgPT4ge1xuICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUXG4gIHJldHVybiBCdXR0b24uX2pRdWVyeUludGVyZmFjZVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25cbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuNC4xKTogY2Fyb3VzZWwuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSdcbmltcG9ydCBVdGlsIGZyb20gJy4vdXRpbCdcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvbnN0YW50c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgTkFNRSAgICAgICAgICAgICAgICAgICA9ICdjYXJvdXNlbCdcbmNvbnN0IFZFUlNJT04gICAgICAgICAgICAgICAgPSAnNC40LjEnXG5jb25zdCBEQVRBX0tFWSAgICAgICAgICAgICAgID0gJ2JzLmNhcm91c2VsJ1xuY29uc3QgRVZFTlRfS0VZICAgICAgICAgICAgICA9IGAuJHtEQVRBX0tFWX1gXG5jb25zdCBEQVRBX0FQSV9LRVkgICAgICAgICAgID0gJy5kYXRhLWFwaSdcbmNvbnN0IEpRVUVSWV9OT19DT05GTElDVCAgICAgPSAkLmZuW05BTUVdXG5jb25zdCBBUlJPV19MRUZUX0tFWUNPREUgICAgID0gMzcgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgbGVmdCBhcnJvdyBrZXlcbmNvbnN0IEFSUk9XX1JJR0hUX0tFWUNPREUgICAgPSAzOSAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciByaWdodCBhcnJvdyBrZXlcbmNvbnN0IFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgPSA1MDAgLy8gVGltZSBmb3IgbW91c2UgY29tcGF0IGV2ZW50cyB0byBmaXJlIGFmdGVyIHRvdWNoXG5jb25zdCBTV0lQRV9USFJFU0hPTEQgICAgICAgID0gNDBcblxuY29uc3QgRGVmYXVsdCA9IHtcbiAgaW50ZXJ2YWwgOiA1MDAwLFxuICBrZXlib2FyZCA6IHRydWUsXG4gIHNsaWRlICAgIDogZmFsc2UsXG4gIHBhdXNlICAgIDogJ2hvdmVyJyxcbiAgd3JhcCAgICAgOiB0cnVlLFxuICB0b3VjaCAgICA6IHRydWVcbn1cblxuY29uc3QgRGVmYXVsdFR5cGUgPSB7XG4gIGludGVydmFsIDogJyhudW1iZXJ8Ym9vbGVhbiknLFxuICBrZXlib2FyZCA6ICdib29sZWFuJyxcbiAgc2xpZGUgICAgOiAnKGJvb2xlYW58c3RyaW5nKScsXG4gIHBhdXNlICAgIDogJyhzdHJpbmd8Ym9vbGVhbiknLFxuICB3cmFwICAgICA6ICdib29sZWFuJyxcbiAgdG91Y2ggICAgOiAnYm9vbGVhbidcbn1cblxuY29uc3QgRGlyZWN0aW9uID0ge1xuICBORVhUICAgICA6ICduZXh0JyxcbiAgUFJFViAgICAgOiAncHJldicsXG4gIExFRlQgICAgIDogJ2xlZnQnLFxuICBSSUdIVCAgICA6ICdyaWdodCdcbn1cblxuY29uc3QgRXZlbnQgPSB7XG4gIFNMSURFICAgICAgICAgIDogYHNsaWRlJHtFVkVOVF9LRVl9YCxcbiAgU0xJRCAgICAgICAgICAgOiBgc2xpZCR7RVZFTlRfS0VZfWAsXG4gIEtFWURPV04gICAgICAgIDogYGtleWRvd24ke0VWRU5UX0tFWX1gLFxuICBNT1VTRUVOVEVSICAgICA6IGBtb3VzZWVudGVyJHtFVkVOVF9LRVl9YCxcbiAgTU9VU0VMRUFWRSAgICAgOiBgbW91c2VsZWF2ZSR7RVZFTlRfS0VZfWAsXG4gIFRPVUNIU1RBUlQgICAgIDogYHRvdWNoc3RhcnQke0VWRU5UX0tFWX1gLFxuICBUT1VDSE1PVkUgICAgICA6IGB0b3VjaG1vdmUke0VWRU5UX0tFWX1gLFxuICBUT1VDSEVORCAgICAgICA6IGB0b3VjaGVuZCR7RVZFTlRfS0VZfWAsXG4gIFBPSU5URVJET1dOICAgIDogYHBvaW50ZXJkb3duJHtFVkVOVF9LRVl9YCxcbiAgUE9JTlRFUlVQICAgICAgOiBgcG9pbnRlcnVwJHtFVkVOVF9LRVl9YCxcbiAgRFJBR19TVEFSVCAgICAgOiBgZHJhZ3N0YXJ0JHtFVkVOVF9LRVl9YCxcbiAgTE9BRF9EQVRBX0FQSSAgOiBgbG9hZCR7RVZFTlRfS0VZfSR7REFUQV9BUElfS0VZfWAsXG4gIENMSUNLX0RBVEFfQVBJIDogYGNsaWNrJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxufVxuXG5jb25zdCBDbGFzc05hbWUgPSB7XG4gIENBUk9VU0VMICAgICAgOiAnY2Fyb3VzZWwnLFxuICBBQ1RJVkUgICAgICAgIDogJ2FjdGl2ZScsXG4gIFNMSURFICAgICAgICAgOiAnc2xpZGUnLFxuICBSSUdIVCAgICAgICAgIDogJ2Nhcm91c2VsLWl0ZW0tcmlnaHQnLFxuICBMRUZUICAgICAgICAgIDogJ2Nhcm91c2VsLWl0ZW0tbGVmdCcsXG4gIE5FWFQgICAgICAgICAgOiAnY2Fyb3VzZWwtaXRlbS1uZXh0JyxcbiAgUFJFViAgICAgICAgICA6ICdjYXJvdXNlbC1pdGVtLXByZXYnLFxuICBJVEVNICAgICAgICAgIDogJ2Nhcm91c2VsLWl0ZW0nLFxuICBQT0lOVEVSX0VWRU5UIDogJ3BvaW50ZXItZXZlbnQnXG59XG5cbmNvbnN0IFNlbGVjdG9yID0ge1xuICBBQ1RJVkUgICAgICA6ICcuYWN0aXZlJyxcbiAgQUNUSVZFX0lURU0gOiAnLmFjdGl2ZS5jYXJvdXNlbC1pdGVtJyxcbiAgSVRFTSAgICAgICAgOiAnLmNhcm91c2VsLWl0ZW0nLFxuICBJVEVNX0lNRyAgICA6ICcuY2Fyb3VzZWwtaXRlbSBpbWcnLFxuICBORVhUX1BSRVYgICA6ICcuY2Fyb3VzZWwtaXRlbS1uZXh0LCAuY2Fyb3VzZWwtaXRlbS1wcmV2JyxcbiAgSU5ESUNBVE9SUyAgOiAnLmNhcm91c2VsLWluZGljYXRvcnMnLFxuICBEQVRBX1NMSURFICA6ICdbZGF0YS1zbGlkZV0sIFtkYXRhLXNsaWRlLXRvXScsXG4gIERBVEFfUklERSAgIDogJ1tkYXRhLXJpZGU9XCJjYXJvdXNlbFwiXSdcbn1cblxuY29uc3QgUG9pbnRlclR5cGUgPSB7XG4gIFRPVUNIIDogJ3RvdWNoJyxcbiAgUEVOICAgOiAncGVuJ1xufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbmNsYXNzIENhcm91c2VsIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgdGhpcy5faXRlbXMgICAgICAgICA9IG51bGxcbiAgICB0aGlzLl9pbnRlcnZhbCAgICAgID0gbnVsbFxuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBudWxsXG4gICAgdGhpcy5faXNQYXVzZWQgICAgICA9IGZhbHNlXG4gICAgdGhpcy5faXNTbGlkaW5nICAgICA9IGZhbHNlXG4gICAgdGhpcy50b3VjaFRpbWVvdXQgICA9IG51bGxcbiAgICB0aGlzLnRvdWNoU3RhcnRYICAgID0gMFxuICAgIHRoaXMudG91Y2hEZWx0YVggICAgPSAwXG5cbiAgICB0aGlzLl9jb25maWcgICAgICAgICAgICA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpXG4gICAgdGhpcy5fZWxlbWVudCAgICAgICAgICAgPSBlbGVtZW50XG4gICAgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQgPSB0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoU2VsZWN0b3IuSU5ESUNBVE9SUylcbiAgICB0aGlzLl90b3VjaFN1cHBvcnRlZCAgICA9ICdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwXG4gICAgdGhpcy5fcG9pbnRlckV2ZW50ICAgICAgPSBCb29sZWFuKHdpbmRvdy5Qb2ludGVyRXZlbnQgfHwgd2luZG93Lk1TUG9pbnRlckV2ZW50KVxuXG4gICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKVxuICB9XG5cbiAgLy8gR2V0dGVyc1xuXG4gIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICByZXR1cm4gVkVSU0lPTlxuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0XG4gIH1cblxuICAvLyBQdWJsaWNcblxuICBuZXh0KCkge1xuICAgIGlmICghdGhpcy5faXNTbGlkaW5nKSB7XG4gICAgICB0aGlzLl9zbGlkZShEaXJlY3Rpb24uTkVYVClcbiAgICB9XG4gIH1cblxuICBuZXh0V2hlblZpc2libGUoKSB7XG4gICAgLy8gRG9uJ3QgY2FsbCBuZXh0IHdoZW4gdGhlIHBhZ2UgaXNuJ3QgdmlzaWJsZVxuICAgIC8vIG9yIHRoZSBjYXJvdXNlbCBvciBpdHMgcGFyZW50IGlzbid0IHZpc2libGVcbiAgICBpZiAoIWRvY3VtZW50LmhpZGRlbiAmJlxuICAgICAgKCQodGhpcy5fZWxlbWVudCkuaXMoJzp2aXNpYmxlJykgJiYgJCh0aGlzLl9lbGVtZW50KS5jc3MoJ3Zpc2liaWxpdHknKSAhPT0gJ2hpZGRlbicpKSB7XG4gICAgICB0aGlzLm5leHQoKVxuICAgIH1cbiAgfVxuXG4gIHByZXYoKSB7XG4gICAgaWYgKCF0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgIHRoaXMuX3NsaWRlKERpcmVjdGlvbi5QUkVWKVxuICAgIH1cbiAgfVxuXG4gIHBhdXNlKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgdGhpcy5faXNQYXVzZWQgPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2VsZW1lbnQucXVlcnlTZWxlY3RvcihTZWxlY3Rvci5ORVhUX1BSRVYpKSB7XG4gICAgICBVdGlsLnRyaWdnZXJUcmFuc2l0aW9uRW5kKHRoaXMuX2VsZW1lbnQpXG4gICAgICB0aGlzLmN5Y2xlKHRydWUpXG4gICAgfVxuXG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbClcbiAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGxcbiAgfVxuXG4gIGN5Y2xlKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbClcbiAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb25maWcuaW50ZXJ2YWwgJiYgIXRoaXMuX2lzUGF1c2VkKSB7XG4gICAgICB0aGlzLl9pbnRlcnZhbCA9IHNldEludGVydmFsKFxuICAgICAgICAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID8gdGhpcy5uZXh0V2hlblZpc2libGUgOiB0aGlzLm5leHQpLmJpbmQodGhpcyksXG4gICAgICAgIHRoaXMuX2NvbmZpZy5pbnRlcnZhbFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHRvKGluZGV4KSB7XG4gICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IHRoaXMuX2VsZW1lbnQucXVlcnlTZWxlY3RvcihTZWxlY3Rvci5BQ1RJVkVfSVRFTSlcblxuICAgIGNvbnN0IGFjdGl2ZUluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KHRoaXMuX2FjdGl2ZUVsZW1lbnQpXG5cbiAgICBpZiAoaW5kZXggPiB0aGlzLl9pdGVtcy5sZW5ndGggLSAxIHx8IGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbmUoRXZlbnQuU0xJRCwgKCkgPT4gdGhpcy50byhpbmRleCkpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoYWN0aXZlSW5kZXggPT09IGluZGV4KSB7XG4gICAgICB0aGlzLnBhdXNlKClcbiAgICAgIHRoaXMuY3ljbGUoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgZGlyZWN0aW9uID0gaW5kZXggPiBhY3RpdmVJbmRleFxuICAgICAgPyBEaXJlY3Rpb24uTkVYVFxuICAgICAgOiBEaXJlY3Rpb24uUFJFVlxuXG4gICAgdGhpcy5fc2xpZGUoZGlyZWN0aW9uLCB0aGlzLl9pdGVtc1tpbmRleF0pXG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgICQodGhpcy5fZWxlbWVudCkub2ZmKEVWRU5UX0tFWSlcbiAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpXG5cbiAgICB0aGlzLl9pdGVtcyAgICAgICAgICAgICA9IG51bGxcbiAgICB0aGlzLl9jb25maWcgICAgICAgICAgICA9IG51bGxcbiAgICB0aGlzLl9lbGVtZW50ICAgICAgICAgICA9IG51bGxcbiAgICB0aGlzLl9pbnRlcnZhbCAgICAgICAgICA9IG51bGxcbiAgICB0aGlzLl9pc1BhdXNlZCAgICAgICAgICA9IG51bGxcbiAgICB0aGlzLl9pc1NsaWRpbmcgICAgICAgICA9IG51bGxcbiAgICB0aGlzLl9hY3RpdmVFbGVtZW50ICAgICA9IG51bGxcbiAgICB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCA9IG51bGxcbiAgfVxuXG4gIC8vIFByaXZhdGVcblxuICBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgIGNvbmZpZyA9IHtcbiAgICAgIC4uLkRlZmF1bHQsXG4gICAgICAuLi5jb25maWdcbiAgICB9XG4gICAgVXRpbC50eXBlQ2hlY2tDb25maWcoTkFNRSwgY29uZmlnLCBEZWZhdWx0VHlwZSlcbiAgICByZXR1cm4gY29uZmlnXG4gIH1cblxuICBfaGFuZGxlU3dpcGUoKSB7XG4gICAgY29uc3QgYWJzRGVsdGF4ID0gTWF0aC5hYnModGhpcy50b3VjaERlbHRhWClcblxuICAgIGlmIChhYnNEZWx0YXggPD0gU1dJUEVfVEhSRVNIT0xEKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBkaXJlY3Rpb24gPSBhYnNEZWx0YXggLyB0aGlzLnRvdWNoRGVsdGFYXG5cbiAgICB0aGlzLnRvdWNoRGVsdGFYID0gMFxuXG4gICAgLy8gc3dpcGUgbGVmdFxuICAgIGlmIChkaXJlY3Rpb24gPiAwKSB7XG4gICAgICB0aGlzLnByZXYoKVxuICAgIH1cblxuICAgIC8vIHN3aXBlIHJpZ2h0XG4gICAgaWYgKGRpcmVjdGlvbiA8IDApIHtcbiAgICAgIHRoaXMubmV4dCgpXG4gICAgfVxuICB9XG5cbiAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLl9jb25maWcua2V5Ym9hcmQpIHtcbiAgICAgICQodGhpcy5fZWxlbWVudClcbiAgICAgICAgLm9uKEV2ZW50LktFWURPV04sIChldmVudCkgPT4gdGhpcy5fa2V5ZG93bihldmVudCkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5wYXVzZSA9PT0gJ2hvdmVyJykge1xuICAgICAgJCh0aGlzLl9lbGVtZW50KVxuICAgICAgICAub24oRXZlbnQuTU9VU0VFTlRFUiwgKGV2ZW50KSA9PiB0aGlzLnBhdXNlKGV2ZW50KSlcbiAgICAgICAgLm9uKEV2ZW50Lk1PVVNFTEVBVkUsIChldmVudCkgPT4gdGhpcy5jeWNsZShldmVudCkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NvbmZpZy50b3VjaCkge1xuICAgICAgdGhpcy5fYWRkVG91Y2hFdmVudExpc3RlbmVycygpXG4gICAgfVxuICB9XG5cbiAgX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKCF0aGlzLl90b3VjaFN1cHBvcnRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnQgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmICh0aGlzLl9wb2ludGVyRXZlbnQgJiYgUG9pbnRlclR5cGVbZXZlbnQub3JpZ2luYWxFdmVudC5wb2ludGVyVHlwZS50b1VwcGVyQ2FzZSgpXSkge1xuICAgICAgICB0aGlzLnRvdWNoU3RhcnRYID0gZXZlbnQub3JpZ2luYWxFdmVudC5jbGllbnRYXG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9wb2ludGVyRXZlbnQpIHtcbiAgICAgICAgdGhpcy50b3VjaFN0YXJ0WCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlc1swXS5jbGllbnRYXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbW92ZSA9IChldmVudCkgPT4ge1xuICAgICAgLy8gZW5zdXJlIHN3aXBpbmcgd2l0aCBvbmUgdG91Y2ggYW5kIG5vdCBwaW5jaGluZ1xuICAgICAgaWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcyAmJiBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLnRvdWNoRGVsdGFYID0gMFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50b3VjaERlbHRhWCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlc1swXS5jbGllbnRYIC0gdGhpcy50b3VjaFN0YXJ0WFxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGVuZCA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX3BvaW50ZXJFdmVudCAmJiBQb2ludGVyVHlwZVtldmVudC5vcmlnaW5hbEV2ZW50LnBvaW50ZXJUeXBlLnRvVXBwZXJDYXNlKCldKSB7XG4gICAgICAgIHRoaXMudG91Y2hEZWx0YVggPSBldmVudC5vcmlnaW5hbEV2ZW50LmNsaWVudFggLSB0aGlzLnRvdWNoU3RhcnRYXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2hhbmRsZVN3aXBlKClcbiAgICAgIGlmICh0aGlzLl9jb25maWcucGF1c2UgPT09ICdob3ZlcicpIHtcbiAgICAgICAgLy8gSWYgaXQncyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlLCBtb3VzZWVudGVyL2xlYXZlIGFyZSBmaXJlZCBhc1xuICAgICAgICAvLyBwYXJ0IG9mIHRoZSBtb3VzZSBjb21wYXRpYmlsaXR5IGV2ZW50cyBvbiBmaXJzdCB0YXAgLSB0aGUgY2Fyb3VzZWxcbiAgICAgICAgLy8gd291bGQgc3RvcCBjeWNsaW5nIHVudGlsIHVzZXIgdGFwcGVkIG91dCBvZiBpdDtcbiAgICAgICAgLy8gaGVyZSwgd2UgbGlzdGVuIGZvciB0b3VjaGVuZCwgZXhwbGljaXRseSBwYXVzZSB0aGUgY2Fyb3VzZWxcbiAgICAgICAgLy8gKGFzIGlmIGl0J3MgdGhlIHNlY29uZCB0aW1lIHdlIHRhcCBvbiBpdCwgbW91c2VlbnRlciBjb21wYXQgZXZlbnRcbiAgICAgICAgLy8gaXMgTk9UIGZpcmVkKSBhbmQgYWZ0ZXIgYSB0aW1lb3V0ICh0byBhbGxvdyBmb3IgbW91c2UgY29tcGF0aWJpbGl0eVxuICAgICAgICAvLyBldmVudHMgdG8gZmlyZSkgd2UgZXhwbGljaXRseSByZXN0YXJ0IGN5Y2xpbmdcblxuICAgICAgICB0aGlzLnBhdXNlKClcbiAgICAgICAgaWYgKHRoaXMudG91Y2hUaW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudG91Y2hUaW1lb3V0KVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudG91Y2hUaW1lb3V0ID0gc2V0VGltZW91dCgoZXZlbnQpID0+IHRoaXMuY3ljbGUoZXZlbnQpLCBUT1VDSEVWRU5UX0NPTVBBVF9XQUlUICsgdGhpcy5fY29uZmlnLmludGVydmFsKVxuICAgICAgfVxuICAgIH1cblxuICAgICQodGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFNlbGVjdG9yLklURU1fSU1HKSkub24oRXZlbnQuRFJBR19TVEFSVCwgKGUpID0+IGUucHJldmVudERlZmF1bHQoKSlcbiAgICBpZiAodGhpcy5fcG9pbnRlckV2ZW50KSB7XG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uKEV2ZW50LlBPSU5URVJET1dOLCAoZXZlbnQpID0+IHN0YXJ0KGV2ZW50KSlcbiAgICAgICQodGhpcy5fZWxlbWVudCkub24oRXZlbnQuUE9JTlRFUlVQLCAoZXZlbnQpID0+IGVuZChldmVudCkpXG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDbGFzc05hbWUuUE9JTlRFUl9FVkVOVClcbiAgICB9IGVsc2Uge1xuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFdmVudC5UT1VDSFNUQVJULCAoZXZlbnQpID0+IHN0YXJ0KGV2ZW50KSlcbiAgICAgICQodGhpcy5fZWxlbWVudCkub24oRXZlbnQuVE9VQ0hNT1ZFLCAoZXZlbnQpID0+IG1vdmUoZXZlbnQpKVxuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFdmVudC5UT1VDSEVORCwgKGV2ZW50KSA9PiBlbmQoZXZlbnQpKVxuICAgIH1cbiAgfVxuXG4gIF9rZXlkb3duKGV2ZW50KSB7XG4gICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzd2l0Y2ggKGV2ZW50LndoaWNoKSB7XG4gICAgICBjYXNlIEFSUk9XX0xFRlRfS0VZQ09ERTpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICB0aGlzLnByZXYoKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBBUlJPV19SSUdIVF9LRVlDT0RFOlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIHRoaXMubmV4dCgpXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxuXG4gIF9nZXRJdGVtSW5kZXgoZWxlbWVudCkge1xuICAgIHRoaXMuX2l0ZW1zID0gZWxlbWVudCAmJiBlbGVtZW50LnBhcmVudE5vZGVcbiAgICAgID8gW10uc2xpY2UuY2FsbChlbGVtZW50LnBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbChTZWxlY3Rvci5JVEVNKSlcbiAgICAgIDogW11cbiAgICByZXR1cm4gdGhpcy5faXRlbXMuaW5kZXhPZihlbGVtZW50KVxuICB9XG5cbiAgX2dldEl0ZW1CeURpcmVjdGlvbihkaXJlY3Rpb24sIGFjdGl2ZUVsZW1lbnQpIHtcbiAgICBjb25zdCBpc05leHREaXJlY3Rpb24gPSBkaXJlY3Rpb24gPT09IERpcmVjdGlvbi5ORVhUXG4gICAgY29uc3QgaXNQcmV2RGlyZWN0aW9uID0gZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uUFJFVlxuICAgIGNvbnN0IGFjdGl2ZUluZGV4ICAgICA9IHRoaXMuX2dldEl0ZW1JbmRleChhY3RpdmVFbGVtZW50KVxuICAgIGNvbnN0IGxhc3RJdGVtSW5kZXggICA9IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDFcbiAgICBjb25zdCBpc0dvaW5nVG9XcmFwICAgPSBpc1ByZXZEaXJlY3Rpb24gJiYgYWN0aXZlSW5kZXggPT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc05leHREaXJlY3Rpb24gJiYgYWN0aXZlSW5kZXggPT09IGxhc3RJdGVtSW5kZXhcblxuICAgIGlmIChpc0dvaW5nVG9XcmFwICYmICF0aGlzLl9jb25maWcud3JhcCkge1xuICAgICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRcbiAgICB9XG5cbiAgICBjb25zdCBkZWx0YSAgICAgPSBkaXJlY3Rpb24gPT09IERpcmVjdGlvbi5QUkVWID8gLTEgOiAxXG4gICAgY29uc3QgaXRlbUluZGV4ID0gKGFjdGl2ZUluZGV4ICsgZGVsdGEpICUgdGhpcy5faXRlbXMubGVuZ3RoXG5cbiAgICByZXR1cm4gaXRlbUluZGV4ID09PSAtMVxuICAgICAgPyB0aGlzLl9pdGVtc1t0aGlzLl9pdGVtcy5sZW5ndGggLSAxXSA6IHRoaXMuX2l0ZW1zW2l0ZW1JbmRleF1cbiAgfVxuXG4gIF90cmlnZ2VyU2xpZGVFdmVudChyZWxhdGVkVGFyZ2V0LCBldmVudERpcmVjdGlvbk5hbWUpIHtcbiAgICBjb25zdCB0YXJnZXRJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleChyZWxhdGVkVGFyZ2V0KVxuICAgIGNvbnN0IGZyb21JbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleCh0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoU2VsZWN0b3IuQUNUSVZFX0lURU0pKVxuICAgIGNvbnN0IHNsaWRlRXZlbnQgPSAkLkV2ZW50KEV2ZW50LlNMSURFLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0LFxuICAgICAgZGlyZWN0aW9uOiBldmVudERpcmVjdGlvbk5hbWUsXG4gICAgICBmcm9tOiBmcm9tSW5kZXgsXG4gICAgICB0bzogdGFyZ2V0SW5kZXhcbiAgICB9KVxuXG4gICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKHNsaWRlRXZlbnQpXG5cbiAgICByZXR1cm4gc2xpZGVFdmVudFxuICB9XG5cbiAgX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQoZWxlbWVudCkge1xuICAgIGlmICh0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCkge1xuICAgICAgY29uc3QgaW5kaWNhdG9ycyA9IFtdLnNsaWNlLmNhbGwodGhpcy5faW5kaWNhdG9yc0VsZW1lbnQucXVlcnlTZWxlY3RvckFsbChTZWxlY3Rvci5BQ1RJVkUpKVxuICAgICAgJChpbmRpY2F0b3JzKVxuICAgICAgICAucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSlcblxuICAgICAgY29uc3QgbmV4dEluZGljYXRvciA9IHRoaXMuX2luZGljYXRvcnNFbGVtZW50LmNoaWxkcmVuW1xuICAgICAgICB0aGlzLl9nZXRJdGVtSW5kZXgoZWxlbWVudClcbiAgICAgIF1cblxuICAgICAgaWYgKG5leHRJbmRpY2F0b3IpIHtcbiAgICAgICAgJChuZXh0SW5kaWNhdG9yKS5hZGRDbGFzcyhDbGFzc05hbWUuQUNUSVZFKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9zbGlkZShkaXJlY3Rpb24sIGVsZW1lbnQpIHtcbiAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gdGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yLkFDVElWRV9JVEVNKVxuICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnRJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleChhY3RpdmVFbGVtZW50KVxuICAgIGNvbnN0IG5leHRFbGVtZW50ICAgPSBlbGVtZW50IHx8IGFjdGl2ZUVsZW1lbnQgJiZcbiAgICAgIHRoaXMuX2dldEl0ZW1CeURpcmVjdGlvbihkaXJlY3Rpb24sIGFjdGl2ZUVsZW1lbnQpXG4gICAgY29uc3QgbmV4dEVsZW1lbnRJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleChuZXh0RWxlbWVudClcbiAgICBjb25zdCBpc0N5Y2xpbmcgPSBCb29sZWFuKHRoaXMuX2ludGVydmFsKVxuXG4gICAgbGV0IGRpcmVjdGlvbmFsQ2xhc3NOYW1lXG4gICAgbGV0IG9yZGVyQ2xhc3NOYW1lXG4gICAgbGV0IGV2ZW50RGlyZWN0aW9uTmFtZVxuXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLk5FWFQpIHtcbiAgICAgIGRpcmVjdGlvbmFsQ2xhc3NOYW1lID0gQ2xhc3NOYW1lLkxFRlRcbiAgICAgIG9yZGVyQ2xhc3NOYW1lID0gQ2xhc3NOYW1lLk5FWFRcbiAgICAgIGV2ZW50RGlyZWN0aW9uTmFtZSA9IERpcmVjdGlvbi5MRUZUXG4gICAgfSBlbHNlIHtcbiAgICAgIGRpcmVjdGlvbmFsQ2xhc3NOYW1lID0gQ2xhc3NOYW1lLlJJR0hUXG4gICAgICBvcmRlckNsYXNzTmFtZSA9IENsYXNzTmFtZS5QUkVWXG4gICAgICBldmVudERpcmVjdGlvbk5hbWUgPSBEaXJlY3Rpb24uUklHSFRcbiAgICB9XG5cbiAgICBpZiAobmV4dEVsZW1lbnQgJiYgJChuZXh0RWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSkpIHtcbiAgICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBzbGlkZUV2ZW50ID0gdGhpcy5fdHJpZ2dlclNsaWRlRXZlbnQobmV4dEVsZW1lbnQsIGV2ZW50RGlyZWN0aW9uTmFtZSlcbiAgICBpZiAoc2xpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFhY3RpdmVFbGVtZW50IHx8ICFuZXh0RWxlbWVudCkge1xuICAgICAgLy8gU29tZSB3ZWlyZG5lc3MgaXMgaGFwcGVuaW5nLCBzbyB3ZSBiYWlsXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9pc1NsaWRpbmcgPSB0cnVlXG5cbiAgICBpZiAoaXNDeWNsaW5nKSB7XG4gICAgICB0aGlzLnBhdXNlKClcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KG5leHRFbGVtZW50KVxuXG4gICAgY29uc3Qgc2xpZEV2ZW50ID0gJC5FdmVudChFdmVudC5TTElELCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiBuZXh0RWxlbWVudCxcbiAgICAgIGRpcmVjdGlvbjogZXZlbnREaXJlY3Rpb25OYW1lLFxuICAgICAgZnJvbTogYWN0aXZlRWxlbWVudEluZGV4LFxuICAgICAgdG86IG5leHRFbGVtZW50SW5kZXhcbiAgICB9KVxuXG4gICAgaWYgKCQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLlNMSURFKSkge1xuICAgICAgJChuZXh0RWxlbWVudCkuYWRkQ2xhc3Mob3JkZXJDbGFzc05hbWUpXG5cbiAgICAgIFV0aWwucmVmbG93KG5leHRFbGVtZW50KVxuXG4gICAgICAkKGFjdGl2ZUVsZW1lbnQpLmFkZENsYXNzKGRpcmVjdGlvbmFsQ2xhc3NOYW1lKVxuICAgICAgJChuZXh0RWxlbWVudCkuYWRkQ2xhc3MoZGlyZWN0aW9uYWxDbGFzc05hbWUpXG5cbiAgICAgIGNvbnN0IG5leHRFbGVtZW50SW50ZXJ2YWwgPSBwYXJzZUludChuZXh0RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW50ZXJ2YWwnKSwgMTApXG4gICAgICBpZiAobmV4dEVsZW1lbnRJbnRlcnZhbCkge1xuICAgICAgICB0aGlzLl9jb25maWcuZGVmYXVsdEludGVydmFsID0gdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCB8fCB0aGlzLl9jb25maWcuaW50ZXJ2YWxcbiAgICAgICAgdGhpcy5fY29uZmlnLmludGVydmFsID0gbmV4dEVsZW1lbnRJbnRlcnZhbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY29uZmlnLmludGVydmFsID0gdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCB8fCB0aGlzLl9jb25maWcuaW50ZXJ2YWxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudChhY3RpdmVFbGVtZW50KVxuXG4gICAgICAkKGFjdGl2ZUVsZW1lbnQpXG4gICAgICAgIC5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgKCkgPT4ge1xuICAgICAgICAgICQobmV4dEVsZW1lbnQpXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3MoYCR7ZGlyZWN0aW9uYWxDbGFzc05hbWV9ICR7b3JkZXJDbGFzc05hbWV9YClcbiAgICAgICAgICAgIC5hZGRDbGFzcyhDbGFzc05hbWUuQUNUSVZFKVxuXG4gICAgICAgICAgJChhY3RpdmVFbGVtZW50KS5yZW1vdmVDbGFzcyhgJHtDbGFzc05hbWUuQUNUSVZFfSAke29yZGVyQ2xhc3NOYW1lfSAke2RpcmVjdGlvbmFsQ2xhc3NOYW1lfWApXG5cbiAgICAgICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZVxuXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc2xpZEV2ZW50KSwgMClcbiAgICAgICAgfSlcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAgJChhY3RpdmVFbGVtZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQUNUSVZFKVxuICAgICAgJChuZXh0RWxlbWVudCkuYWRkQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSlcblxuICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2VcbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzbGlkRXZlbnQpXG4gICAgfVxuXG4gICAgaWYgKGlzQ3ljbGluZykge1xuICAgICAgdGhpcy5jeWNsZSgpXG4gICAgfVxuICB9XG5cbiAgLy8gU3RhdGljXG5cbiAgc3RhdGljIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgZGF0YSA9ICQodGhpcykuZGF0YShEQVRBX0tFWSlcbiAgICAgIGxldCBfY29uZmlnID0ge1xuICAgICAgICAuLi5EZWZhdWx0LFxuICAgICAgICAuLi4kKHRoaXMpLmRhdGEoKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgX2NvbmZpZyA9IHtcbiAgICAgICAgICAuLi5fY29uZmlnLFxuICAgICAgICAgIC4uLmNvbmZpZ1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFjdGlvbiA9IHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnID8gY29uZmlnIDogX2NvbmZpZy5zbGlkZVxuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBDYXJvdXNlbCh0aGlzLCBfY29uZmlnKVxuICAgICAgICAkKHRoaXMpLmRhdGEoREFUQV9LRVksIGRhdGEpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnbnVtYmVyJykge1xuICAgICAgICBkYXRhLnRvKGNvbmZpZylcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2FjdGlvbl0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHthY3Rpb259XCJgKVxuICAgICAgICB9XG4gICAgICAgIGRhdGFbYWN0aW9uXSgpXG4gICAgICB9IGVsc2UgaWYgKF9jb25maWcuaW50ZXJ2YWwgJiYgX2NvbmZpZy5yaWRlKSB7XG4gICAgICAgIGRhdGEucGF1c2UoKVxuICAgICAgICBkYXRhLmN5Y2xlKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgc3RhdGljIF9kYXRhQXBpQ2xpY2tIYW5kbGVyKGV2ZW50KSB7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodGhpcylcblxuICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9ICQoc2VsZWN0b3IpWzBdXG5cbiAgICBpZiAoIXRhcmdldCB8fCAhJCh0YXJnZXQpLmhhc0NsYXNzKENsYXNzTmFtZS5DQVJPVVNFTCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgIC4uLiQodGFyZ2V0KS5kYXRhKCksXG4gICAgICAuLi4kKHRoaXMpLmRhdGEoKVxuICAgIH1cbiAgICBjb25zdCBzbGlkZUluZGV4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xpZGUtdG8nKVxuXG4gICAgaWYgKHNsaWRlSW5kZXgpIHtcbiAgICAgIGNvbmZpZy5pbnRlcnZhbCA9IGZhbHNlXG4gICAgfVxuXG4gICAgQ2Fyb3VzZWwuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQodGFyZ2V0KSwgY29uZmlnKVxuXG4gICAgaWYgKHNsaWRlSW5kZXgpIHtcbiAgICAgICQodGFyZ2V0KS5kYXRhKERBVEFfS0VZKS50byhzbGlkZUluZGV4KVxuICAgIH1cblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbiQoZG9jdW1lbnQpXG4gIC5vbihFdmVudC5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IuREFUQV9TTElERSwgQ2Fyb3VzZWwuX2RhdGFBcGlDbGlja0hhbmRsZXIpXG5cbiQod2luZG93KS5vbihFdmVudC5MT0FEX0RBVEFfQVBJLCAoKSA9PiB7XG4gIGNvbnN0IGNhcm91c2VscyA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChTZWxlY3Rvci5EQVRBX1JJREUpKVxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2Fyb3VzZWxzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgJGNhcm91c2VsID0gJChjYXJvdXNlbHNbaV0pXG4gICAgQ2Fyb3VzZWwuX2pRdWVyeUludGVyZmFjZS5jYWxsKCRjYXJvdXNlbCwgJGNhcm91c2VsLmRhdGEoKSlcbiAgfVxufSlcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGpRdWVyeVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuJC5mbltOQU1FXSA9IENhcm91c2VsLl9qUXVlcnlJbnRlcmZhY2VcbiQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBDYXJvdXNlbFxuJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gKCkgPT4ge1xuICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUXG4gIHJldHVybiBDYXJvdXNlbC5falF1ZXJ5SW50ZXJmYWNlXG59XG5cbmV4cG9ydCBkZWZhdWx0IENhcm91c2VsXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjQuMSk6IGNvbGxhcHNlLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknXG5pbXBvcnQgVXRpbCBmcm9tICcuL3V0aWwnXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE5BTUUgICAgICAgICAgICAgICAgPSAnY29sbGFwc2UnXG5jb25zdCBWRVJTSU9OICAgICAgICAgICAgID0gJzQuNC4xJ1xuY29uc3QgREFUQV9LRVkgICAgICAgICAgICA9ICdicy5jb2xsYXBzZSdcbmNvbnN0IEVWRU5UX0tFWSAgICAgICAgICAgPSBgLiR7REFUQV9LRVl9YFxuY29uc3QgREFUQV9BUElfS0VZICAgICAgICA9ICcuZGF0YS1hcGknXG5jb25zdCBKUVVFUllfTk9fQ09ORkxJQ1QgID0gJC5mbltOQU1FXVxuXG5jb25zdCBEZWZhdWx0ID0ge1xuICB0b2dnbGUgOiB0cnVlLFxuICBwYXJlbnQgOiAnJ1xufVxuXG5jb25zdCBEZWZhdWx0VHlwZSA9IHtcbiAgdG9nZ2xlIDogJ2Jvb2xlYW4nLFxuICBwYXJlbnQgOiAnKHN0cmluZ3xlbGVtZW50KSdcbn1cblxuY29uc3QgRXZlbnQgPSB7XG4gIFNIT1cgICAgICAgICAgIDogYHNob3cke0VWRU5UX0tFWX1gLFxuICBTSE9XTiAgICAgICAgICA6IGBzaG93biR7RVZFTlRfS0VZfWAsXG4gIEhJREUgICAgICAgICAgIDogYGhpZGUke0VWRU5UX0tFWX1gLFxuICBISURERU4gICAgICAgICA6IGBoaWRkZW4ke0VWRU5UX0tFWX1gLFxuICBDTElDS19EQVRBX0FQSSA6IGBjbGljayR7RVZFTlRfS0VZfSR7REFUQV9BUElfS0VZfWBcbn1cblxuY29uc3QgQ2xhc3NOYW1lID0ge1xuICBTSE9XICAgICAgIDogJ3Nob3cnLFxuICBDT0xMQVBTRSAgIDogJ2NvbGxhcHNlJyxcbiAgQ09MTEFQU0lORyA6ICdjb2xsYXBzaW5nJyxcbiAgQ09MTEFQU0VEICA6ICdjb2xsYXBzZWQnXG59XG5cbmNvbnN0IERpbWVuc2lvbiA9IHtcbiAgV0lEVEggIDogJ3dpZHRoJyxcbiAgSEVJR0hUIDogJ2hlaWdodCdcbn1cblxuY29uc3QgU2VsZWN0b3IgPSB7XG4gIEFDVElWRVMgICAgIDogJy5zaG93LCAuY29sbGFwc2luZycsXG4gIERBVEFfVE9HR0xFIDogJ1tkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdJ1xufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgQ29sbGFwc2Uge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZVxuICAgIHRoaXMuX2VsZW1lbnQgICAgICAgICA9IGVsZW1lbnRcbiAgICB0aGlzLl9jb25maWcgICAgICAgICAgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKVxuICAgIHRoaXMuX3RyaWdnZXJBcnJheSAgICA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcbiAgICAgIGBbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtocmVmPVwiIyR7ZWxlbWVudC5pZH1cIl0sYCArXG4gICAgICBgW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1bZGF0YS10YXJnZXQ9XCIjJHtlbGVtZW50LmlkfVwiXWBcbiAgICApKVxuXG4gICAgY29uc3QgdG9nZ2xlTGlzdCA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChTZWxlY3Rvci5EQVRBX1RPR0dMRSkpXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRvZ2dsZUxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsZW0gPSB0b2dnbGVMaXN0W2ldXG4gICAgICBjb25zdCBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtKVxuICAgICAgY29uc3QgZmlsdGVyRWxlbWVudCA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpXG4gICAgICAgIC5maWx0ZXIoKGZvdW5kRWxlbSkgPT4gZm91bmRFbGVtID09PSBlbGVtZW50KVxuXG4gICAgICBpZiAoc2VsZWN0b3IgIT09IG51bGwgJiYgZmlsdGVyRWxlbWVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdG9yID0gc2VsZWN0b3JcbiAgICAgICAgdGhpcy5fdHJpZ2dlckFycmF5LnB1c2goZWxlbSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9wYXJlbnQgPSB0aGlzLl9jb25maWcucGFyZW50ID8gdGhpcy5fZ2V0UGFyZW50KCkgOiBudWxsXG5cbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcbiAgICAgIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl90cmlnZ2VyQXJyYXkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NvbmZpZy50b2dnbGUpIHtcbiAgICAgIHRoaXMudG9nZ2xlKClcbiAgICB9XG4gIH1cblxuICAvLyBHZXR0ZXJzXG5cbiAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xuICAgIHJldHVybiBWRVJTSU9OXG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRcbiAgfVxuXG4gIC8vIFB1YmxpY1xuXG4gIHRvZ2dsZSgpIHtcbiAgICBpZiAoJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuU0hPVykpIHtcbiAgICAgIHRoaXMuaGlkZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2hvdygpXG4gICAgfVxuICB9XG5cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8XG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGFjdGl2ZXNcbiAgICBsZXQgYWN0aXZlc0RhdGFcblxuICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgIGFjdGl2ZXMgPSBbXS5zbGljZS5jYWxsKHRoaXMuX3BhcmVudC5xdWVyeVNlbGVjdG9yQWxsKFNlbGVjdG9yLkFDVElWRVMpKVxuICAgICAgICAuZmlsdGVyKChlbGVtKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jb25maWcucGFyZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCdkYXRhLXBhcmVudCcpID09PSB0aGlzLl9jb25maWcucGFyZW50XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKENsYXNzTmFtZS5DT0xMQVBTRSlcbiAgICAgICAgfSlcblxuICAgICAgaWYgKGFjdGl2ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGFjdGl2ZXMgPSBudWxsXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFjdGl2ZXMpIHtcbiAgICAgIGFjdGl2ZXNEYXRhID0gJChhY3RpdmVzKS5ub3QodGhpcy5fc2VsZWN0b3IpLmRhdGEoREFUQV9LRVkpXG4gICAgICBpZiAoYWN0aXZlc0RhdGEgJiYgYWN0aXZlc0RhdGEuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzdGFydEV2ZW50ID0gJC5FdmVudChFdmVudC5TSE9XKVxuICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzdGFydEV2ZW50KVxuICAgIGlmIChzdGFydEV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoYWN0aXZlcykge1xuICAgICAgQ29sbGFwc2UuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQoYWN0aXZlcykubm90KHRoaXMuX3NlbGVjdG9yKSwgJ2hpZGUnKVxuICAgICAgaWYgKCFhY3RpdmVzRGF0YSkge1xuICAgICAgICAkKGFjdGl2ZXMpLmRhdGEoREFUQV9LRVksIG51bGwpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5fZ2V0RGltZW5zaW9uKClcblxuICAgICQodGhpcy5fZWxlbWVudClcbiAgICAgIC5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0UpXG4gICAgICAuYWRkQ2xhc3MoQ2xhc3NOYW1lLkNPTExBUFNJTkcpXG5cbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAwXG5cbiAgICBpZiAodGhpcy5fdHJpZ2dlckFycmF5Lmxlbmd0aCkge1xuICAgICAgJCh0aGlzLl90cmlnZ2VyQXJyYXkpXG4gICAgICAgIC5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0VEKVxuICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpXG4gICAgfVxuXG4gICAgdGhpcy5zZXRUcmFuc2l0aW9uaW5nKHRydWUpXG5cbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICQodGhpcy5fZWxlbWVudClcbiAgICAgICAgLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5DT0xMQVBTSU5HKVxuICAgICAgICAuYWRkQ2xhc3MoQ2xhc3NOYW1lLkNPTExBUFNFKVxuICAgICAgICAuYWRkQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpXG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9ICcnXG5cbiAgICAgIHRoaXMuc2V0VHJhbnNpdGlvbmluZyhmYWxzZSlcblxuICAgICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKEV2ZW50LlNIT1dOKVxuICAgIH1cblxuICAgIGNvbnN0IGNhcGl0YWxpemVkRGltZW5zaW9uID0gZGltZW5zaW9uWzBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoMSlcbiAgICBjb25zdCBzY3JvbGxTaXplID0gYHNjcm9sbCR7Y2FwaXRhbGl6ZWREaW1lbnNpb259YFxuICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudClcblxuICAgICQodGhpcy5fZWxlbWVudClcbiAgICAgIC5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpXG4gICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkR1cmF0aW9uKVxuXG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gYCR7dGhpcy5fZWxlbWVudFtzY3JvbGxTaXplXX1weGBcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fFxuICAgICAgISQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBzdGFydEV2ZW50ID0gJC5FdmVudChFdmVudC5ISURFKVxuICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzdGFydEV2ZW50KVxuICAgIGlmIChzdGFydEV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLl9nZXREaW1lbnNpb24oKVxuXG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gYCR7dGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtkaW1lbnNpb25dfXB4YFxuXG4gICAgVXRpbC5yZWZsb3codGhpcy5fZWxlbWVudClcblxuICAgICQodGhpcy5fZWxlbWVudClcbiAgICAgIC5hZGRDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0lORylcbiAgICAgIC5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0UpXG4gICAgICAucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpXG5cbiAgICBjb25zdCB0cmlnZ2VyQXJyYXlMZW5ndGggPSB0aGlzLl90cmlnZ2VyQXJyYXkubGVuZ3RoXG4gICAgaWYgKHRyaWdnZXJBcnJheUxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJpZ2dlckFycmF5TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdHJpZ2dlciA9IHRoaXMuX3RyaWdnZXJBcnJheVtpXVxuICAgICAgICBjb25zdCBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0cmlnZ2VyKVxuXG4gICAgICAgIGlmIChzZWxlY3RvciAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0ICRlbGVtID0gJChbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKSlcbiAgICAgICAgICBpZiAoISRlbGVtLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKSkge1xuICAgICAgICAgICAgJCh0cmlnZ2VyKS5hZGRDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0VEKVxuICAgICAgICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0VHJhbnNpdGlvbmluZyh0cnVlKVxuXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLnNldFRyYW5zaXRpb25pbmcoZmFsc2UpXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpXG4gICAgICAgIC5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQ09MTEFQU0lORylcbiAgICAgICAgLmFkZENsYXNzKENsYXNzTmFtZS5DT0xMQVBTRSlcbiAgICAgICAgLnRyaWdnZXIoRXZlbnQuSElEREVOKVxuICAgIH1cblxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9ICcnXG4gICAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KVxuXG4gICAgJCh0aGlzLl9lbGVtZW50KVxuICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSlcbiAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pXG4gIH1cblxuICBzZXRUcmFuc2l0aW9uaW5nKGlzVHJhbnNpdGlvbmluZykge1xuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGlzVHJhbnNpdGlvbmluZ1xuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpXG5cbiAgICB0aGlzLl9jb25maWcgICAgICAgICAgPSBudWxsXG4gICAgdGhpcy5fcGFyZW50ICAgICAgICAgID0gbnVsbFxuICAgIHRoaXMuX2VsZW1lbnQgICAgICAgICA9IG51bGxcbiAgICB0aGlzLl90cmlnZ2VyQXJyYXkgICAgPSBudWxsXG4gICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gbnVsbFxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0ge1xuICAgICAgLi4uRGVmYXVsdCxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH1cbiAgICBjb25maWcudG9nZ2xlID0gQm9vbGVhbihjb25maWcudG9nZ2xlKSAvLyBDb2VyY2Ugc3RyaW5nIHZhbHVlc1xuICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKE5BTUUsIGNvbmZpZywgRGVmYXVsdFR5cGUpXG4gICAgcmV0dXJuIGNvbmZpZ1xuICB9XG5cbiAgX2dldERpbWVuc2lvbigpIHtcbiAgICBjb25zdCBoYXNXaWR0aCA9ICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoRGltZW5zaW9uLldJRFRIKVxuICAgIHJldHVybiBoYXNXaWR0aCA/IERpbWVuc2lvbi5XSURUSCA6IERpbWVuc2lvbi5IRUlHSFRcbiAgfVxuXG4gIF9nZXRQYXJlbnQoKSB7XG4gICAgbGV0IHBhcmVudFxuXG4gICAgaWYgKFV0aWwuaXNFbGVtZW50KHRoaXMuX2NvbmZpZy5wYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSB0aGlzLl9jb25maWcucGFyZW50XG5cbiAgICAgIC8vIEl0J3MgYSBqUXVlcnkgb2JqZWN0XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2NvbmZpZy5wYXJlbnQuanF1ZXJ5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwYXJlbnQgPSB0aGlzLl9jb25maWcucGFyZW50WzBdXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5fY29uZmlnLnBhcmVudClcbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3RvciA9XG4gICAgICBgW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1bZGF0YS1wYXJlbnQ9XCIke3RoaXMuX2NvbmZpZy5wYXJlbnR9XCJdYFxuXG4gICAgY29uc3QgY2hpbGRyZW4gPSBbXS5zbGljZS5jYWxsKHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSlcbiAgICAkKGNoaWxkcmVuKS5lYWNoKChpLCBlbGVtZW50KSA9PiB7XG4gICAgICB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoXG4gICAgICAgIENvbGxhcHNlLl9nZXRUYXJnZXRGcm9tRWxlbWVudChlbGVtZW50KSxcbiAgICAgICAgW2VsZW1lbnRdXG4gICAgICApXG4gICAgfSlcblxuICAgIHJldHVybiBwYXJlbnRcbiAgfVxuXG4gIF9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoZWxlbWVudCwgdHJpZ2dlckFycmF5KSB7XG4gICAgY29uc3QgaXNPcGVuID0gJChlbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuU0hPVylcblxuICAgIGlmICh0cmlnZ2VyQXJyYXkubGVuZ3RoKSB7XG4gICAgICAkKHRyaWdnZXJBcnJheSlcbiAgICAgICAgLnRvZ2dsZUNsYXNzKENsYXNzTmFtZS5DT0xMQVBTRUQsICFpc09wZW4pXG4gICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgaXNPcGVuKVxuICAgIH1cbiAgfVxuXG4gIC8vIFN0YXRpY1xuXG4gIHN0YXRpYyBfZ2V0VGFyZ2V0RnJvbUVsZW1lbnQoZWxlbWVudCkge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW1lbnQpXG4gICAgcmV0dXJuIHNlbGVjdG9yID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcikgOiBudWxsXG4gIH1cblxuICBzdGF0aWMgX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0ICR0aGlzICAgPSAkKHRoaXMpXG4gICAgICBsZXQgZGF0YSAgICAgID0gJHRoaXMuZGF0YShEQVRBX0tFWSlcbiAgICAgIGNvbnN0IF9jb25maWcgPSB7XG4gICAgICAgIC4uLkRlZmF1bHQsXG4gICAgICAgIC4uLiR0aGlzLmRhdGEoKSxcbiAgICAgICAgLi4udHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnID8gY29uZmlnIDoge31cbiAgICAgIH1cblxuICAgICAgaWYgKCFkYXRhICYmIF9jb25maWcudG9nZ2xlICYmIC9zaG93fGhpZGUvLnRlc3QoY29uZmlnKSkge1xuICAgICAgICBfY29uZmlnLnRvZ2dsZSA9IGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICBkYXRhID0gbmV3IENvbGxhcHNlKHRoaXMsIF9jb25maWcpXG4gICAgICAgICR0aGlzLmRhdGEoREFUQV9LRVksIGRhdGEpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApXG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtjb25maWddKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuJChkb2N1bWVudCkub24oRXZlbnQuQ0xJQ0tfREFUQV9BUEksIFNlbGVjdG9yLkRBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgLy8gcHJldmVudERlZmF1bHQgb25seSBmb3IgPGE+IGVsZW1lbnRzICh3aGljaCBjaGFuZ2UgdGhlIFVSTCkgbm90IGluc2lkZSB0aGUgY29sbGFwc2libGUgZWxlbWVudFxuICBpZiAoZXZlbnQuY3VycmVudFRhcmdldC50YWdOYW1lID09PSAnQScpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cblxuICBjb25zdCAkdHJpZ2dlciA9ICQodGhpcylcbiAgY29uc3Qgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodGhpcylcbiAgY29uc3Qgc2VsZWN0b3JzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSlcblxuICAkKHNlbGVjdG9ycykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgJHRhcmdldCA9ICQodGhpcylcbiAgICBjb25zdCBkYXRhICAgID0gJHRhcmdldC5kYXRhKERBVEFfS0VZKVxuICAgIGNvbnN0IGNvbmZpZyAgPSBkYXRhID8gJ3RvZ2dsZScgOiAkdHJpZ2dlci5kYXRhKClcbiAgICBDb2xsYXBzZS5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJHRhcmdldCwgY29uZmlnKVxuICB9KVxufSlcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGpRdWVyeVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuJC5mbltOQU1FXSA9IENvbGxhcHNlLl9qUXVlcnlJbnRlcmZhY2VcbiQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBDb2xsYXBzZVxuJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gKCkgPT4ge1xuICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUXG4gIHJldHVybiBDb2xsYXBzZS5falF1ZXJ5SW50ZXJmYWNlXG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbGxhcHNlXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjQuMSk6IGRyb3Bkb3duLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknXG5pbXBvcnQgUG9wcGVyIGZyb20gJ3BvcHBlci5qcydcbmltcG9ydCBVdGlsIGZyb20gJy4vdXRpbCdcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvbnN0YW50c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgTkFNRSAgICAgICAgICAgICAgICAgICAgID0gJ2Ryb3Bkb3duJ1xuY29uc3QgVkVSU0lPTiAgICAgICAgICAgICAgICAgID0gJzQuNC4xJ1xuY29uc3QgREFUQV9LRVkgICAgICAgICAgICAgICAgID0gJ2JzLmRyb3Bkb3duJ1xuY29uc3QgRVZFTlRfS0VZICAgICAgICAgICAgICAgID0gYC4ke0RBVEFfS0VZfWBcbmNvbnN0IERBVEFfQVBJX0tFWSAgICAgICAgICAgICA9ICcuZGF0YS1hcGknXG5jb25zdCBKUVVFUllfTk9fQ09ORkxJQ1QgICAgICAgPSAkLmZuW05BTUVdXG5jb25zdCBFU0NBUEVfS0VZQ09ERSAgICAgICAgICAgPSAyNyAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciBFc2NhcGUgKEVzYykga2V5XG5jb25zdCBTUEFDRV9LRVlDT0RFICAgICAgICAgICAgPSAzMiAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciBzcGFjZSBrZXlcbmNvbnN0IFRBQl9LRVlDT0RFICAgICAgICAgICAgICA9IDkgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgdGFiIGtleVxuY29uc3QgQVJST1dfVVBfS0VZQ09ERSAgICAgICAgID0gMzggLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgdXAgYXJyb3cga2V5XG5jb25zdCBBUlJPV19ET1dOX0tFWUNPREUgICAgICAgPSA0MCAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciBkb3duIGFycm93IGtleVxuY29uc3QgUklHSFRfTU9VU0VfQlVUVE9OX1dISUNIID0gMyAvLyBNb3VzZUV2ZW50LndoaWNoIHZhbHVlIGZvciB0aGUgcmlnaHQgYnV0dG9uIChhc3N1bWluZyBhIHJpZ2h0LWhhbmRlZCBtb3VzZSlcbmNvbnN0IFJFR0VYUF9LRVlET1dOICAgICAgICAgICA9IG5ldyBSZWdFeHAoYCR7QVJST1dfVVBfS0VZQ09ERX18JHtBUlJPV19ET1dOX0tFWUNPREV9fCR7RVNDQVBFX0tFWUNPREV9YClcblxuY29uc3QgRXZlbnQgPSB7XG4gIEhJREUgICAgICAgICAgICAgOiBgaGlkZSR7RVZFTlRfS0VZfWAsXG4gIEhJRERFTiAgICAgICAgICAgOiBgaGlkZGVuJHtFVkVOVF9LRVl9YCxcbiAgU0hPVyAgICAgICAgICAgICA6IGBzaG93JHtFVkVOVF9LRVl9YCxcbiAgU0hPV04gICAgICAgICAgICA6IGBzaG93biR7RVZFTlRfS0VZfWAsXG4gIENMSUNLICAgICAgICAgICAgOiBgY2xpY2ske0VWRU5UX0tFWX1gLFxuICBDTElDS19EQVRBX0FQSSAgIDogYGNsaWNrJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YCxcbiAgS0VZRE9XTl9EQVRBX0FQSSA6IGBrZXlkb3duJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YCxcbiAgS0VZVVBfREFUQV9BUEkgICA6IGBrZXl1cCR7RVZFTlRfS0VZfSR7REFUQV9BUElfS0VZfWBcbn1cblxuY29uc3QgQ2xhc3NOYW1lID0ge1xuICBESVNBQkxFRCAgICAgICAgOiAnZGlzYWJsZWQnLFxuICBTSE9XICAgICAgICAgICAgOiAnc2hvdycsXG4gIERST1BVUCAgICAgICAgICA6ICdkcm9wdXAnLFxuICBEUk9QUklHSFQgICAgICAgOiAnZHJvcHJpZ2h0JyxcbiAgRFJPUExFRlQgICAgICAgIDogJ2Ryb3BsZWZ0JyxcbiAgTUVOVVJJR0hUICAgICAgIDogJ2Ryb3Bkb3duLW1lbnUtcmlnaHQnLFxuICBNRU5VTEVGVCAgICAgICAgOiAnZHJvcGRvd24tbWVudS1sZWZ0JyxcbiAgUE9TSVRJT05fU1RBVElDIDogJ3Bvc2l0aW9uLXN0YXRpYydcbn1cblxuY29uc3QgU2VsZWN0b3IgPSB7XG4gIERBVEFfVE9HR0xFICAgOiAnW2RhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIl0nLFxuICBGT1JNX0NISUxEICAgIDogJy5kcm9wZG93biBmb3JtJyxcbiAgTUVOVSAgICAgICAgICA6ICcuZHJvcGRvd24tbWVudScsXG4gIE5BVkJBUl9OQVYgICAgOiAnLm5hdmJhci1uYXYnLFxuICBWSVNJQkxFX0lURU1TIDogJy5kcm9wZG93bi1tZW51IC5kcm9wZG93bi1pdGVtOm5vdCguZGlzYWJsZWQpOm5vdCg6ZGlzYWJsZWQpJ1xufVxuXG5jb25zdCBBdHRhY2htZW50TWFwID0ge1xuICBUT1AgICAgICAgOiAndG9wLXN0YXJ0JyxcbiAgVE9QRU5EICAgIDogJ3RvcC1lbmQnLFxuICBCT1RUT00gICAgOiAnYm90dG9tLXN0YXJ0JyxcbiAgQk9UVE9NRU5EIDogJ2JvdHRvbS1lbmQnLFxuICBSSUdIVCAgICAgOiAncmlnaHQtc3RhcnQnLFxuICBSSUdIVEVORCAgOiAncmlnaHQtZW5kJyxcbiAgTEVGVCAgICAgIDogJ2xlZnQtc3RhcnQnLFxuICBMRUZURU5EICAgOiAnbGVmdC1lbmQnXG59XG5cbmNvbnN0IERlZmF1bHQgPSB7XG4gIG9mZnNldCAgICAgICA6IDAsXG4gIGZsaXAgICAgICAgICA6IHRydWUsXG4gIGJvdW5kYXJ5ICAgICA6ICdzY3JvbGxQYXJlbnQnLFxuICByZWZlcmVuY2UgICAgOiAndG9nZ2xlJyxcbiAgZGlzcGxheSAgICAgIDogJ2R5bmFtaWMnLFxuICBwb3BwZXJDb25maWcgOiBudWxsXG59XG5cbmNvbnN0IERlZmF1bHRUeXBlID0ge1xuICBvZmZzZXQgICAgICAgOiAnKG51bWJlcnxzdHJpbmd8ZnVuY3Rpb24pJyxcbiAgZmxpcCAgICAgICAgIDogJ2Jvb2xlYW4nLFxuICBib3VuZGFyeSAgICAgOiAnKHN0cmluZ3xlbGVtZW50KScsXG4gIHJlZmVyZW5jZSAgICA6ICcoc3RyaW5nfGVsZW1lbnQpJyxcbiAgZGlzcGxheSAgICAgIDogJ3N0cmluZycsXG4gIHBvcHBlckNvbmZpZyA6ICcobnVsbHxvYmplY3QpJ1xufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgRHJvcGRvd24ge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICB0aGlzLl9lbGVtZW50ICA9IGVsZW1lbnRcbiAgICB0aGlzLl9wb3BwZXIgICA9IG51bGxcbiAgICB0aGlzLl9jb25maWcgICA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpXG4gICAgdGhpcy5fbWVudSAgICAgPSB0aGlzLl9nZXRNZW51RWxlbWVudCgpXG4gICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKVxuXG4gICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKVxuICB9XG5cbiAgLy8gR2V0dGVyc1xuXG4gIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICByZXR1cm4gVkVSU0lPTlxuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0XG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZVxuICB9XG5cbiAgLy8gUHVibGljXG5cbiAgdG9nZ2xlKCkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50LmRpc2FibGVkIHx8ICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkRJU0FCTEVEKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgaXNBY3RpdmUgPSAkKHRoaXMuX21lbnUpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKVxuXG4gICAgRHJvcGRvd24uX2NsZWFyTWVudXMoKVxuXG4gICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLnNob3codHJ1ZSlcbiAgfVxuXG4gIHNob3codXNlUG9wcGVyID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5fZWxlbWVudC5kaXNhYmxlZCB8fCAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5ESVNBQkxFRCkgfHwgJCh0aGlzLl9tZW51KS5oYXNDbGFzcyhDbGFzc05hbWUuU0hPVykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgfVxuICAgIGNvbnN0IHNob3dFdmVudCA9ICQuRXZlbnQoRXZlbnQuU0hPVywgcmVsYXRlZFRhcmdldClcbiAgICBjb25zdCBwYXJlbnQgPSBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudClcblxuICAgICQocGFyZW50KS50cmlnZ2VyKHNob3dFdmVudClcblxuICAgIGlmIChzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIERpc2FibGUgdG90YWxseSBQb3BwZXIuanMgZm9yIERyb3Bkb3duIGluIE5hdmJhclxuICAgIGlmICghdGhpcy5faW5OYXZiYXIgJiYgdXNlUG9wcGVyKSB7XG4gICAgICAvKipcbiAgICAgICAqIENoZWNrIGZvciBQb3BwZXIgZGVwZW5kZW5jeVxuICAgICAgICogUG9wcGVyIC0gaHR0cHM6Ly9wb3BwZXIuanMub3JnXG4gICAgICAgKi9cbiAgICAgIGlmICh0eXBlb2YgUG9wcGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb290c3RyYXBcXCdzIGRyb3Bkb3ducyByZXF1aXJlIFBvcHBlci5qcyAoaHR0cHM6Ly9wb3BwZXIuanMub3JnLyknKVxuICAgICAgfVxuXG4gICAgICBsZXQgcmVmZXJlbmNlRWxlbWVudCA9IHRoaXMuX2VsZW1lbnRcblxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UgPT09ICdwYXJlbnQnKSB7XG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSBwYXJlbnRcbiAgICAgIH0gZWxzZSBpZiAoVXRpbC5pc0VsZW1lbnQodGhpcy5fY29uZmlnLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IHRoaXMuX2NvbmZpZy5yZWZlcmVuY2VcblxuICAgICAgICAvLyBDaGVjayBpZiBpdCdzIGpRdWVyeSBlbGVtZW50XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fY29uZmlnLnJlZmVyZW5jZS5qcXVlcnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IHRoaXMuX2NvbmZpZy5yZWZlcmVuY2VbMF1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBib3VuZGFyeSBpcyBub3QgYHNjcm9sbFBhcmVudGAsIHRoZW4gc2V0IHBvc2l0aW9uIHRvIGBzdGF0aWNgXG4gICAgICAvLyB0byBhbGxvdyB0aGUgbWVudSB0byBcImVzY2FwZVwiIHRoZSBzY3JvbGwgcGFyZW50J3MgYm91bmRhcmllc1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2lzc3Vlcy8yNDI1MVxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5ib3VuZGFyeSAhPT0gJ3Njcm9sbFBhcmVudCcpIHtcbiAgICAgICAgJChwYXJlbnQpLmFkZENsYXNzKENsYXNzTmFtZS5QT1NJVElPTl9TVEFUSUMpXG4gICAgICB9XG4gICAgICB0aGlzLl9wb3BwZXIgPSBuZXcgUG9wcGVyKHJlZmVyZW5jZUVsZW1lbnQsIHRoaXMuX21lbnUsIHRoaXMuX2dldFBvcHBlckNvbmZpZygpKVxuICAgIH1cblxuICAgIC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSBhZGQgZXh0cmFcbiAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHRvIHRoZSBib2R5J3MgaW1tZWRpYXRlIGNoaWxkcmVuO1xuICAgIC8vIG9ubHkgbmVlZGVkIGJlY2F1c2Ugb2YgYnJva2VuIGV2ZW50IGRlbGVnYXRpb24gb24gaU9TXG4gICAgLy8gaHR0cHM6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDE0LzAyL21vdXNlX2V2ZW50X2J1Yi5odG1sXG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJlxuICAgICAgICAkKHBhcmVudCkuY2xvc2VzdChTZWxlY3Rvci5OQVZCQVJfTkFWKS5sZW5ndGggPT09IDApIHtcbiAgICAgICQoZG9jdW1lbnQuYm9keSkuY2hpbGRyZW4oKS5vbignbW91c2VvdmVyJywgbnVsbCwgJC5ub29wKVxuICAgIH1cblxuICAgIHRoaXMuX2VsZW1lbnQuZm9jdXMoKVxuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcblxuICAgICQodGhpcy5fbWVudSkudG9nZ2xlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpXG4gICAgJChwYXJlbnQpXG4gICAgICAudG9nZ2xlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpXG4gICAgICAudHJpZ2dlcigkLkV2ZW50KEV2ZW50LlNIT1dOLCByZWxhdGVkVGFyZ2V0KSlcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuZGlzYWJsZWQgfHwgJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuRElTQUJMRUQpIHx8ICEkKHRoaXMuX21lbnUpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICB9XG4gICAgY29uc3QgaGlkZUV2ZW50ID0gJC5FdmVudChFdmVudC5ISURFLCByZWxhdGVkVGFyZ2V0KVxuICAgIGNvbnN0IHBhcmVudCA9IERyb3Bkb3duLl9nZXRQYXJlbnRGcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KVxuXG4gICAgJChwYXJlbnQpLnRyaWdnZXIoaGlkZUV2ZW50KVxuXG4gICAgaWYgKGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BvcHBlcikge1xuICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKVxuICAgIH1cblxuICAgICQodGhpcy5fbWVudSkudG9nZ2xlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpXG4gICAgJChwYXJlbnQpXG4gICAgICAudG9nZ2xlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpXG4gICAgICAudHJpZ2dlcigkLkV2ZW50KEV2ZW50LkhJRERFTiwgcmVsYXRlZFRhcmdldCkpXG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgICQucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBEQVRBX0tFWSlcbiAgICAkKHRoaXMuX2VsZW1lbnQpLm9mZihFVkVOVF9LRVkpXG4gICAgdGhpcy5fZWxlbWVudCA9IG51bGxcbiAgICB0aGlzLl9tZW51ID0gbnVsbFxuICAgIGlmICh0aGlzLl9wb3BwZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KClcbiAgICAgIHRoaXMuX3BvcHBlciA9IG51bGxcbiAgICB9XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKVxuICAgIGlmICh0aGlzLl9wb3BwZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3BvcHBlci5zY2hlZHVsZVVwZGF0ZSgpXG4gICAgfVxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuXG4gIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAkKHRoaXMuX2VsZW1lbnQpLm9uKEV2ZW50LkNMSUNLLCAoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICB0aGlzLnRvZ2dsZSgpXG4gICAgfSlcbiAgfVxuXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0ge1xuICAgICAgLi4udGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LFxuICAgICAgLi4uJCh0aGlzLl9lbGVtZW50KS5kYXRhKCksXG4gICAgICAuLi5jb25maWdcbiAgICB9XG5cbiAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhcbiAgICAgIE5BTUUsXG4gICAgICBjb25maWcsXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlXG4gICAgKVxuXG4gICAgcmV0dXJuIGNvbmZpZ1xuICB9XG5cbiAgX2dldE1lbnVFbGVtZW50KCkge1xuICAgIGlmICghdGhpcy5fbWVudSkge1xuICAgICAgY29uc3QgcGFyZW50ID0gRHJvcGRvd24uX2dldFBhcmVudEZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpXG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5fbWVudSA9IHBhcmVudC5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yLk1FTlUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9tZW51XG4gIH1cblxuICBfZ2V0UGxhY2VtZW50KCkge1xuICAgIGNvbnN0ICRwYXJlbnREcm9wZG93biA9ICQodGhpcy5fZWxlbWVudC5wYXJlbnROb2RlKVxuICAgIGxldCBwbGFjZW1lbnQgPSBBdHRhY2htZW50TWFwLkJPVFRPTVxuXG4gICAgLy8gSGFuZGxlIGRyb3B1cFxuICAgIGlmICgkcGFyZW50RHJvcGRvd24uaGFzQ2xhc3MoQ2xhc3NOYW1lLkRST1BVUCkpIHtcbiAgICAgIHBsYWNlbWVudCA9IEF0dGFjaG1lbnRNYXAuVE9QXG4gICAgICBpZiAoJCh0aGlzLl9tZW51KS5oYXNDbGFzcyhDbGFzc05hbWUuTUVOVVJJR0hUKSkge1xuICAgICAgICBwbGFjZW1lbnQgPSBBdHRhY2htZW50TWFwLlRPUEVORFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJHBhcmVudERyb3Bkb3duLmhhc0NsYXNzKENsYXNzTmFtZS5EUk9QUklHSFQpKSB7XG4gICAgICBwbGFjZW1lbnQgPSBBdHRhY2htZW50TWFwLlJJR0hUXG4gICAgfSBlbHNlIGlmICgkcGFyZW50RHJvcGRvd24uaGFzQ2xhc3MoQ2xhc3NOYW1lLkRST1BMRUZUKSkge1xuICAgICAgcGxhY2VtZW50ID0gQXR0YWNobWVudE1hcC5MRUZUXG4gICAgfSBlbHNlIGlmICgkKHRoaXMuX21lbnUpLmhhc0NsYXNzKENsYXNzTmFtZS5NRU5VUklHSFQpKSB7XG4gICAgICBwbGFjZW1lbnQgPSBBdHRhY2htZW50TWFwLkJPVFRPTUVORFxuICAgIH1cbiAgICByZXR1cm4gcGxhY2VtZW50XG4gIH1cblxuICBfZGV0ZWN0TmF2YmFyKCkge1xuICAgIHJldHVybiAkKHRoaXMuX2VsZW1lbnQpLmNsb3Nlc3QoJy5uYXZiYXInKS5sZW5ndGggPiAwXG4gIH1cblxuICBfZ2V0T2Zmc2V0KCkge1xuICAgIGNvbnN0IG9mZnNldCA9IHt9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMuX2NvbmZpZy5vZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9mZnNldC5mbiA9IChkYXRhKSA9PiB7XG4gICAgICAgIGRhdGEub2Zmc2V0cyA9IHtcbiAgICAgICAgICAuLi5kYXRhLm9mZnNldHMsXG4gICAgICAgICAgLi4udGhpcy5fY29uZmlnLm9mZnNldChkYXRhLm9mZnNldHMsIHRoaXMuX2VsZW1lbnQpIHx8IHt9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQub2Zmc2V0ID0gdGhpcy5fY29uZmlnLm9mZnNldFxuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXRcbiAgfVxuXG4gIF9nZXRQb3BwZXJDb25maWcoKSB7XG4gICAgY29uc3QgcG9wcGVyQ29uZmlnID0ge1xuICAgICAgcGxhY2VtZW50OiB0aGlzLl9nZXRQbGFjZW1lbnQoKSxcbiAgICAgIG1vZGlmaWVyczoge1xuICAgICAgICBvZmZzZXQ6IHRoaXMuX2dldE9mZnNldCgpLFxuICAgICAgICBmbGlwOiB7XG4gICAgICAgICAgZW5hYmxlZDogdGhpcy5fY29uZmlnLmZsaXBcbiAgICAgICAgfSxcbiAgICAgICAgcHJldmVudE92ZXJmbG93OiB7XG4gICAgICAgICAgYm91bmRhcmllc0VsZW1lbnQ6IHRoaXMuX2NvbmZpZy5ib3VuZGFyeVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGlzYWJsZSBQb3BwZXIuanMgaWYgd2UgaGF2ZSBhIHN0YXRpYyBkaXNwbGF5XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5kaXNwbGF5ID09PSAnc3RhdGljJykge1xuICAgICAgcG9wcGVyQ29uZmlnLm1vZGlmaWVycy5hcHBseVN0eWxlID0ge1xuICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi5wb3BwZXJDb25maWcsXG4gICAgICAuLi50aGlzLl9jb25maWcucG9wcGVyQ29uZmlnXG4gICAgfVxuICB9XG5cbiAgLy8gU3RhdGljXG5cbiAgc3RhdGljIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgZGF0YSA9ICQodGhpcykuZGF0YShEQVRBX0tFWSlcbiAgICAgIGNvbnN0IF9jb25maWcgPSB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IG51bGxcblxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgRHJvcGRvd24odGhpcywgX2NvbmZpZylcbiAgICAgICAgJCh0aGlzKS5kYXRhKERBVEFfS0VZLCBkYXRhKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKVxuICAgICAgICB9XG4gICAgICAgIGRhdGFbY29uZmlnXSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHN0YXRpYyBfY2xlYXJNZW51cyhldmVudCkge1xuICAgIGlmIChldmVudCAmJiAoZXZlbnQud2hpY2ggPT09IFJJR0hUX01PVVNFX0JVVFRPTl9XSElDSCB8fFxuICAgICAgZXZlbnQudHlwZSA9PT0gJ2tleXVwJyAmJiBldmVudC53aGljaCAhPT0gVEFCX0tFWUNPREUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB0b2dnbGVzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNlbGVjdG9yLkRBVEFfVE9HR0xFKSlcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0b2dnbGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodG9nZ2xlc1tpXSlcbiAgICAgIGNvbnN0IGNvbnRleHQgPSAkKHRvZ2dsZXNbaV0pLmRhdGEoREFUQV9LRVkpXG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0b2dnbGVzW2ldXG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudCAmJiBldmVudC50eXBlID09PSAnY2xpY2snKSB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQuY2xpY2tFdmVudCA9IGV2ZW50XG4gICAgICB9XG5cbiAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBkcm9wZG93bk1lbnUgPSBjb250ZXh0Ll9tZW51XG4gICAgICBpZiAoISQocGFyZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuU0hPVykpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50ICYmIChldmVudC50eXBlID09PSAnY2xpY2snICYmXG4gICAgICAgICAgL2lucHV0fHRleHRhcmVhL2kudGVzdChldmVudC50YXJnZXQudGFnTmFtZSkgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJyAmJiBldmVudC53aGljaCA9PT0gVEFCX0tFWUNPREUpICYmXG4gICAgICAgICAgJC5jb250YWlucyhwYXJlbnQsIGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgY29uc3QgaGlkZUV2ZW50ID0gJC5FdmVudChFdmVudC5ISURFLCByZWxhdGVkVGFyZ2V0KVxuICAgICAgJChwYXJlbnQpLnRyaWdnZXIoaGlkZUV2ZW50KVxuICAgICAgaWYgKGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgcmVtb3ZlIHRoZSBleHRyYVxuICAgICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB3ZSBhZGRlZCBmb3IgaU9TIHN1cHBvcnRcbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgJChkb2N1bWVudC5ib2R5KS5jaGlsZHJlbigpLm9mZignbW91c2VvdmVyJywgbnVsbCwgJC5ub29wKVxuICAgICAgfVxuXG4gICAgICB0b2dnbGVzW2ldLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpXG5cbiAgICAgIGlmIChjb250ZXh0Ll9wb3BwZXIpIHtcbiAgICAgICAgY29udGV4dC5fcG9wcGVyLmRlc3Ryb3koKVxuICAgICAgfVxuXG4gICAgICAkKGRyb3Bkb3duTWVudSkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpXG4gICAgICAkKHBhcmVudClcbiAgICAgICAgLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5TSE9XKVxuICAgICAgICAudHJpZ2dlcigkLkV2ZW50KEV2ZW50LkhJRERFTiwgcmVsYXRlZFRhcmdldCkpXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIF9nZXRQYXJlbnRGcm9tRWxlbWVudChlbGVtZW50KSB7XG4gICAgbGV0IHBhcmVudFxuICAgIGNvbnN0IHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW1lbnQpXG5cbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIHBhcmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmVudCB8fCBlbGVtZW50LnBhcmVudE5vZGVcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIHN0YXRpYyBfZGF0YUFwaUtleWRvd25IYW5kbGVyKGV2ZW50KSB7XG4gICAgLy8gSWYgbm90IGlucHV0L3RleHRhcmVhOlxuICAgIC8vICAtIEFuZCBub3QgYSBrZXkgaW4gUkVHRVhQX0tFWURPV04gPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxuICAgIC8vIElmIGlucHV0L3RleHRhcmVhOlxuICAgIC8vICAtIElmIHNwYWNlIGtleSA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXG4gICAgLy8gIC0gSWYga2V5IGlzIG90aGVyIHRoYW4gZXNjYXBlXG4gICAgLy8gICAgLSBJZiBrZXkgaXMgbm90IHVwIG9yIGRvd24gPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxuICAgIC8vICAgIC0gSWYgdHJpZ2dlciBpbnNpZGUgdGhlIG1lbnUgPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxuICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKVxuICAgICAgPyBldmVudC53aGljaCA9PT0gU1BBQ0VfS0VZQ09ERSB8fCBldmVudC53aGljaCAhPT0gRVNDQVBFX0tFWUNPREUgJiZcbiAgICAgIChldmVudC53aGljaCAhPT0gQVJST1dfRE9XTl9LRVlDT0RFICYmIGV2ZW50LndoaWNoICE9PSBBUlJPV19VUF9LRVlDT0RFIHx8XG4gICAgICAgICQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KFNlbGVjdG9yLk1FTlUpLmxlbmd0aCkgOiAhUkVHRVhQX0tFWURPV04udGVzdChldmVudC53aGljaCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuXG4gICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgJCh0aGlzKS5oYXNDbGFzcyhDbGFzc05hbWUuRElTQUJMRUQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnQgICA9IERyb3Bkb3duLl9nZXRQYXJlbnRGcm9tRWxlbWVudCh0aGlzKVxuICAgIGNvbnN0IGlzQWN0aXZlID0gJChwYXJlbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKVxuXG4gICAgaWYgKCFpc0FjdGl2ZSAmJiBldmVudC53aGljaCA9PT0gRVNDQVBFX0tFWUNPREUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghaXNBY3RpdmUgfHwgaXNBY3RpdmUgJiYgKGV2ZW50LndoaWNoID09PSBFU0NBUEVfS0VZQ09ERSB8fCBldmVudC53aGljaCA9PT0gU1BBQ0VfS0VZQ09ERSkpIHtcbiAgICAgIGlmIChldmVudC53aGljaCA9PT0gRVNDQVBFX0tFWUNPREUpIHtcbiAgICAgICAgY29uc3QgdG9nZ2xlID0gcGFyZW50LnF1ZXJ5U2VsZWN0b3IoU2VsZWN0b3IuREFUQV9UT0dHTEUpXG4gICAgICAgICQodG9nZ2xlKS50cmlnZ2VyKCdmb2N1cycpXG4gICAgICB9XG5cbiAgICAgICQodGhpcykudHJpZ2dlcignY2xpY2snKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgaXRlbXMgPSBbXS5zbGljZS5jYWxsKHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKFNlbGVjdG9yLlZJU0lCTEVfSVRFTVMpKVxuICAgICAgLmZpbHRlcigoaXRlbSkgPT4gJChpdGVtKS5pcygnOnZpc2libGUnKSlcblxuICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBpbmRleCA9IGl0ZW1zLmluZGV4T2YoZXZlbnQudGFyZ2V0KVxuXG4gICAgaWYgKGV2ZW50LndoaWNoID09PSBBUlJPV19VUF9LRVlDT0RFICYmIGluZGV4ID4gMCkgeyAvLyBVcFxuICAgICAgaW5kZXgtLVxuICAgIH1cblxuICAgIGlmIChldmVudC53aGljaCA9PT0gQVJST1dfRE9XTl9LRVlDT0RFICYmIGluZGV4IDwgaXRlbXMubGVuZ3RoIC0gMSkgeyAvLyBEb3duXG4gICAgICBpbmRleCsrXG4gICAgfVxuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgaW5kZXggPSAwXG4gICAgfVxuXG4gICAgaXRlbXNbaW5kZXhdLmZvY3VzKClcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbiQoZG9jdW1lbnQpXG4gIC5vbihFdmVudC5LRVlET1dOX0RBVEFfQVBJLCBTZWxlY3Rvci5EQVRBX1RPR0dMRSwgRHJvcGRvd24uX2RhdGFBcGlLZXlkb3duSGFuZGxlcilcbiAgLm9uKEV2ZW50LktFWURPV05fREFUQV9BUEksIFNlbGVjdG9yLk1FTlUsIERyb3Bkb3duLl9kYXRhQXBpS2V5ZG93bkhhbmRsZXIpXG4gIC5vbihgJHtFdmVudC5DTElDS19EQVRBX0FQSX0gJHtFdmVudC5LRVlVUF9EQVRBX0FQSX1gLCBEcm9wZG93bi5fY2xlYXJNZW51cylcbiAgLm9uKEV2ZW50LkNMSUNLX0RBVEFfQVBJLCBTZWxlY3Rvci5EQVRBX1RPR0dMRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgRHJvcGRvd24uX2pRdWVyeUludGVyZmFjZS5jYWxsKCQodGhpcyksICd0b2dnbGUnKVxuICB9KVxuICAub24oRXZlbnQuQ0xJQ0tfREFUQV9BUEksIFNlbGVjdG9yLkZPUk1fQ0hJTEQsIChlKSA9PiB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICB9KVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4kLmZuW05BTUVdID0gRHJvcGRvd24uX2pRdWVyeUludGVyZmFjZVxuJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IERyb3Bkb3duXG4kLmZuW05BTUVdLm5vQ29uZmxpY3QgPSAoKSA9PiB7XG4gICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1RcbiAgcmV0dXJuIERyb3Bkb3duLl9qUXVlcnlJbnRlcmZhY2Vcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBEcm9wZG93blxuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC40LjEpOiBtb2RhbC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5J1xuaW1wb3J0IFV0aWwgZnJvbSAnLi91dGlsJ1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FICAgICAgICAgICAgICAgPSAnbW9kYWwnXG5jb25zdCBWRVJTSU9OICAgICAgICAgICAgPSAnNC40LjEnXG5jb25zdCBEQVRBX0tFWSAgICAgICAgICAgPSAnYnMubW9kYWwnXG5jb25zdCBFVkVOVF9LRVkgICAgICAgICAgPSBgLiR7REFUQV9LRVl9YFxuY29uc3QgREFUQV9BUElfS0VZICAgICAgID0gJy5kYXRhLWFwaSdcbmNvbnN0IEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV1cbmNvbnN0IEVTQ0FQRV9LRVlDT0RFICAgICA9IDI3IC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIEVzY2FwZSAoRXNjKSBrZXlcblxuY29uc3QgRGVmYXVsdCA9IHtcbiAgYmFja2Ryb3AgOiB0cnVlLFxuICBrZXlib2FyZCA6IHRydWUsXG4gIGZvY3VzICAgIDogdHJ1ZSxcbiAgc2hvdyAgICAgOiB0cnVlXG59XG5cbmNvbnN0IERlZmF1bHRUeXBlID0ge1xuICBiYWNrZHJvcCA6ICcoYm9vbGVhbnxzdHJpbmcpJyxcbiAga2V5Ym9hcmQgOiAnYm9vbGVhbicsXG4gIGZvY3VzICAgIDogJ2Jvb2xlYW4nLFxuICBzaG93ICAgICA6ICdib29sZWFuJ1xufVxuXG5jb25zdCBFdmVudCA9IHtcbiAgSElERSAgICAgICAgICAgICAgOiBgaGlkZSR7RVZFTlRfS0VZfWAsXG4gIEhJREVfUFJFVkVOVEVEICAgIDogYGhpZGVQcmV2ZW50ZWQke0VWRU5UX0tFWX1gLFxuICBISURERU4gICAgICAgICAgICA6IGBoaWRkZW4ke0VWRU5UX0tFWX1gLFxuICBTSE9XICAgICAgICAgICAgICA6IGBzaG93JHtFVkVOVF9LRVl9YCxcbiAgU0hPV04gICAgICAgICAgICAgOiBgc2hvd24ke0VWRU5UX0tFWX1gLFxuICBGT0NVU0lOICAgICAgICAgICA6IGBmb2N1c2luJHtFVkVOVF9LRVl9YCxcbiAgUkVTSVpFICAgICAgICAgICAgOiBgcmVzaXplJHtFVkVOVF9LRVl9YCxcbiAgQ0xJQ0tfRElTTUlTUyAgICAgOiBgY2xpY2suZGlzbWlzcyR7RVZFTlRfS0VZfWAsXG4gIEtFWURPV05fRElTTUlTUyAgIDogYGtleWRvd24uZGlzbWlzcyR7RVZFTlRfS0VZfWAsXG4gIE1PVVNFVVBfRElTTUlTUyAgIDogYG1vdXNldXAuZGlzbWlzcyR7RVZFTlRfS0VZfWAsXG4gIE1PVVNFRE9XTl9ESVNNSVNTIDogYG1vdXNlZG93bi5kaXNtaXNzJHtFVkVOVF9LRVl9YCxcbiAgQ0xJQ0tfREFUQV9BUEkgICAgOiBgY2xpY2ske0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gXG59XG5cbmNvbnN0IENsYXNzTmFtZSA9IHtcbiAgU0NST0xMQUJMRSAgICAgICAgIDogJ21vZGFsLWRpYWxvZy1zY3JvbGxhYmxlJyxcbiAgU0NST0xMQkFSX01FQVNVUkVSIDogJ21vZGFsLXNjcm9sbGJhci1tZWFzdXJlJyxcbiAgQkFDS0RST1AgICAgICAgICAgIDogJ21vZGFsLWJhY2tkcm9wJyxcbiAgT1BFTiAgICAgICAgICAgICAgIDogJ21vZGFsLW9wZW4nLFxuICBGQURFICAgICAgICAgICAgICAgOiAnZmFkZScsXG4gIFNIT1cgICAgICAgICAgICAgICA6ICdzaG93JyxcbiAgU1RBVElDICAgICAgICAgICAgIDogJ21vZGFsLXN0YXRpYydcbn1cblxuY29uc3QgU2VsZWN0b3IgPSB7XG4gIERJQUxPRyAgICAgICAgIDogJy5tb2RhbC1kaWFsb2cnLFxuICBNT0RBTF9CT0RZICAgICA6ICcubW9kYWwtYm9keScsXG4gIERBVEFfVE9HR0xFICAgIDogJ1tkYXRhLXRvZ2dsZT1cIm1vZGFsXCJdJyxcbiAgREFUQV9ESVNNSVNTICAgOiAnW2RhdGEtZGlzbWlzcz1cIm1vZGFsXCJdJyxcbiAgRklYRURfQ09OVEVOVCAgOiAnLmZpeGVkLXRvcCwgLmZpeGVkLWJvdHRvbSwgLmlzLWZpeGVkLCAuc3RpY2t5LXRvcCcsXG4gIFNUSUNLWV9DT05URU5UIDogJy5zdGlja3ktdG9wJ1xufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgTW9kYWwge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICB0aGlzLl9jb25maWcgICAgICAgICAgICAgID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZylcbiAgICB0aGlzLl9lbGVtZW50ICAgICAgICAgICAgID0gZWxlbWVudFxuICAgIHRoaXMuX2RpYWxvZyAgICAgICAgICAgICAgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoU2VsZWN0b3IuRElBTE9HKVxuICAgIHRoaXMuX2JhY2tkcm9wICAgICAgICAgICAgPSBudWxsXG4gICAgdGhpcy5faXNTaG93biAgICAgICAgICAgICA9IGZhbHNlXG4gICAgdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgICA9IGZhbHNlXG4gICAgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9IGZhbHNlXG4gICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nICAgICA9IGZhbHNlXG4gICAgdGhpcy5fc2Nyb2xsYmFyV2lkdGggICAgICA9IDBcbiAgfVxuXG4gIC8vIEdldHRlcnNcblxuICBzdGF0aWMgZ2V0IFZFUlNJT04oKSB7XG4gICAgcmV0dXJuIFZFUlNJT05cbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFxuICB9XG5cbiAgLy8gUHVibGljXG5cbiAgdG9nZ2xlKHJlbGF0ZWRUYXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KHJlbGF0ZWRUYXJnZXQpXG4gIH1cblxuICBzaG93KHJlbGF0ZWRUYXJnZXQpIHtcbiAgICBpZiAodGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICgkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5GQURFKSkge1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IHNob3dFdmVudCA9ICQuRXZlbnQoRXZlbnQuU0hPVywge1xuICAgICAgcmVsYXRlZFRhcmdldFxuICAgIH0pXG5cbiAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc2hvd0V2ZW50KVxuXG4gICAgaWYgKHRoaXMuX2lzU2hvd24gfHwgc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9pc1Nob3duID0gdHJ1ZVxuXG4gICAgdGhpcy5fY2hlY2tTY3JvbGxiYXIoKVxuICAgIHRoaXMuX3NldFNjcm9sbGJhcigpXG5cbiAgICB0aGlzLl9hZGp1c3REaWFsb2coKVxuXG4gICAgdGhpcy5fc2V0RXNjYXBlRXZlbnQoKVxuICAgIHRoaXMuX3NldFJlc2l6ZUV2ZW50KClcblxuICAgICQodGhpcy5fZWxlbWVudCkub24oXG4gICAgICBFdmVudC5DTElDS19ESVNNSVNTLFxuICAgICAgU2VsZWN0b3IuREFUQV9ESVNNSVNTLFxuICAgICAgKGV2ZW50KSA9PiB0aGlzLmhpZGUoZXZlbnQpXG4gICAgKVxuXG4gICAgJCh0aGlzLl9kaWFsb2cpLm9uKEV2ZW50Lk1PVVNFRE9XTl9ESVNNSVNTLCAoKSA9PiB7XG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uZShFdmVudC5NT1VTRVVQX0RJU01JU1MsIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoJChldmVudC50YXJnZXQpLmlzKHRoaXMuX2VsZW1lbnQpKSB7XG4gICAgICAgICAgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgdGhpcy5fc2hvd0JhY2tkcm9wKCgpID0+IHRoaXMuX3Nob3dFbGVtZW50KHJlbGF0ZWRUYXJnZXQpKVxuICB9XG5cbiAgaGlkZShldmVudCkge1xuICAgIGlmIChldmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIH1cblxuICAgIGlmICghdGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGhpZGVFdmVudCA9ICQuRXZlbnQoRXZlbnQuSElERSlcblxuICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihoaWRlRXZlbnQpXG5cbiAgICBpZiAoIXRoaXMuX2lzU2hvd24gfHwgaGlkZUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9pc1Nob3duID0gZmFsc2VcbiAgICBjb25zdCB0cmFuc2l0aW9uID0gJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuRkFERSlcblxuICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlXG4gICAgfVxuXG4gICAgdGhpcy5fc2V0RXNjYXBlRXZlbnQoKVxuICAgIHRoaXMuX3NldFJlc2l6ZUV2ZW50KClcblxuICAgICQoZG9jdW1lbnQpLm9mZihFdmVudC5GT0NVU0lOKVxuXG4gICAgJCh0aGlzLl9lbGVtZW50KS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuU0hPVylcblxuICAgICQodGhpcy5fZWxlbWVudCkub2ZmKEV2ZW50LkNMSUNLX0RJU01JU1MpXG4gICAgJCh0aGlzLl9kaWFsb2cpLm9mZihFdmVudC5NT1VTRURPV05fRElTTUlTUylcblxuXG4gICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbiAgPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpXG5cbiAgICAgICQodGhpcy5fZWxlbWVudClcbiAgICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCAoZXZlbnQpID0+IHRoaXMuX2hpZGVNb2RhbChldmVudCkpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hpZGVNb2RhbCgpXG4gICAgfVxuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICBbd2luZG93LCB0aGlzLl9lbGVtZW50LCB0aGlzLl9kaWFsb2ddXG4gICAgICAuZm9yRWFjaCgoaHRtbEVsZW1lbnQpID0+ICQoaHRtbEVsZW1lbnQpLm9mZihFVkVOVF9LRVkpKVxuXG4gICAgLyoqXG4gICAgICogYGRvY3VtZW50YCBoYXMgMiBldmVudHMgYEV2ZW50LkZPQ1VTSU5gIGFuZCBgRXZlbnQuQ0xJQ0tfREFUQV9BUElgXG4gICAgICogRG8gbm90IG1vdmUgYGRvY3VtZW50YCBpbiBgaHRtbEVsZW1lbnRzYCBhcnJheVxuICAgICAqIEl0IHdpbGwgcmVtb3ZlIGBFdmVudC5DTElDS19EQVRBX0FQSWAgZXZlbnQgdGhhdCBzaG91bGQgcmVtYWluXG4gICAgICovXG4gICAgJChkb2N1bWVudCkub2ZmKEV2ZW50LkZPQ1VTSU4pXG5cbiAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpXG5cbiAgICB0aGlzLl9jb25maWcgICAgICAgICAgICAgID0gbnVsbFxuICAgIHRoaXMuX2VsZW1lbnQgICAgICAgICAgICAgPSBudWxsXG4gICAgdGhpcy5fZGlhbG9nICAgICAgICAgICAgICA9IG51bGxcbiAgICB0aGlzLl9iYWNrZHJvcCAgICAgICAgICAgID0gbnVsbFxuICAgIHRoaXMuX2lzU2hvd24gICAgICAgICAgICAgPSBudWxsXG4gICAgdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgICA9IG51bGxcbiAgICB0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gbnVsbFxuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyAgICAgPSBudWxsXG4gICAgdGhpcy5fc2Nyb2xsYmFyV2lkdGggICAgICA9IG51bGxcbiAgfVxuXG4gIGhhbmRsZVVwZGF0ZSgpIHtcbiAgICB0aGlzLl9hZGp1c3REaWFsb2coKVxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0ge1xuICAgICAgLi4uRGVmYXVsdCxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH1cbiAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhOQU1FLCBjb25maWcsIERlZmF1bHRUeXBlKVxuICAgIHJldHVybiBjb25maWdcbiAgfVxuXG4gIF90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCkge1xuICAgIGlmICh0aGlzLl9jb25maWcuYmFja2Ryb3AgPT09ICdzdGF0aWMnKSB7XG4gICAgICBjb25zdCBoaWRlRXZlbnRQcmV2ZW50ZWQgPSAkLkV2ZW50KEV2ZW50LkhJREVfUFJFVkVOVEVEKVxuXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoaGlkZUV2ZW50UHJldmVudGVkKVxuICAgICAgaWYgKGhpZGVFdmVudFByZXZlbnRlZC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ2xhc3NOYW1lLlNUQVRJQylcblxuICAgICAgY29uc3QgbW9kYWxUcmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpXG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsICgpID0+IHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENsYXNzTmFtZS5TVEFUSUMpXG4gICAgICB9KVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQobW9kYWxUcmFuc2l0aW9uRHVyYXRpb24pXG4gICAgICB0aGlzLl9lbGVtZW50LmZvY3VzKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRlKClcbiAgICB9XG4gIH1cblxuICBfc2hvd0VsZW1lbnQocmVsYXRlZFRhcmdldCkge1xuICAgIGNvbnN0IHRyYW5zaXRpb24gPSAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5GQURFKVxuICAgIGNvbnN0IG1vZGFsQm9keSA9IHRoaXMuX2RpYWxvZyA/IHRoaXMuX2RpYWxvZy5xdWVyeVNlbGVjdG9yKFNlbGVjdG9yLk1PREFMX0JPRFkpIDogbnVsbFxuXG4gICAgaWYgKCF0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUgfHxcbiAgICAgICAgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgLy8gRG9uJ3QgbW92ZSBtb2RhbCdzIERPTSBwb3NpdGlvblxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50KVxuICAgIH1cblxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKVxuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJywgdHJ1ZSlcblxuICAgIGlmICgkKHRoaXMuX2RpYWxvZykuaGFzQ2xhc3MoQ2xhc3NOYW1lLlNDUk9MTEFCTEUpICYmIG1vZGFsQm9keSkge1xuICAgICAgbW9kYWxCb2R5LnNjcm9sbFRvcCA9IDBcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZWxlbWVudC5zY3JvbGxUb3AgPSAwXG4gICAgfVxuXG4gICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgIFV0aWwucmVmbG93KHRoaXMuX2VsZW1lbnQpXG4gICAgfVxuXG4gICAgJCh0aGlzLl9lbGVtZW50KS5hZGRDbGFzcyhDbGFzc05hbWUuU0hPVylcblxuICAgIGlmICh0aGlzLl9jb25maWcuZm9jdXMpIHtcbiAgICAgIHRoaXMuX2VuZm9yY2VGb2N1cygpXG4gICAgfVxuXG4gICAgY29uc3Qgc2hvd25FdmVudCA9ICQuRXZlbnQoRXZlbnQuU0hPV04sIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXRcbiAgICB9KVxuXG4gICAgY29uc3QgdHJhbnNpdGlvbkNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5mb2N1cykge1xuICAgICAgICB0aGlzLl9lbGVtZW50LmZvY3VzKClcbiAgICAgIH1cbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc2hvd25FdmVudClcbiAgICB9XG5cbiAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9uICA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fZGlhbG9nKVxuXG4gICAgICAkKHRoaXMuX2RpYWxvZylcbiAgICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCB0cmFuc2l0aW9uQ29tcGxldGUpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zaXRpb25Db21wbGV0ZSgpXG4gICAgfVxuICB9XG5cbiAgX2VuZm9yY2VGb2N1cygpIHtcbiAgICAkKGRvY3VtZW50KVxuICAgICAgLm9mZihFdmVudC5GT0NVU0lOKSAvLyBHdWFyZCBhZ2FpbnN0IGluZmluaXRlIGZvY3VzIGxvb3BcbiAgICAgIC5vbihFdmVudC5GT0NVU0lOLCAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGRvY3VtZW50ICE9PSBldmVudC50YXJnZXQgJiZcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQgIT09IGV2ZW50LnRhcmdldCAmJlxuICAgICAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5oYXMoZXZlbnQudGFyZ2V0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9lbGVtZW50LmZvY3VzKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgfVxuXG4gIF9zZXRFc2NhcGVFdmVudCgpIHtcbiAgICBpZiAodGhpcy5faXNTaG93biAmJiB0aGlzLl9jb25maWcua2V5Ym9hcmQpIHtcbiAgICAgICQodGhpcy5fZWxlbWVudCkub24oRXZlbnQuS0VZRE9XTl9ESVNNSVNTLCAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LndoaWNoID09PSBFU0NBUEVfS0VZQ09ERSkge1xuICAgICAgICAgIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzU2hvd24pIHtcbiAgICAgICQodGhpcy5fZWxlbWVudCkub2ZmKEV2ZW50LktFWURPV05fRElTTUlTUylcbiAgICB9XG4gIH1cblxuICBfc2V0UmVzaXplRXZlbnQoKSB7XG4gICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcbiAgICAgICQod2luZG93KS5vbihFdmVudC5SRVNJWkUsIChldmVudCkgPT4gdGhpcy5oYW5kbGVVcGRhdGUoZXZlbnQpKVxuICAgIH0gZWxzZSB7XG4gICAgICAkKHdpbmRvdykub2ZmKEV2ZW50LlJFU0laRSlcbiAgICB9XG4gIH1cblxuICBfaGlkZU1vZGFsKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpXG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnKVxuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlXG4gICAgdGhpcy5fc2hvd0JhY2tkcm9wKCgpID0+IHtcbiAgICAgICQoZG9jdW1lbnQuYm9keSkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLk9QRU4pXG4gICAgICB0aGlzLl9yZXNldEFkanVzdG1lbnRzKClcbiAgICAgIHRoaXMuX3Jlc2V0U2Nyb2xsYmFyKClcbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihFdmVudC5ISURERU4pXG4gICAgfSlcbiAgfVxuXG4gIF9yZW1vdmVCYWNrZHJvcCgpIHtcbiAgICBpZiAodGhpcy5fYmFja2Ryb3ApIHtcbiAgICAgICQodGhpcy5fYmFja2Ryb3ApLnJlbW92ZSgpXG4gICAgICB0aGlzLl9iYWNrZHJvcCA9IG51bGxcbiAgICB9XG4gIH1cblxuICBfc2hvd0JhY2tkcm9wKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgYW5pbWF0ZSA9ICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpXG4gICAgICA/IENsYXNzTmFtZS5GQURFIDogJydcblxuICAgIGlmICh0aGlzLl9pc1Nob3duICYmIHRoaXMuX2NvbmZpZy5iYWNrZHJvcCkge1xuICAgICAgdGhpcy5fYmFja2Ryb3AgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgdGhpcy5fYmFja2Ryb3AuY2xhc3NOYW1lID0gQ2xhc3NOYW1lLkJBQ0tEUk9QXG5cbiAgICAgIGlmIChhbmltYXRlKSB7XG4gICAgICAgIHRoaXMuX2JhY2tkcm9wLmNsYXNzTGlzdC5hZGQoYW5pbWF0ZSlcbiAgICAgIH1cblxuICAgICAgJCh0aGlzLl9iYWNrZHJvcCkuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSlcblxuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFdmVudC5DTElDS19ESVNNSVNTLCAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2spIHtcbiAgICAgICAgICB0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gZmFsc2VcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSBldmVudC5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKClcbiAgICAgIH0pXG5cbiAgICAgIGlmIChhbmltYXRlKSB7XG4gICAgICAgIFV0aWwucmVmbG93KHRoaXMuX2JhY2tkcm9wKVxuICAgICAgfVxuXG4gICAgICAkKHRoaXMuX2JhY2tkcm9wKS5hZGRDbGFzcyhDbGFzc05hbWUuU0hPVylcblxuICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKCFhbmltYXRlKSB7XG4gICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJhY2tkcm9wVHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9iYWNrZHJvcClcblxuICAgICAgJCh0aGlzLl9iYWNrZHJvcClcbiAgICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjYWxsYmFjaylcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGJhY2tkcm9wVHJhbnNpdGlvbkR1cmF0aW9uKVxuICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzU2hvd24gJiYgdGhpcy5fYmFja2Ryb3ApIHtcbiAgICAgICQodGhpcy5fYmFja2Ryb3ApLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5TSE9XKVxuXG4gICAgICBjb25zdCBjYWxsYmFja1JlbW92ZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlQmFja2Ryb3AoKVxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpKSB7XG4gICAgICAgIGNvbnN0IGJhY2tkcm9wVHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9iYWNrZHJvcClcblxuICAgICAgICAkKHRoaXMuX2JhY2tkcm9wKVxuICAgICAgICAgIC5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY2FsbGJhY2tSZW1vdmUpXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGJhY2tkcm9wVHJhbnNpdGlvbkR1cmF0aW9uKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2tSZW1vdmUoKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHRoZSBmb2xsb3dpbmcgbWV0aG9kcyBhcmUgdXNlZCB0byBoYW5kbGUgb3ZlcmZsb3dpbmcgbW9kYWxzXG4gIC8vIHRvZG8gKGZhdCk6IHRoZXNlIHNob3VsZCBwcm9iYWJseSBiZSByZWZhY3RvcmVkIG91dCBvZiBtb2RhbC5qc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgX2FkanVzdERpYWxvZygpIHtcbiAgICBjb25zdCBpc01vZGFsT3ZlcmZsb3dpbmcgPVxuICAgICAgdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XG5cbiAgICBpZiAoIXRoaXMuX2lzQm9keU92ZXJmbG93aW5nICYmIGlzTW9kYWxPdmVyZmxvd2luZykge1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9IGAke3RoaXMuX3Njcm9sbGJhcldpZHRofXB4YFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9pc0JvZHlPdmVyZmxvd2luZyAmJiAhaXNNb2RhbE92ZXJmbG93aW5nKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IGAke3RoaXMuX3Njcm9sbGJhcldpZHRofXB4YFxuICAgIH1cbiAgfVxuXG4gIF9yZXNldEFkanVzdG1lbnRzKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQgPSAnJ1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gJydcbiAgfVxuXG4gIF9jaGVja1Njcm9sbGJhcigpIHtcbiAgICBjb25zdCByZWN0ID0gZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIHRoaXMuX2lzQm9keU92ZXJmbG93aW5nID0gcmVjdC5sZWZ0ICsgcmVjdC5yaWdodCA8IHdpbmRvdy5pbm5lcldpZHRoXG4gICAgdGhpcy5fc2Nyb2xsYmFyV2lkdGggPSB0aGlzLl9nZXRTY3JvbGxiYXJXaWR0aCgpXG4gIH1cblxuICBfc2V0U2Nyb2xsYmFyKCkge1xuICAgIGlmICh0aGlzLl9pc0JvZHlPdmVyZmxvd2luZykge1xuICAgICAgLy8gTm90ZTogRE9NTm9kZS5zdHlsZS5wYWRkaW5nUmlnaHQgcmV0dXJucyB0aGUgYWN0dWFsIHZhbHVlIG9yICcnIGlmIG5vdCBzZXRcbiAgICAgIC8vICAgd2hpbGUgJChET01Ob2RlKS5jc3MoJ3BhZGRpbmctcmlnaHQnKSByZXR1cm5zIHRoZSBjYWxjdWxhdGVkIHZhbHVlIG9yIDAgaWYgbm90IHNldFxuICAgICAgY29uc3QgZml4ZWRDb250ZW50ID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNlbGVjdG9yLkZJWEVEX0NPTlRFTlQpKVxuICAgICAgY29uc3Qgc3RpY2t5Q29udGVudCA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChTZWxlY3Rvci5TVElDS1lfQ09OVEVOVCkpXG5cbiAgICAgIC8vIEFkanVzdCBmaXhlZCBjb250ZW50IHBhZGRpbmdcbiAgICAgICQoZml4ZWRDb250ZW50KS5lYWNoKChpbmRleCwgZWxlbWVudCkgPT4ge1xuICAgICAgICBjb25zdCBhY3R1YWxQYWRkaW5nID0gZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHRcbiAgICAgICAgY29uc3QgY2FsY3VsYXRlZFBhZGRpbmcgPSAkKGVsZW1lbnQpLmNzcygncGFkZGluZy1yaWdodCcpXG4gICAgICAgICQoZWxlbWVudClcbiAgICAgICAgICAuZGF0YSgncGFkZGluZy1yaWdodCcsIGFjdHVhbFBhZGRpbmcpXG4gICAgICAgICAgLmNzcygncGFkZGluZy1yaWdodCcsIGAke3BhcnNlRmxvYXQoY2FsY3VsYXRlZFBhZGRpbmcpICsgdGhpcy5fc2Nyb2xsYmFyV2lkdGh9cHhgKVxuICAgICAgfSlcblxuICAgICAgLy8gQWRqdXN0IHN0aWNreSBjb250ZW50IG1hcmdpblxuICAgICAgJChzdGlja3lDb250ZW50KS5lYWNoKChpbmRleCwgZWxlbWVudCkgPT4ge1xuICAgICAgICBjb25zdCBhY3R1YWxNYXJnaW4gPSBlbGVtZW50LnN0eWxlLm1hcmdpblJpZ2h0XG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRNYXJnaW4gPSAkKGVsZW1lbnQpLmNzcygnbWFyZ2luLXJpZ2h0JylcbiAgICAgICAgJChlbGVtZW50KVxuICAgICAgICAgIC5kYXRhKCdtYXJnaW4tcmlnaHQnLCBhY3R1YWxNYXJnaW4pXG4gICAgICAgICAgLmNzcygnbWFyZ2luLXJpZ2h0JywgYCR7cGFyc2VGbG9hdChjYWxjdWxhdGVkTWFyZ2luKSAtIHRoaXMuX3Njcm9sbGJhcldpZHRofXB4YClcbiAgICAgIH0pXG5cbiAgICAgIC8vIEFkanVzdCBib2R5IHBhZGRpbmdcbiAgICAgIGNvbnN0IGFjdHVhbFBhZGRpbmcgPSBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodFxuICAgICAgY29uc3QgY2FsY3VsYXRlZFBhZGRpbmcgPSAkKGRvY3VtZW50LmJvZHkpLmNzcygncGFkZGluZy1yaWdodCcpXG4gICAgICAkKGRvY3VtZW50LmJvZHkpXG4gICAgICAgIC5kYXRhKCdwYWRkaW5nLXJpZ2h0JywgYWN0dWFsUGFkZGluZylcbiAgICAgICAgLmNzcygncGFkZGluZy1yaWdodCcsIGAke3BhcnNlRmxvYXQoY2FsY3VsYXRlZFBhZGRpbmcpICsgdGhpcy5fc2Nyb2xsYmFyV2lkdGh9cHhgKVxuICAgIH1cblxuICAgICQoZG9jdW1lbnQuYm9keSkuYWRkQ2xhc3MoQ2xhc3NOYW1lLk9QRU4pXG4gIH1cblxuICBfcmVzZXRTY3JvbGxiYXIoKSB7XG4gICAgLy8gUmVzdG9yZSBmaXhlZCBjb250ZW50IHBhZGRpbmdcbiAgICBjb25zdCBmaXhlZENvbnRlbnQgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU2VsZWN0b3IuRklYRURfQ09OVEVOVCkpXG4gICAgJChmaXhlZENvbnRlbnQpLmVhY2goKGluZGV4LCBlbGVtZW50KSA9PiB7XG4gICAgICBjb25zdCBwYWRkaW5nID0gJChlbGVtZW50KS5kYXRhKCdwYWRkaW5nLXJpZ2h0JylcbiAgICAgICQoZWxlbWVudCkucmVtb3ZlRGF0YSgncGFkZGluZy1yaWdodCcpXG4gICAgICBlbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IHBhZGRpbmcgPyBwYWRkaW5nIDogJydcbiAgICB9KVxuXG4gICAgLy8gUmVzdG9yZSBzdGlja3kgY29udGVudFxuICAgIGNvbnN0IGVsZW1lbnRzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGAke1NlbGVjdG9yLlNUSUNLWV9DT05URU5UfWApKVxuICAgICQoZWxlbWVudHMpLmVhY2goKGluZGV4LCBlbGVtZW50KSA9PiB7XG4gICAgICBjb25zdCBtYXJnaW4gPSAkKGVsZW1lbnQpLmRhdGEoJ21hcmdpbi1yaWdodCcpXG4gICAgICBpZiAodHlwZW9mIG1hcmdpbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgJChlbGVtZW50KS5jc3MoJ21hcmdpbi1yaWdodCcsIG1hcmdpbikucmVtb3ZlRGF0YSgnbWFyZ2luLXJpZ2h0JylcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gUmVzdG9yZSBib2R5IHBhZGRpbmdcbiAgICBjb25zdCBwYWRkaW5nID0gJChkb2N1bWVudC5ib2R5KS5kYXRhKCdwYWRkaW5nLXJpZ2h0JylcbiAgICAkKGRvY3VtZW50LmJvZHkpLnJlbW92ZURhdGEoJ3BhZGRpbmctcmlnaHQnKVxuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0ID0gcGFkZGluZyA/IHBhZGRpbmcgOiAnJ1xuICB9XG5cbiAgX2dldFNjcm9sbGJhcldpZHRoKCkgeyAvLyB0aHggZC53YWxzaFxuICAgIGNvbnN0IHNjcm9sbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgc2Nyb2xsRGl2LmNsYXNzTmFtZSA9IENsYXNzTmFtZS5TQ1JPTExCQVJfTUVBU1VSRVJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcm9sbERpdilcbiAgICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHNjcm9sbERpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIHNjcm9sbERpdi5jbGllbnRXaWR0aFxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc2Nyb2xsRGl2KVxuICAgIHJldHVybiBzY3JvbGxiYXJXaWR0aFxuICB9XG5cbiAgLy8gU3RhdGljXG5cbiAgc3RhdGljIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnLCByZWxhdGVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgZGF0YSA9ICQodGhpcykuZGF0YShEQVRBX0tFWSlcbiAgICAgIGNvbnN0IF9jb25maWcgPSB7XG4gICAgICAgIC4uLkRlZmF1bHQsXG4gICAgICAgIC4uLiQodGhpcykuZGF0YSgpLFxuICAgICAgICAuLi50eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWcgPyBjb25maWcgOiB7fVxuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBNb2RhbCh0aGlzLCBfY29uZmlnKVxuICAgICAgICAkKHRoaXMpLmRhdGEoREFUQV9LRVksIGRhdGEpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApXG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtjb25maWddKHJlbGF0ZWRUYXJnZXQpXG4gICAgICB9IGVsc2UgaWYgKF9jb25maWcuc2hvdykge1xuICAgICAgICBkYXRhLnNob3cocmVsYXRlZFRhcmdldClcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuJChkb2N1bWVudCkub24oRXZlbnQuQ0xJQ0tfREFUQV9BUEksIFNlbGVjdG9yLkRBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgbGV0IHRhcmdldFxuICBjb25zdCBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0aGlzKVxuXG4gIGlmIChzZWxlY3Rvcikge1xuICAgIHRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpXG4gIH1cblxuICBjb25zdCBjb25maWcgPSAkKHRhcmdldCkuZGF0YShEQVRBX0tFWSlcbiAgICA/ICd0b2dnbGUnIDoge1xuICAgICAgLi4uJCh0YXJnZXQpLmRhdGEoKSxcbiAgICAgIC4uLiQodGhpcykuZGF0YSgpXG4gICAgfVxuXG4gIGlmICh0aGlzLnRhZ05hbWUgPT09ICdBJyB8fCB0aGlzLnRhZ05hbWUgPT09ICdBUkVBJykge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgfVxuXG4gIGNvbnN0ICR0YXJnZXQgPSAkKHRhcmdldCkub25lKEV2ZW50LlNIT1csIChzaG93RXZlbnQpID0+IHtcbiAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAvLyBPbmx5IHJlZ2lzdGVyIGZvY3VzIHJlc3RvcmVyIGlmIG1vZGFsIHdpbGwgYWN0dWFsbHkgZ2V0IHNob3duXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAkdGFyZ2V0Lm9uZShFdmVudC5ISURERU4sICgpID0+IHtcbiAgICAgIGlmICgkKHRoaXMpLmlzKCc6dmlzaWJsZScpKSB7XG4gICAgICAgIHRoaXMuZm9jdXMoKVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG5cbiAgTW9kYWwuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQodGFyZ2V0KSwgY29uZmlnLCB0aGlzKVxufSlcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGpRdWVyeVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuJC5mbltOQU1FXSA9IE1vZGFsLl9qUXVlcnlJbnRlcmZhY2VcbiQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBNb2RhbFxuJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gKCkgPT4ge1xuICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUXG4gIHJldHVybiBNb2RhbC5falF1ZXJ5SW50ZXJmYWNlXG59XG5cbmV4cG9ydCBkZWZhdWx0IE1vZGFsXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjQuMSk6IHRvb2xzL3Nhbml0aXplci5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgdXJpQXR0cnMgPSBbXG4gICdiYWNrZ3JvdW5kJyxcbiAgJ2NpdGUnLFxuICAnaHJlZicsXG4gICdpdGVtdHlwZScsXG4gICdsb25nZGVzYycsXG4gICdwb3N0ZXInLFxuICAnc3JjJyxcbiAgJ3hsaW5rOmhyZWYnXG5dXG5cbmNvbnN0IEFSSUFfQVRUUklCVVRFX1BBVFRFUk4gPSAvXmFyaWEtW1xcdy1dKiQvaVxuXG5leHBvcnQgY29uc3QgRGVmYXVsdFdoaXRlbGlzdCA9IHtcbiAgLy8gR2xvYmFsIGF0dHJpYnV0ZXMgYWxsb3dlZCBvbiBhbnkgc3VwcGxpZWQgZWxlbWVudCBiZWxvdy5cbiAgJyonOiBbJ2NsYXNzJywgJ2RpcicsICdpZCcsICdsYW5nJywgJ3JvbGUnLCBBUklBX0FUVFJJQlVURV9QQVRURVJOXSxcbiAgYTogWyd0YXJnZXQnLCAnaHJlZicsICd0aXRsZScsICdyZWwnXSxcbiAgYXJlYTogW10sXG4gIGI6IFtdLFxuICBicjogW10sXG4gIGNvbDogW10sXG4gIGNvZGU6IFtdLFxuICBkaXY6IFtdLFxuICBlbTogW10sXG4gIGhyOiBbXSxcbiAgaDE6IFtdLFxuICBoMjogW10sXG4gIGgzOiBbXSxcbiAgaDQ6IFtdLFxuICBoNTogW10sXG4gIGg2OiBbXSxcbiAgaTogW10sXG4gIGltZzogWydzcmMnLCAnYWx0JywgJ3RpdGxlJywgJ3dpZHRoJywgJ2hlaWdodCddLFxuICBsaTogW10sXG4gIG9sOiBbXSxcbiAgcDogW10sXG4gIHByZTogW10sXG4gIHM6IFtdLFxuICBzbWFsbDogW10sXG4gIHNwYW46IFtdLFxuICBzdWI6IFtdLFxuICBzdXA6IFtdLFxuICBzdHJvbmc6IFtdLFxuICB1OiBbXSxcbiAgdWw6IFtdXG59XG5cbi8qKlxuICogQSBwYXR0ZXJuIHRoYXQgcmVjb2duaXplcyBhIGNvbW1vbmx5IHVzZWZ1bCBzdWJzZXQgb2YgVVJMcyB0aGF0IGFyZSBzYWZlLlxuICpcbiAqIFNob3V0b3V0IHRvIEFuZ3VsYXIgNyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvNy4yLjQvcGFja2FnZXMvY29yZS9zcmMvc2FuaXRpemF0aW9uL3VybF9zYW5pdGl6ZXIudHNcbiAqL1xuY29uc3QgU0FGRV9VUkxfUEFUVEVSTiA9IC9eKD86KD86aHR0cHM/fG1haWx0b3xmdHB8dGVsfGZpbGUpOnxbXiY6Lz8jXSooPzpbLz8jXXwkKSkvZ2lcblxuLyoqXG4gKiBBIHBhdHRlcm4gdGhhdCBtYXRjaGVzIHNhZmUgZGF0YSBVUkxzLiBPbmx5IG1hdGNoZXMgaW1hZ2UsIHZpZGVvIGFuZCBhdWRpbyB0eXBlcy5cbiAqXG4gKiBTaG91dG91dCB0byBBbmd1bGFyIDcgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iLzcuMi40L3BhY2thZ2VzL2NvcmUvc3JjL3Nhbml0aXphdGlvbi91cmxfc2FuaXRpemVyLnRzXG4gKi9cbmNvbnN0IERBVEFfVVJMX1BBVFRFUk4gPSAvXmRhdGE6KD86aW1hZ2VcXC8oPzpibXB8Z2lmfGpwZWd8anBnfHBuZ3x0aWZmfHdlYnApfHZpZGVvXFwvKD86bXBlZ3xtcDR8b2dnfHdlYm0pfGF1ZGlvXFwvKD86bXAzfG9nYXxvZ2d8b3B1cykpO2Jhc2U2NCxbYS16MC05Ky9dKz0qJC9pXG5cbmZ1bmN0aW9uIGFsbG93ZWRBdHRyaWJ1dGUoYXR0ciwgYWxsb3dlZEF0dHJpYnV0ZUxpc3QpIHtcbiAgY29uc3QgYXR0ck5hbWUgPSBhdHRyLm5vZGVOYW1lLnRvTG93ZXJDYXNlKClcblxuICBpZiAoYWxsb3dlZEF0dHJpYnV0ZUxpc3QuaW5kZXhPZihhdHRyTmFtZSkgIT09IC0xKSB7XG4gICAgaWYgKHVyaUF0dHJzLmluZGV4T2YoYXR0ck5hbWUpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4oYXR0ci5ub2RlVmFsdWUubWF0Y2goU0FGRV9VUkxfUEFUVEVSTikgfHwgYXR0ci5ub2RlVmFsdWUubWF0Y2goREFUQV9VUkxfUEFUVEVSTikpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGNvbnN0IHJlZ0V4cCA9IGFsbG93ZWRBdHRyaWJ1dGVMaXN0LmZpbHRlcigoYXR0clJlZ2V4KSA9PiBhdHRyUmVnZXggaW5zdGFuY2VvZiBSZWdFeHApXG5cbiAgLy8gQ2hlY2sgaWYgYSByZWd1bGFyIGV4cHJlc3Npb24gdmFsaWRhdGVzIHRoZSBhdHRyaWJ1dGUuXG4gIGZvciAobGV0IGkgPSAwLCBsID0gcmVnRXhwLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChhdHRyTmFtZS5tYXRjaChyZWdFeHBbaV0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVIdG1sKHVuc2FmZUh0bWwsIHdoaXRlTGlzdCwgc2FuaXRpemVGbikge1xuICBpZiAodW5zYWZlSHRtbC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdW5zYWZlSHRtbFxuICB9XG5cbiAgaWYgKHNhbml0aXplRm4gJiYgdHlwZW9mIHNhbml0aXplRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gc2FuaXRpemVGbih1bnNhZmVIdG1sKVxuICB9XG5cbiAgY29uc3QgZG9tUGFyc2VyID0gbmV3IHdpbmRvdy5ET01QYXJzZXIoKVxuICBjb25zdCBjcmVhdGVkRG9jdW1lbnQgPSBkb21QYXJzZXIucGFyc2VGcm9tU3RyaW5nKHVuc2FmZUh0bWwsICd0ZXh0L2h0bWwnKVxuICBjb25zdCB3aGl0ZWxpc3RLZXlzID0gT2JqZWN0LmtleXMod2hpdGVMaXN0KVxuICBjb25zdCBlbGVtZW50cyA9IFtdLnNsaWNlLmNhbGwoY3JlYXRlZERvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvckFsbCgnKicpKVxuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGVsID0gZWxlbWVudHNbaV1cbiAgICBjb25zdCBlbE5hbWUgPSBlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgICBpZiAod2hpdGVsaXN0S2V5cy5pbmRleE9mKGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpID09PSAtMSkge1xuICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbClcblxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBjb25zdCBhdHRyaWJ1dGVMaXN0ID0gW10uc2xpY2UuY2FsbChlbC5hdHRyaWJ1dGVzKVxuICAgIGNvbnN0IHdoaXRlbGlzdGVkQXR0cmlidXRlcyA9IFtdLmNvbmNhdCh3aGl0ZUxpc3RbJyonXSB8fCBbXSwgd2hpdGVMaXN0W2VsTmFtZV0gfHwgW10pXG5cbiAgICBhdHRyaWJ1dGVMaXN0LmZvckVhY2goKGF0dHIpID0+IHtcbiAgICAgIGlmICghYWxsb3dlZEF0dHJpYnV0ZShhdHRyLCB3aGl0ZWxpc3RlZEF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyLm5vZGVOYW1lKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gY3JlYXRlZERvY3VtZW50LmJvZHkuaW5uZXJIVE1MXG59XG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjQuMSk6IHRvb2x0aXAuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCB7XG4gIERlZmF1bHRXaGl0ZWxpc3QsXG4gIHNhbml0aXplSHRtbFxufSBmcm9tICcuL3Rvb2xzL3Nhbml0aXplcidcbmltcG9ydCAkIGZyb20gJ2pxdWVyeSdcbmltcG9ydCBQb3BwZXIgZnJvbSAncG9wcGVyLmpzJ1xuaW1wb3J0IFV0aWwgZnJvbSAnLi91dGlsJ1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FICAgICAgICAgICAgICAgICAgPSAndG9vbHRpcCdcbmNvbnN0IFZFUlNJT04gICAgICAgICAgICAgICA9ICc0LjQuMSdcbmNvbnN0IERBVEFfS0VZICAgICAgICAgICAgICA9ICdicy50b29sdGlwJ1xuY29uc3QgRVZFTlRfS0VZICAgICAgICAgICAgID0gYC4ke0RBVEFfS0VZfWBcbmNvbnN0IEpRVUVSWV9OT19DT05GTElDVCAgICA9ICQuZm5bTkFNRV1cbmNvbnN0IENMQVNTX1BSRUZJWCAgICAgICAgICA9ICdicy10b29sdGlwJ1xuY29uc3QgQlNDTFNfUFJFRklYX1JFR0VYICAgID0gbmV3IFJlZ0V4cChgKF58XFxcXHMpJHtDTEFTU19QUkVGSVh9XFxcXFMrYCwgJ2cnKVxuY29uc3QgRElTQUxMT1dFRF9BVFRSSUJVVEVTID0gWydzYW5pdGl6ZScsICd3aGl0ZUxpc3QnLCAnc2FuaXRpemVGbiddXG5cbmNvbnN0IERlZmF1bHRUeXBlID0ge1xuICBhbmltYXRpb24gICAgICAgICA6ICdib29sZWFuJyxcbiAgdGVtcGxhdGUgICAgICAgICAgOiAnc3RyaW5nJyxcbiAgdGl0bGUgICAgICAgICAgICAgOiAnKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKScsXG4gIHRyaWdnZXIgICAgICAgICAgIDogJ3N0cmluZycsXG4gIGRlbGF5ICAgICAgICAgICAgIDogJyhudW1iZXJ8b2JqZWN0KScsXG4gIGh0bWwgICAgICAgICAgICAgIDogJ2Jvb2xlYW4nLFxuICBzZWxlY3RvciAgICAgICAgICA6ICcoc3RyaW5nfGJvb2xlYW4pJyxcbiAgcGxhY2VtZW50ICAgICAgICAgOiAnKHN0cmluZ3xmdW5jdGlvbiknLFxuICBvZmZzZXQgICAgICAgICAgICA6ICcobnVtYmVyfHN0cmluZ3xmdW5jdGlvbiknLFxuICBjb250YWluZXIgICAgICAgICA6ICcoc3RyaW5nfGVsZW1lbnR8Ym9vbGVhbiknLFxuICBmYWxsYmFja1BsYWNlbWVudCA6ICcoc3RyaW5nfGFycmF5KScsXG4gIGJvdW5kYXJ5ICAgICAgICAgIDogJyhzdHJpbmd8ZWxlbWVudCknLFxuICBzYW5pdGl6ZSAgICAgICAgICA6ICdib29sZWFuJyxcbiAgc2FuaXRpemVGbiAgICAgICAgOiAnKG51bGx8ZnVuY3Rpb24pJyxcbiAgd2hpdGVMaXN0ICAgICAgICAgOiAnb2JqZWN0JyxcbiAgcG9wcGVyQ29uZmlnICAgICAgOiAnKG51bGx8b2JqZWN0KSdcbn1cblxuY29uc3QgQXR0YWNobWVudE1hcCA9IHtcbiAgQVVUTyAgIDogJ2F1dG8nLFxuICBUT1AgICAgOiAndG9wJyxcbiAgUklHSFQgIDogJ3JpZ2h0JyxcbiAgQk9UVE9NIDogJ2JvdHRvbScsXG4gIExFRlQgICA6ICdsZWZ0J1xufVxuXG5jb25zdCBEZWZhdWx0ID0ge1xuICBhbmltYXRpb24gICAgICAgICA6IHRydWUsXG4gIHRlbXBsYXRlICAgICAgICAgIDogJzxkaXYgY2xhc3M9XCJ0b29sdGlwXCIgcm9sZT1cInRvb2x0aXBcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJhcnJvd1wiPjwvZGl2PicgK1xuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj48L2Rpdj4nLFxuICB0cmlnZ2VyICAgICAgICAgICA6ICdob3ZlciBmb2N1cycsXG4gIHRpdGxlICAgICAgICAgICAgIDogJycsXG4gIGRlbGF5ICAgICAgICAgICAgIDogMCxcbiAgaHRtbCAgICAgICAgICAgICAgOiBmYWxzZSxcbiAgc2VsZWN0b3IgICAgICAgICAgOiBmYWxzZSxcbiAgcGxhY2VtZW50ICAgICAgICAgOiAndG9wJyxcbiAgb2Zmc2V0ICAgICAgICAgICAgOiAwLFxuICBjb250YWluZXIgICAgICAgICA6IGZhbHNlLFxuICBmYWxsYmFja1BsYWNlbWVudCA6ICdmbGlwJyxcbiAgYm91bmRhcnkgICAgICAgICAgOiAnc2Nyb2xsUGFyZW50JyxcbiAgc2FuaXRpemUgICAgICAgICAgOiB0cnVlLFxuICBzYW5pdGl6ZUZuICAgICAgICA6IG51bGwsXG4gIHdoaXRlTGlzdCAgICAgICAgIDogRGVmYXVsdFdoaXRlbGlzdCxcbiAgcG9wcGVyQ29uZmlnICAgICAgOiBudWxsXG59XG5cbmNvbnN0IEhvdmVyU3RhdGUgPSB7XG4gIFNIT1cgOiAnc2hvdycsXG4gIE9VVCAgOiAnb3V0J1xufVxuXG5jb25zdCBFdmVudCA9IHtcbiAgSElERSAgICAgICA6IGBoaWRlJHtFVkVOVF9LRVl9YCxcbiAgSElEREVOICAgICA6IGBoaWRkZW4ke0VWRU5UX0tFWX1gLFxuICBTSE9XICAgICAgIDogYHNob3cke0VWRU5UX0tFWX1gLFxuICBTSE9XTiAgICAgIDogYHNob3duJHtFVkVOVF9LRVl9YCxcbiAgSU5TRVJURUQgICA6IGBpbnNlcnRlZCR7RVZFTlRfS0VZfWAsXG4gIENMSUNLICAgICAgOiBgY2xpY2ske0VWRU5UX0tFWX1gLFxuICBGT0NVU0lOICAgIDogYGZvY3VzaW4ke0VWRU5UX0tFWX1gLFxuICBGT0NVU09VVCAgIDogYGZvY3Vzb3V0JHtFVkVOVF9LRVl9YCxcbiAgTU9VU0VFTlRFUiA6IGBtb3VzZWVudGVyJHtFVkVOVF9LRVl9YCxcbiAgTU9VU0VMRUFWRSA6IGBtb3VzZWxlYXZlJHtFVkVOVF9LRVl9YFxufVxuXG5jb25zdCBDbGFzc05hbWUgPSB7XG4gIEZBREUgOiAnZmFkZScsXG4gIFNIT1cgOiAnc2hvdydcbn1cblxuY29uc3QgU2VsZWN0b3IgPSB7XG4gIFRPT0xUSVAgICAgICAgOiAnLnRvb2x0aXAnLFxuICBUT09MVElQX0lOTkVSIDogJy50b29sdGlwLWlubmVyJyxcbiAgQVJST1cgICAgICAgICA6ICcuYXJyb3cnXG59XG5cbmNvbnN0IFRyaWdnZXIgPSB7XG4gIEhPVkVSICA6ICdob3ZlcicsXG4gIEZPQ1VTICA6ICdmb2N1cycsXG4gIENMSUNLICA6ICdjbGljaycsXG4gIE1BTlVBTCA6ICdtYW51YWwnXG59XG5cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENsYXNzIERlZmluaXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNsYXNzIFRvb2x0aXAge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICBpZiAodHlwZW9mIFBvcHBlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Jvb3RzdHJhcFxcJ3MgdG9vbHRpcHMgcmVxdWlyZSBQb3BwZXIuanMgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZy8pJylcbiAgICB9XG5cbiAgICAvLyBwcml2YXRlXG4gICAgdGhpcy5faXNFbmFibGVkICAgICA9IHRydWVcbiAgICB0aGlzLl90aW1lb3V0ICAgICAgID0gMFxuICAgIHRoaXMuX2hvdmVyU3RhdGUgICAgPSAnJ1xuICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXIgPSB7fVxuICAgIHRoaXMuX3BvcHBlciAgICAgICAgPSBudWxsXG5cbiAgICAvLyBQcm90ZWN0ZWRcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50XG4gICAgdGhpcy5jb25maWcgID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZylcbiAgICB0aGlzLnRpcCAgICAgPSBudWxsXG5cbiAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoKVxuICB9XG5cbiAgLy8gR2V0dGVyc1xuXG4gIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICByZXR1cm4gVkVSU0lPTlxuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0XG4gIH1cblxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUVcbiAgfVxuXG4gIHN0YXRpYyBnZXQgREFUQV9LRVkoKSB7XG4gICAgcmV0dXJuIERBVEFfS0VZXG4gIH1cblxuICBzdGF0aWMgZ2V0IEV2ZW50KCkge1xuICAgIHJldHVybiBFdmVudFxuICB9XG5cbiAgc3RhdGljIGdldCBFVkVOVF9LRVkoKSB7XG4gICAgcmV0dXJuIEVWRU5UX0tFWVxuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGVcbiAgfVxuXG4gIC8vIFB1YmxpY1xuXG4gIGVuYWJsZSgpIHtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlXG4gIH1cblxuICBkaXNhYmxlKCkge1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlXG4gIH1cblxuICB0b2dnbGVFbmFibGVkKCkge1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9ICF0aGlzLl9pc0VuYWJsZWRcbiAgfVxuXG4gIHRvZ2dsZShldmVudCkge1xuICAgIGlmICghdGhpcy5faXNFbmFibGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgIGNvbnN0IGRhdGFLZXkgPSB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZXG4gICAgICBsZXQgY29udGV4dCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YShkYXRhS2V5KVxuXG4gICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKFxuICAgICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgdGhpcy5fZ2V0RGVsZWdhdGVDb25maWcoKVxuICAgICAgICApXG4gICAgICAgICQoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YShkYXRhS2V5LCBjb250ZXh0KVxuICAgICAgfVxuXG4gICAgICBjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyLmNsaWNrID0gIWNvbnRleHQuX2FjdGl2ZVRyaWdnZXIuY2xpY2tcblxuICAgICAgaWYgKGNvbnRleHQuX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSkge1xuICAgICAgICBjb250ZXh0Ll9lbnRlcihudWxsLCBjb250ZXh0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5fbGVhdmUobnVsbCwgY29udGV4dClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCQodGhpcy5nZXRUaXBFbGVtZW50KCkpLmhhc0NsYXNzKENsYXNzTmFtZS5TSE9XKSkge1xuICAgICAgICB0aGlzLl9sZWF2ZShudWxsLCB0aGlzKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdGhpcy5fZW50ZXIobnVsbCwgdGhpcylcbiAgICB9XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KVxuXG4gICAgJC5yZW1vdmVEYXRhKHRoaXMuZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSlcblxuICAgICQodGhpcy5lbGVtZW50KS5vZmYodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVF9LRVkpXG4gICAgJCh0aGlzLmVsZW1lbnQpLmNsb3Nlc3QoJy5tb2RhbCcpLm9mZignaGlkZS5icy5tb2RhbCcsIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIpXG5cbiAgICBpZiAodGhpcy50aXApIHtcbiAgICAgICQodGhpcy50aXApLnJlbW92ZSgpXG4gICAgfVxuXG4gICAgdGhpcy5faXNFbmFibGVkICAgICA9IG51bGxcbiAgICB0aGlzLl90aW1lb3V0ICAgICAgID0gbnVsbFxuICAgIHRoaXMuX2hvdmVyU3RhdGUgICAgPSBudWxsXG4gICAgdGhpcy5fYWN0aXZlVHJpZ2dlciA9IG51bGxcbiAgICBpZiAodGhpcy5fcG9wcGVyKSB7XG4gICAgICB0aGlzLl9wb3BwZXIuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgdGhpcy5fcG9wcGVyID0gbnVsbFxuICAgIHRoaXMuZWxlbWVudCA9IG51bGxcbiAgICB0aGlzLmNvbmZpZyAgPSBudWxsXG4gICAgdGhpcy50aXAgICAgID0gbnVsbFxuICB9XG5cbiAgc2hvdygpIHtcbiAgICBpZiAoJCh0aGlzLmVsZW1lbnQpLmNzcygnZGlzcGxheScpID09PSAnbm9uZScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHVzZSBzaG93IG9uIHZpc2libGUgZWxlbWVudHMnKVxuICAgIH1cblxuICAgIGNvbnN0IHNob3dFdmVudCA9ICQuRXZlbnQodGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XKVxuICAgIGlmICh0aGlzLmlzV2l0aENvbnRlbnQoKSAmJiB0aGlzLl9pc0VuYWJsZWQpIHtcbiAgICAgICQodGhpcy5lbGVtZW50KS50cmlnZ2VyKHNob3dFdmVudClcblxuICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IFV0aWwuZmluZFNoYWRvd1Jvb3QodGhpcy5lbGVtZW50KVxuICAgICAgY29uc3QgaXNJblRoZURvbSA9ICQuY29udGFpbnMoXG4gICAgICAgIHNoYWRvd1Jvb3QgIT09IG51bGwgPyBzaGFkb3dSb290IDogdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICB0aGlzLmVsZW1lbnRcbiAgICAgIClcblxuICAgICAgaWYgKHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCAhaXNJblRoZURvbSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY29uc3QgdGlwICAgPSB0aGlzLmdldFRpcEVsZW1lbnQoKVxuICAgICAgY29uc3QgdGlwSWQgPSBVdGlsLmdldFVJRCh0aGlzLmNvbnN0cnVjdG9yLk5BTUUpXG5cbiAgICAgIHRpcC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGlwSWQpXG4gICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JywgdGlwSWQpXG5cbiAgICAgIHRoaXMuc2V0Q29udGVudCgpXG5cbiAgICAgIGlmICh0aGlzLmNvbmZpZy5hbmltYXRpb24pIHtcbiAgICAgICAgJCh0aXApLmFkZENsYXNzKENsYXNzTmFtZS5GQURFKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwbGFjZW1lbnQgID0gdHlwZW9mIHRoaXMuY29uZmlnLnBsYWNlbWVudCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHRoaXMuY29uZmlnLnBsYWNlbWVudC5jYWxsKHRoaXMsIHRpcCwgdGhpcy5lbGVtZW50KVxuICAgICAgICA6IHRoaXMuY29uZmlnLnBsYWNlbWVudFxuXG4gICAgICBjb25zdCBhdHRhY2htZW50ID0gdGhpcy5fZ2V0QXR0YWNobWVudChwbGFjZW1lbnQpXG4gICAgICB0aGlzLmFkZEF0dGFjaG1lbnRDbGFzcyhhdHRhY2htZW50KVxuXG4gICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLl9nZXRDb250YWluZXIoKVxuICAgICAgJCh0aXApLmRhdGEodGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSwgdGhpcylcblxuICAgICAgaWYgKCEkLmNvbnRhaW5zKHRoaXMuZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgdGhpcy50aXApKSB7XG4gICAgICAgICQodGlwKS5hcHBlbmRUbyhjb250YWluZXIpXG4gICAgICB9XG5cbiAgICAgICQodGhpcy5lbGVtZW50KS50cmlnZ2VyKHRoaXMuY29uc3RydWN0b3IuRXZlbnQuSU5TRVJURUQpXG5cbiAgICAgIHRoaXMuX3BvcHBlciA9IG5ldyBQb3BwZXIodGhpcy5lbGVtZW50LCB0aXAsIHRoaXMuX2dldFBvcHBlckNvbmZpZyhhdHRhY2htZW50KSlcblxuICAgICAgJCh0aXApLmFkZENsYXNzKENsYXNzTmFtZS5TSE9XKVxuXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgYWRkIGV4dHJhXG4gICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHRvIHRoZSBib2R5J3MgaW1tZWRpYXRlIGNoaWxkcmVuO1xuICAgICAgLy8gb25seSBuZWVkZWQgYmVjYXVzZSBvZiBicm9rZW4gZXZlbnQgZGVsZWdhdGlvbiBvbiBpT1NcbiAgICAgIC8vIGh0dHBzOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxNC8wMi9tb3VzZV9ldmVudF9idWIuaHRtbFxuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAkKGRvY3VtZW50LmJvZHkpLmNoaWxkcmVuKCkub24oJ21vdXNlb3ZlcicsIG51bGwsICQubm9vcClcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5hbmltYXRpb24pIHtcbiAgICAgICAgICB0aGlzLl9maXhUcmFuc2l0aW9uKClcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2SG92ZXJTdGF0ZSA9IHRoaXMuX2hvdmVyU3RhdGVcbiAgICAgICAgdGhpcy5faG92ZXJTdGF0ZSAgICAgPSBudWxsXG5cbiAgICAgICAgJCh0aGlzLmVsZW1lbnQpLnRyaWdnZXIodGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XTilcblxuICAgICAgICBpZiAocHJldkhvdmVyU3RhdGUgPT09IEhvdmVyU3RhdGUuT1VUKSB7XG4gICAgICAgICAgdGhpcy5fbGVhdmUobnVsbCwgdGhpcylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoJCh0aGlzLnRpcCkuaGFzQ2xhc3MoQ2xhc3NOYW1lLkZBREUpKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy50aXApXG5cbiAgICAgICAgJCh0aGlzLnRpcClcbiAgICAgICAgICAub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGNvbXBsZXRlKVxuICAgICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wbGV0ZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGlkZShjYWxsYmFjaykge1xuICAgIGNvbnN0IHRpcCAgICAgICA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpXG4gICAgY29uc3QgaGlkZUV2ZW50ID0gJC5FdmVudCh0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkhJREUpXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5faG92ZXJTdGF0ZSAhPT0gSG92ZXJTdGF0ZS5TSE9XICYmIHRpcC5wYXJlbnROb2RlKSB7XG4gICAgICAgIHRpcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRpcClcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2xlYW5UaXBDbGFzcygpXG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JylcbiAgICAgICQodGhpcy5lbGVtZW50KS50cmlnZ2VyKHRoaXMuY29uc3RydWN0b3IuRXZlbnQuSElEREVOKVxuICAgICAgaWYgKHRoaXMuX3BvcHBlciAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9wb3BwZXIuZGVzdHJveSgpXG4gICAgICB9XG5cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjaygpXG4gICAgICB9XG4gICAgfVxuXG4gICAgJCh0aGlzLmVsZW1lbnQpLnRyaWdnZXIoaGlkZUV2ZW50KVxuXG4gICAgaWYgKGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgJCh0aXApLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5TSE9XKVxuXG4gICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIHJlbW92ZSB0aGUgZXh0cmFcbiAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHdlIGFkZGVkIGZvciBpT1Mgc3VwcG9ydFxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICQoZG9jdW1lbnQuYm9keSkuY2hpbGRyZW4oKS5vZmYoJ21vdXNlb3ZlcicsIG51bGwsICQubm9vcClcbiAgICB9XG5cbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RyaWdnZXIuQ0xJQ0tdID0gZmFsc2VcbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RyaWdnZXIuRk9DVVNdID0gZmFsc2VcbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RyaWdnZXIuSE9WRVJdID0gZmFsc2VcblxuICAgIGlmICgkKHRoaXMudGlwKS5oYXNDbGFzcyhDbGFzc05hbWUuRkFERSkpIHtcbiAgICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGlwKVxuXG4gICAgICAkKHRpcClcbiAgICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSlcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcGxldGUoKVxuICAgIH1cblxuICAgIHRoaXMuX2hvdmVyU3RhdGUgPSAnJ1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIGlmICh0aGlzLl9wb3BwZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3BvcHBlci5zY2hlZHVsZVVwZGF0ZSgpXG4gICAgfVxuICB9XG5cbiAgLy8gUHJvdGVjdGVkXG5cbiAgaXNXaXRoQ29udGVudCgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLmdldFRpdGxlKCkpXG4gIH1cblxuICBhZGRBdHRhY2htZW50Q2xhc3MoYXR0YWNobWVudCkge1xuICAgICQodGhpcy5nZXRUaXBFbGVtZW50KCkpLmFkZENsYXNzKGAke0NMQVNTX1BSRUZJWH0tJHthdHRhY2htZW50fWApXG4gIH1cblxuICBnZXRUaXBFbGVtZW50KCkge1xuICAgIHRoaXMudGlwID0gdGhpcy50aXAgfHwgJCh0aGlzLmNvbmZpZy50ZW1wbGF0ZSlbMF1cbiAgICByZXR1cm4gdGhpcy50aXBcbiAgfVxuXG4gIHNldENvbnRlbnQoKSB7XG4gICAgY29uc3QgdGlwID0gdGhpcy5nZXRUaXBFbGVtZW50KClcbiAgICB0aGlzLnNldEVsZW1lbnRDb250ZW50KCQodGlwLnF1ZXJ5U2VsZWN0b3JBbGwoU2VsZWN0b3IuVE9PTFRJUF9JTk5FUikpLCB0aGlzLmdldFRpdGxlKCkpXG4gICAgJCh0aXApLnJlbW92ZUNsYXNzKGAke0NsYXNzTmFtZS5GQURFfSAke0NsYXNzTmFtZS5TSE9XfWApXG4gIH1cblxuICBzZXRFbGVtZW50Q29udGVudCgkZWxlbWVudCwgY29udGVudCkge1xuICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ29iamVjdCcgJiYgKGNvbnRlbnQubm9kZVR5cGUgfHwgY29udGVudC5qcXVlcnkpKSB7XG4gICAgICAvLyBDb250ZW50IGlzIGEgRE9NIG5vZGUgb3IgYSBqUXVlcnlcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5odG1sKSB7XG4gICAgICAgIGlmICghJChjb250ZW50KS5wYXJlbnQoKS5pcygkZWxlbWVudCkpIHtcbiAgICAgICAgICAkZWxlbWVudC5lbXB0eSgpLmFwcGVuZChjb250ZW50KVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkZWxlbWVudC50ZXh0KCQoY29udGVudCkudGV4dCgpKVxuICAgICAgfVxuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb25maWcuaHRtbCkge1xuICAgICAgaWYgKHRoaXMuY29uZmlnLnNhbml0aXplKSB7XG4gICAgICAgIGNvbnRlbnQgPSBzYW5pdGl6ZUh0bWwoY29udGVudCwgdGhpcy5jb25maWcud2hpdGVMaXN0LCB0aGlzLmNvbmZpZy5zYW5pdGl6ZUZuKVxuICAgICAgfVxuXG4gICAgICAkZWxlbWVudC5odG1sKGNvbnRlbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgICRlbGVtZW50LnRleHQoY29udGVudClcbiAgICB9XG4gIH1cblxuICBnZXRUaXRsZSgpIHtcbiAgICBsZXQgdGl0bGUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLXRpdGxlJylcblxuICAgIGlmICghdGl0bGUpIHtcbiAgICAgIHRpdGxlID0gdHlwZW9mIHRoaXMuY29uZmlnLnRpdGxlID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gdGhpcy5jb25maWcudGl0bGUuY2FsbCh0aGlzLmVsZW1lbnQpXG4gICAgICAgIDogdGhpcy5jb25maWcudGl0bGVcbiAgICB9XG5cbiAgICByZXR1cm4gdGl0bGVcbiAgfVxuXG4gIC8vIFByaXZhdGVcblxuICBfZ2V0UG9wcGVyQ29uZmlnKGF0dGFjaG1lbnQpIHtcbiAgICBjb25zdCBkZWZhdWx0QnNDb25maWcgPSB7XG4gICAgICBwbGFjZW1lbnQ6IGF0dGFjaG1lbnQsXG4gICAgICBtb2RpZmllcnM6IHtcbiAgICAgICAgb2Zmc2V0OiB0aGlzLl9nZXRPZmZzZXQoKSxcbiAgICAgICAgZmxpcDoge1xuICAgICAgICAgIGJlaGF2aW9yOiB0aGlzLmNvbmZpZy5mYWxsYmFja1BsYWNlbWVudFxuICAgICAgICB9LFxuICAgICAgICBhcnJvdzoge1xuICAgICAgICAgIGVsZW1lbnQ6IFNlbGVjdG9yLkFSUk9XXG4gICAgICAgIH0sXG4gICAgICAgIHByZXZlbnRPdmVyZmxvdzoge1xuICAgICAgICAgIGJvdW5kYXJpZXNFbGVtZW50OiB0aGlzLmNvbmZpZy5ib3VuZGFyeVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25DcmVhdGU6IChkYXRhKSA9PiB7XG4gICAgICAgIGlmIChkYXRhLm9yaWdpbmFsUGxhY2VtZW50ICE9PSBkYXRhLnBsYWNlbWVudCkge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZShkYXRhKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25VcGRhdGU6IChkYXRhKSA9PiB0aGlzLl9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UoZGF0YSlcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGVmYXVsdEJzQ29uZmlnLFxuICAgICAgLi4udGhpcy5jb25maWcucG9wcGVyQ29uZmlnXG4gICAgfVxuICB9XG5cbiAgX2dldE9mZnNldCgpIHtcbiAgICBjb25zdCBvZmZzZXQgPSB7fVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLmNvbmZpZy5vZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9mZnNldC5mbiA9IChkYXRhKSA9PiB7XG4gICAgICAgIGRhdGEub2Zmc2V0cyA9IHtcbiAgICAgICAgICAuLi5kYXRhLm9mZnNldHMsXG4gICAgICAgICAgLi4udGhpcy5jb25maWcub2Zmc2V0KGRhdGEub2Zmc2V0cywgdGhpcy5lbGVtZW50KSB8fCB7fVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0Lm9mZnNldCA9IHRoaXMuY29uZmlnLm9mZnNldFxuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXRcbiAgfVxuXG4gIF9nZXRDb250YWluZXIoKSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLmNvbnRhaW5lciA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5XG4gICAgfVxuXG4gICAgaWYgKFV0aWwuaXNFbGVtZW50KHRoaXMuY29uZmlnLmNvbnRhaW5lcikpIHtcbiAgICAgIHJldHVybiAkKHRoaXMuY29uZmlnLmNvbnRhaW5lcilcbiAgICB9XG5cbiAgICByZXR1cm4gJChkb2N1bWVudCkuZmluZCh0aGlzLmNvbmZpZy5jb250YWluZXIpXG4gIH1cblxuICBfZ2V0QXR0YWNobWVudChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gQXR0YWNobWVudE1hcFtwbGFjZW1lbnQudG9VcHBlckNhc2UoKV1cbiAgfVxuXG4gIF9zZXRMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgdHJpZ2dlcnMgPSB0aGlzLmNvbmZpZy50cmlnZ2VyLnNwbGl0KCcgJylcblxuICAgIHRyaWdnZXJzLmZvckVhY2goKHRyaWdnZXIpID0+IHtcbiAgICAgIGlmICh0cmlnZ2VyID09PSAnY2xpY2snKSB7XG4gICAgICAgICQodGhpcy5lbGVtZW50KS5vbihcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkNMSUNLLFxuICAgICAgICAgIHRoaXMuY29uZmlnLnNlbGVjdG9yLFxuICAgICAgICAgIChldmVudCkgPT4gdGhpcy50b2dnbGUoZXZlbnQpXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSBpZiAodHJpZ2dlciAhPT0gVHJpZ2dlci5NQU5VQUwpIHtcbiAgICAgICAgY29uc3QgZXZlbnRJbiA9IHRyaWdnZXIgPT09IFRyaWdnZXIuSE9WRVJcbiAgICAgICAgICA/IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuTU9VU0VFTlRFUlxuICAgICAgICAgIDogdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5GT0NVU0lOXG4gICAgICAgIGNvbnN0IGV2ZW50T3V0ID0gdHJpZ2dlciA9PT0gVHJpZ2dlci5IT1ZFUlxuICAgICAgICAgID8gdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5NT1VTRUxFQVZFXG4gICAgICAgICAgOiB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkZPQ1VTT1VUXG5cbiAgICAgICAgJCh0aGlzLmVsZW1lbnQpXG4gICAgICAgICAgLm9uKFxuICAgICAgICAgICAgZXZlbnRJbixcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLnNlbGVjdG9yLFxuICAgICAgICAgICAgKGV2ZW50KSA9PiB0aGlzLl9lbnRlcihldmVudClcbiAgICAgICAgICApXG4gICAgICAgICAgLm9uKFxuICAgICAgICAgICAgZXZlbnRPdXQsXG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5zZWxlY3RvcixcbiAgICAgICAgICAgIChldmVudCkgPT4gdGhpcy5fbGVhdmUoZXZlbnQpXG4gICAgICAgICAgKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgICB0aGlzLmhpZGUoKVxuICAgICAgfVxuICAgIH1cblxuICAgICQodGhpcy5lbGVtZW50KS5jbG9zZXN0KCcubW9kYWwnKS5vbihcbiAgICAgICdoaWRlLmJzLm1vZGFsJyxcbiAgICAgIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXJcbiAgICApXG5cbiAgICBpZiAodGhpcy5jb25maWcuc2VsZWN0b3IpIHtcbiAgICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgICAgdHJpZ2dlcjogJ21hbnVhbCcsXG4gICAgICAgIHNlbGVjdG9yOiAnJ1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9maXhUaXRsZSgpXG4gICAgfVxuICB9XG5cbiAgX2ZpeFRpdGxlKCkge1xuICAgIGNvbnN0IHRpdGxlVHlwZSA9IHR5cGVvZiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLXRpdGxlJylcblxuICAgIGlmICh0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0aXRsZScpIHx8IHRpdGxlVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICdkYXRhLW9yaWdpbmFsLXRpdGxlJyxcbiAgICAgICAgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgndGl0bGUnKSB8fCAnJ1xuICAgICAgKVxuXG4gICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCd0aXRsZScsICcnKVxuICAgIH1cbiAgfVxuXG4gIF9lbnRlcihldmVudCwgY29udGV4dCkge1xuICAgIGNvbnN0IGRhdGFLZXkgPSB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZXG4gICAgY29udGV4dCA9IGNvbnRleHQgfHwgJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKGRhdGFLZXkpXG5cbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgIGNvbnRleHQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihcbiAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCxcbiAgICAgICAgdGhpcy5fZ2V0RGVsZWdhdGVDb25maWcoKVxuICAgICAgKVxuICAgICAgJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKGRhdGFLZXksIGNvbnRleHQpXG4gICAgfVxuXG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICBjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyW1xuICAgICAgICBldmVudC50eXBlID09PSAnZm9jdXNpbicgPyBUcmlnZ2VyLkZPQ1VTIDogVHJpZ2dlci5IT1ZFUlxuICAgICAgXSA9IHRydWVcbiAgICB9XG5cbiAgICBpZiAoJChjb250ZXh0LmdldFRpcEVsZW1lbnQoKSkuaGFzQ2xhc3MoQ2xhc3NOYW1lLlNIT1cpIHx8IGNvbnRleHQuX2hvdmVyU3RhdGUgPT09IEhvdmVyU3RhdGUuU0hPVykge1xuICAgICAgY29udGV4dC5faG92ZXJTdGF0ZSA9IEhvdmVyU3RhdGUuU0hPV1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuX3RpbWVvdXQpXG5cbiAgICBjb250ZXh0Ll9ob3ZlclN0YXRlID0gSG92ZXJTdGF0ZS5TSE9XXG5cbiAgICBpZiAoIWNvbnRleHQuY29uZmlnLmRlbGF5IHx8ICFjb250ZXh0LmNvbmZpZy5kZWxheS5zaG93KSB7XG4gICAgICBjb250ZXh0LnNob3coKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29udGV4dC5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKGNvbnRleHQuX2hvdmVyU3RhdGUgPT09IEhvdmVyU3RhdGUuU0hPVykge1xuICAgICAgICBjb250ZXh0LnNob3coKVxuICAgICAgfVxuICAgIH0sIGNvbnRleHQuY29uZmlnLmRlbGF5LnNob3cpXG4gIH1cblxuICBfbGVhdmUoZXZlbnQsIGNvbnRleHQpIHtcbiAgICBjb25zdCBkYXRhS2V5ID0gdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWVxuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8ICQoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YShkYXRhS2V5KVxuXG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICBjb250ZXh0ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoXG4gICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQsXG4gICAgICAgIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKClcbiAgICAgIClcbiAgICAgICQoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YShkYXRhS2V5LCBjb250ZXh0KVxuICAgIH1cblxuICAgIGlmIChldmVudCkge1xuICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlcltcbiAgICAgICAgZXZlbnQudHlwZSA9PT0gJ2ZvY3Vzb3V0JyA/IFRyaWdnZXIuRk9DVVMgOiBUcmlnZ2VyLkhPVkVSXG4gICAgICBdID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dC5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjbGVhclRpbWVvdXQoY29udGV4dC5fdGltZW91dClcblxuICAgIGNvbnRleHQuX2hvdmVyU3RhdGUgPSBIb3ZlclN0YXRlLk9VVFxuXG4gICAgaWYgKCFjb250ZXh0LmNvbmZpZy5kZWxheSB8fCAhY29udGV4dC5jb25maWcuZGVsYXkuaGlkZSkge1xuICAgICAgY29udGV4dC5oaWRlKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnRleHQuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChjb250ZXh0Ll9ob3ZlclN0YXRlID09PSBIb3ZlclN0YXRlLk9VVCkge1xuICAgICAgICBjb250ZXh0LmhpZGUoKVxuICAgICAgfVxuICAgIH0sIGNvbnRleHQuY29uZmlnLmRlbGF5LmhpZGUpXG4gIH1cblxuICBfaXNXaXRoQWN0aXZlVHJpZ2dlcigpIHtcbiAgICBmb3IgKGNvbnN0IHRyaWdnZXIgaW4gdGhpcy5fYWN0aXZlVHJpZ2dlcikge1xuICAgICAgaWYgKHRoaXMuX2FjdGl2ZVRyaWdnZXJbdHJpZ2dlcl0pIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uc3QgZGF0YUF0dHJpYnV0ZXMgPSAkKHRoaXMuZWxlbWVudCkuZGF0YSgpXG5cbiAgICBPYmplY3Qua2V5cyhkYXRhQXR0cmlidXRlcylcbiAgICAgIC5mb3JFYWNoKChkYXRhQXR0cikgPT4ge1xuICAgICAgICBpZiAoRElTQUxMT1dFRF9BVFRSSUJVVEVTLmluZGV4T2YoZGF0YUF0dHIpICE9PSAtMSkge1xuICAgICAgICAgIGRlbGV0ZSBkYXRhQXR0cmlidXRlc1tkYXRhQXR0cl1cbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgIGNvbmZpZyA9IHtcbiAgICAgIC4uLnRoaXMuY29uc3RydWN0b3IuRGVmYXVsdCxcbiAgICAgIC4uLmRhdGFBdHRyaWJ1dGVzLFxuICAgICAgLi4udHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnID8gY29uZmlnIDoge31cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZy5kZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbmZpZy5kZWxheSA9IHtcbiAgICAgICAgc2hvdzogY29uZmlnLmRlbGF5LFxuICAgICAgICBoaWRlOiBjb25maWcuZGVsYXlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZy50aXRsZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbmZpZy50aXRsZSA9IGNvbmZpZy50aXRsZS50b1N0cmluZygpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25maWcuY29udGVudCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbmZpZy5jb250ZW50ID0gY29uZmlnLmNvbnRlbnQudG9TdHJpbmcoKVxuICAgIH1cblxuICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKFxuICAgICAgTkFNRSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGVcbiAgICApXG5cbiAgICBpZiAoY29uZmlnLnNhbml0aXplKSB7XG4gICAgICBjb25maWcudGVtcGxhdGUgPSBzYW5pdGl6ZUh0bWwoY29uZmlnLnRlbXBsYXRlLCBjb25maWcud2hpdGVMaXN0LCBjb25maWcuc2FuaXRpemVGbilcbiAgICB9XG5cbiAgICByZXR1cm4gY29uZmlnXG4gIH1cblxuICBfZ2V0RGVsZWdhdGVDb25maWcoKSB7XG4gICAgY29uc3QgY29uZmlnID0ge31cblxuICAgIGlmICh0aGlzLmNvbmZpZykge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5jb25maWcpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFtrZXldICE9PSB0aGlzLmNvbmZpZ1trZXldKSB7XG4gICAgICAgICAgY29uZmlnW2tleV0gPSB0aGlzLmNvbmZpZ1trZXldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29uZmlnXG4gIH1cblxuICBfY2xlYW5UaXBDbGFzcygpIHtcbiAgICBjb25zdCAkdGlwID0gJCh0aGlzLmdldFRpcEVsZW1lbnQoKSlcbiAgICBjb25zdCB0YWJDbGFzcyA9ICR0aXAuYXR0cignY2xhc3MnKS5tYXRjaChCU0NMU19QUkVGSVhfUkVHRVgpXG4gICAgaWYgKHRhYkNsYXNzICE9PSBudWxsICYmIHRhYkNsYXNzLmxlbmd0aCkge1xuICAgICAgJHRpcC5yZW1vdmVDbGFzcyh0YWJDbGFzcy5qb2luKCcnKSlcbiAgICB9XG4gIH1cblxuICBfaGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKHBvcHBlckRhdGEpIHtcbiAgICBjb25zdCBwb3BwZXJJbnN0YW5jZSA9IHBvcHBlckRhdGEuaW5zdGFuY2VcbiAgICB0aGlzLnRpcCA9IHBvcHBlckluc3RhbmNlLnBvcHBlclxuICAgIHRoaXMuX2NsZWFuVGlwQ2xhc3MoKVxuICAgIHRoaXMuYWRkQXR0YWNobWVudENsYXNzKHRoaXMuX2dldEF0dGFjaG1lbnQocG9wcGVyRGF0YS5wbGFjZW1lbnQpKVxuICB9XG5cbiAgX2ZpeFRyYW5zaXRpb24oKSB7XG4gICAgY29uc3QgdGlwID0gdGhpcy5nZXRUaXBFbGVtZW50KClcbiAgICBjb25zdCBpbml0Q29uZmlnQW5pbWF0aW9uID0gdGhpcy5jb25maWcuYW5pbWF0aW9uXG5cbiAgICBpZiAodGlwLmdldEF0dHJpYnV0ZSgneC1wbGFjZW1lbnQnKSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgJCh0aXApLnJlbW92ZUNsYXNzKENsYXNzTmFtZS5GQURFKVxuICAgIHRoaXMuY29uZmlnLmFuaW1hdGlvbiA9IGZhbHNlXG4gICAgdGhpcy5oaWRlKClcbiAgICB0aGlzLnNob3coKVxuICAgIHRoaXMuY29uZmlnLmFuaW1hdGlvbiA9IGluaXRDb25maWdBbmltYXRpb25cbiAgfVxuXG4gIC8vIFN0YXRpY1xuXG4gIHN0YXRpYyBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgbGV0IGRhdGEgPSAkKHRoaXMpLmRhdGEoREFUQV9LRVkpXG4gICAgICBjb25zdCBfY29uZmlnID0gdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnXG5cbiAgICAgIGlmICghZGF0YSAmJiAvZGlzcG9zZXxoaWRlLy50ZXN0KGNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICBkYXRhID0gbmV3IFRvb2x0aXAodGhpcywgX2NvbmZpZylcbiAgICAgICAgJCh0aGlzKS5kYXRhKERBVEFfS0VZLCBkYXRhKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKVxuICAgICAgICB9XG4gICAgICAgIGRhdGFbY29uZmlnXSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4kLmZuW05BTUVdID0gVG9vbHRpcC5falF1ZXJ5SW50ZXJmYWNlXG4kLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gVG9vbHRpcFxuJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gKCkgPT4ge1xuICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUXG4gIHJldHVybiBUb29sdGlwLl9qUXVlcnlJbnRlcmZhY2Vcbn1cblxuZXhwb3J0IGRlZmF1bHQgVG9vbHRpcFxuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC40LjEpOiBwb3BvdmVyLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknXG5pbXBvcnQgVG9vbHRpcCBmcm9tICcuL3Rvb2x0aXAnXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE5BTUUgICAgICAgICAgICAgICAgPSAncG9wb3ZlcidcbmNvbnN0IFZFUlNJT04gICAgICAgICAgICAgPSAnNC40LjEnXG5jb25zdCBEQVRBX0tFWSAgICAgICAgICAgID0gJ2JzLnBvcG92ZXInXG5jb25zdCBFVkVOVF9LRVkgICAgICAgICAgID0gYC4ke0RBVEFfS0VZfWBcbmNvbnN0IEpRVUVSWV9OT19DT05GTElDVCAgPSAkLmZuW05BTUVdXG5jb25zdCBDTEFTU19QUkVGSVggICAgICAgID0gJ2JzLXBvcG92ZXInXG5jb25zdCBCU0NMU19QUkVGSVhfUkVHRVggID0gbmV3IFJlZ0V4cChgKF58XFxcXHMpJHtDTEFTU19QUkVGSVh9XFxcXFMrYCwgJ2cnKVxuXG5jb25zdCBEZWZhdWx0ID0ge1xuICAuLi5Ub29sdGlwLkRlZmF1bHQsXG4gIHBsYWNlbWVudCA6ICdyaWdodCcsXG4gIHRyaWdnZXIgICA6ICdjbGljaycsXG4gIGNvbnRlbnQgICA6ICcnLFxuICB0ZW1wbGF0ZSAgOiAnPGRpdiBjbGFzcz1cInBvcG92ZXJcIiByb2xlPVwidG9vbHRpcFwiPicgK1xuICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImFycm93XCI+PC9kaXY+JyArXG4gICAgICAgICAgICAgICc8aDMgY2xhc3M9XCJwb3BvdmVyLWhlYWRlclwiPjwvaDM+JyArXG4gICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwicG9wb3Zlci1ib2R5XCI+PC9kaXY+PC9kaXY+J1xufVxuXG5jb25zdCBEZWZhdWx0VHlwZSA9IHtcbiAgLi4uVG9vbHRpcC5EZWZhdWx0VHlwZSxcbiAgY29udGVudCA6ICcoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pJ1xufVxuXG5jb25zdCBDbGFzc05hbWUgPSB7XG4gIEZBREUgOiAnZmFkZScsXG4gIFNIT1cgOiAnc2hvdydcbn1cblxuY29uc3QgU2VsZWN0b3IgPSB7XG4gIFRJVExFICAgOiAnLnBvcG92ZXItaGVhZGVyJyxcbiAgQ09OVEVOVCA6ICcucG9wb3Zlci1ib2R5J1xufVxuXG5jb25zdCBFdmVudCA9IHtcbiAgSElERSAgICAgICA6IGBoaWRlJHtFVkVOVF9LRVl9YCxcbiAgSElEREVOICAgICA6IGBoaWRkZW4ke0VWRU5UX0tFWX1gLFxuICBTSE9XICAgICAgIDogYHNob3cke0VWRU5UX0tFWX1gLFxuICBTSE9XTiAgICAgIDogYHNob3duJHtFVkVOVF9LRVl9YCxcbiAgSU5TRVJURUQgICA6IGBpbnNlcnRlZCR7RVZFTlRfS0VZfWAsXG4gIENMSUNLICAgICAgOiBgY2xpY2ske0VWRU5UX0tFWX1gLFxuICBGT0NVU0lOICAgIDogYGZvY3VzaW4ke0VWRU5UX0tFWX1gLFxuICBGT0NVU09VVCAgIDogYGZvY3Vzb3V0JHtFVkVOVF9LRVl9YCxcbiAgTU9VU0VFTlRFUiA6IGBtb3VzZWVudGVyJHtFVkVOVF9LRVl9YCxcbiAgTU9VU0VMRUFWRSA6IGBtb3VzZWxlYXZlJHtFVkVOVF9LRVl9YFxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgUG9wb3ZlciBleHRlbmRzIFRvb2x0aXAge1xuICAvLyBHZXR0ZXJzXG5cbiAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xuICAgIHJldHVybiBWRVJTSU9OXG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRcbiAgfVxuXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRVxuICB9XG5cbiAgc3RhdGljIGdldCBEQVRBX0tFWSgpIHtcbiAgICByZXR1cm4gREFUQV9LRVlcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRXZlbnQoKSB7XG4gICAgcmV0dXJuIEV2ZW50XG4gIH1cblxuICBzdGF0aWMgZ2V0IEVWRU5UX0tFWSgpIHtcbiAgICByZXR1cm4gRVZFTlRfS0VZXG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZVxuICB9XG5cbiAgLy8gT3ZlcnJpZGVzXG5cbiAgaXNXaXRoQ29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaXRsZSgpIHx8IHRoaXMuX2dldENvbnRlbnQoKVxuICB9XG5cbiAgYWRkQXR0YWNobWVudENsYXNzKGF0dGFjaG1lbnQpIHtcbiAgICAkKHRoaXMuZ2V0VGlwRWxlbWVudCgpKS5hZGRDbGFzcyhgJHtDTEFTU19QUkVGSVh9LSR7YXR0YWNobWVudH1gKVxuICB9XG5cbiAgZ2V0VGlwRWxlbWVudCgpIHtcbiAgICB0aGlzLnRpcCA9IHRoaXMudGlwIHx8ICQodGhpcy5jb25maWcudGVtcGxhdGUpWzBdXG4gICAgcmV0dXJuIHRoaXMudGlwXG4gIH1cblxuICBzZXRDb250ZW50KCkge1xuICAgIGNvbnN0ICR0aXAgPSAkKHRoaXMuZ2V0VGlwRWxlbWVudCgpKVxuXG4gICAgLy8gV2UgdXNlIGFwcGVuZCBmb3IgaHRtbCBvYmplY3RzIHRvIG1haW50YWluIGpzIGV2ZW50c1xuICAgIHRoaXMuc2V0RWxlbWVudENvbnRlbnQoJHRpcC5maW5kKFNlbGVjdG9yLlRJVExFKSwgdGhpcy5nZXRUaXRsZSgpKVxuICAgIGxldCBjb250ZW50ID0gdGhpcy5fZ2V0Q29udGVudCgpXG4gICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb250ZW50ID0gY29udGVudC5jYWxsKHRoaXMuZWxlbWVudClcbiAgICB9XG4gICAgdGhpcy5zZXRFbGVtZW50Q29udGVudCgkdGlwLmZpbmQoU2VsZWN0b3IuQ09OVEVOVCksIGNvbnRlbnQpXG5cbiAgICAkdGlwLnJlbW92ZUNsYXNzKGAke0NsYXNzTmFtZS5GQURFfSAke0NsYXNzTmFtZS5TSE9XfWApXG4gIH1cblxuICAvLyBQcml2YXRlXG5cbiAgX2dldENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY29udGVudCcpIHx8XG4gICAgICB0aGlzLmNvbmZpZy5jb250ZW50XG4gIH1cblxuICBfY2xlYW5UaXBDbGFzcygpIHtcbiAgICBjb25zdCAkdGlwID0gJCh0aGlzLmdldFRpcEVsZW1lbnQoKSlcbiAgICBjb25zdCB0YWJDbGFzcyA9ICR0aXAuYXR0cignY2xhc3MnKS5tYXRjaChCU0NMU19QUkVGSVhfUkVHRVgpXG4gICAgaWYgKHRhYkNsYXNzICE9PSBudWxsICYmIHRhYkNsYXNzLmxlbmd0aCA+IDApIHtcbiAgICAgICR0aXAucmVtb3ZlQ2xhc3ModGFiQ2xhc3Muam9pbignJykpXG4gICAgfVxuICB9XG5cbiAgLy8gU3RhdGljXG5cbiAgc3RhdGljIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgZGF0YSA9ICQodGhpcykuZGF0YShEQVRBX0tFWSlcbiAgICAgIGNvbnN0IF9jb25maWcgPSB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IG51bGxcblxuICAgICAgaWYgKCFkYXRhICYmIC9kaXNwb3NlfGhpZGUvLnRlc3QoY29uZmlnKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgUG9wb3Zlcih0aGlzLCBfY29uZmlnKVxuICAgICAgICAkKHRoaXMpLmRhdGEoREFUQV9LRVksIGRhdGEpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApXG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtjb25maWddKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBqUXVlcnlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbiQuZm5bTkFNRV0gPSBQb3BvdmVyLl9qUXVlcnlJbnRlcmZhY2VcbiQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBQb3BvdmVyXG4kLmZuW05BTUVdLm5vQ29uZmxpY3QgPSAoKSA9PiB7XG4gICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1RcbiAgcmV0dXJuIFBvcG92ZXIuX2pRdWVyeUludGVyZmFjZVxufVxuXG5leHBvcnQgZGVmYXVsdCBQb3BvdmVyXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjQuMSk6IHNjcm9sbHNweS5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5J1xuaW1wb3J0IFV0aWwgZnJvbSAnLi91dGlsJ1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FICAgICAgICAgICAgICAgPSAnc2Nyb2xsc3B5J1xuY29uc3QgVkVSU0lPTiAgICAgICAgICAgID0gJzQuNC4xJ1xuY29uc3QgREFUQV9LRVkgICAgICAgICAgID0gJ2JzLnNjcm9sbHNweSdcbmNvbnN0IEVWRU5UX0tFWSAgICAgICAgICA9IGAuJHtEQVRBX0tFWX1gXG5jb25zdCBEQVRBX0FQSV9LRVkgICAgICAgPSAnLmRhdGEtYXBpJ1xuY29uc3QgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltOQU1FXVxuXG5jb25zdCBEZWZhdWx0ID0ge1xuICBvZmZzZXQgOiAxMCxcbiAgbWV0aG9kIDogJ2F1dG8nLFxuICB0YXJnZXQgOiAnJ1xufVxuXG5jb25zdCBEZWZhdWx0VHlwZSA9IHtcbiAgb2Zmc2V0IDogJ251bWJlcicsXG4gIG1ldGhvZCA6ICdzdHJpbmcnLFxuICB0YXJnZXQgOiAnKHN0cmluZ3xlbGVtZW50KSdcbn1cblxuY29uc3QgRXZlbnQgPSB7XG4gIEFDVElWQVRFICAgICAgOiBgYWN0aXZhdGUke0VWRU5UX0tFWX1gLFxuICBTQ1JPTEwgICAgICAgIDogYHNjcm9sbCR7RVZFTlRfS0VZfWAsXG4gIExPQURfREFUQV9BUEkgOiBgbG9hZCR7RVZFTlRfS0VZfSR7REFUQV9BUElfS0VZfWBcbn1cblxuY29uc3QgQ2xhc3NOYW1lID0ge1xuICBEUk9QRE9XTl9JVEVNIDogJ2Ryb3Bkb3duLWl0ZW0nLFxuICBEUk9QRE9XTl9NRU5VIDogJ2Ryb3Bkb3duLW1lbnUnLFxuICBBQ1RJVkUgICAgICAgIDogJ2FjdGl2ZSdcbn1cblxuY29uc3QgU2VsZWN0b3IgPSB7XG4gIERBVEFfU1BZICAgICAgICA6ICdbZGF0YS1zcHk9XCJzY3JvbGxcIl0nLFxuICBBQ1RJVkUgICAgICAgICAgOiAnLmFjdGl2ZScsXG4gIE5BVl9MSVNUX0dST1VQICA6ICcubmF2LCAubGlzdC1ncm91cCcsXG4gIE5BVl9MSU5LUyAgICAgICA6ICcubmF2LWxpbmsnLFxuICBOQVZfSVRFTVMgICAgICAgOiAnLm5hdi1pdGVtJyxcbiAgTElTVF9JVEVNUyAgICAgIDogJy5saXN0LWdyb3VwLWl0ZW0nLFxuICBEUk9QRE9XTiAgICAgICAgOiAnLmRyb3Bkb3duJyxcbiAgRFJPUERPV05fSVRFTVMgIDogJy5kcm9wZG93bi1pdGVtJyxcbiAgRFJPUERPV05fVE9HR0xFIDogJy5kcm9wZG93bi10b2dnbGUnXG59XG5cbmNvbnN0IE9mZnNldE1ldGhvZCA9IHtcbiAgT0ZGU0VUICAgOiAnb2Zmc2V0JyxcbiAgUE9TSVRJT04gOiAncG9zaXRpb24nXG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDbGFzcyBEZWZpbml0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jbGFzcyBTY3JvbGxTcHkge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICB0aGlzLl9lbGVtZW50ICAgICAgID0gZWxlbWVudFxuICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQgPSBlbGVtZW50LnRhZ05hbWUgPT09ICdCT0RZJyA/IHdpbmRvdyA6IGVsZW1lbnRcbiAgICB0aGlzLl9jb25maWcgICAgICAgID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZylcbiAgICB0aGlzLl9zZWxlY3RvciAgICAgID0gYCR7dGhpcy5fY29uZmlnLnRhcmdldH0gJHtTZWxlY3Rvci5OQVZfTElOS1N9LGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBgJHt0aGlzLl9jb25maWcudGFyZ2V0fSAke1NlbGVjdG9yLkxJU1RfSVRFTVN9LGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBgJHt0aGlzLl9jb25maWcudGFyZ2V0fSAke1NlbGVjdG9yLkRST1BET1dOX0lURU1TfWBcbiAgICB0aGlzLl9vZmZzZXRzICAgICAgID0gW11cbiAgICB0aGlzLl90YXJnZXRzICAgICAgID0gW11cbiAgICB0aGlzLl9hY3RpdmVUYXJnZXQgID0gbnVsbFxuICAgIHRoaXMuX3Njcm9sbEhlaWdodCAgPSAwXG5cbiAgICAkKHRoaXMuX3Njcm9sbEVsZW1lbnQpLm9uKEV2ZW50LlNDUk9MTCwgKGV2ZW50KSA9PiB0aGlzLl9wcm9jZXNzKGV2ZW50KSlcblxuICAgIHRoaXMucmVmcmVzaCgpXG4gICAgdGhpcy5fcHJvY2VzcygpXG4gIH1cblxuICAvLyBHZXR0ZXJzXG5cbiAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xuICAgIHJldHVybiBWRVJTSU9OXG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRcbiAgfVxuXG4gIC8vIFB1YmxpY1xuXG4gIHJlZnJlc2goKSB7XG4gICAgY29uc3QgYXV0b01ldGhvZCA9IHRoaXMuX3Njcm9sbEVsZW1lbnQgPT09IHRoaXMuX3Njcm9sbEVsZW1lbnQud2luZG93XG4gICAgICA/IE9mZnNldE1ldGhvZC5PRkZTRVQgOiBPZmZzZXRNZXRob2QuUE9TSVRJT05cblxuICAgIGNvbnN0IG9mZnNldE1ldGhvZCA9IHRoaXMuX2NvbmZpZy5tZXRob2QgPT09ICdhdXRvJ1xuICAgICAgPyBhdXRvTWV0aG9kIDogdGhpcy5fY29uZmlnLm1ldGhvZFxuXG4gICAgY29uc3Qgb2Zmc2V0QmFzZSA9IG9mZnNldE1ldGhvZCA9PT0gT2Zmc2V0TWV0aG9kLlBPU0lUSU9OXG4gICAgICA/IHRoaXMuX2dldFNjcm9sbFRvcCgpIDogMFxuXG4gICAgdGhpcy5fb2Zmc2V0cyA9IFtdXG4gICAgdGhpcy5fdGFyZ2V0cyA9IFtdXG5cbiAgICB0aGlzLl9zY3JvbGxIZWlnaHQgPSB0aGlzLl9nZXRTY3JvbGxIZWlnaHQoKVxuXG4gICAgY29uc3QgdGFyZ2V0cyA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLl9zZWxlY3RvcikpXG5cbiAgICB0YXJnZXRzXG4gICAgICAubWFwKChlbGVtZW50KSA9PiB7XG4gICAgICAgIGxldCB0YXJnZXRcbiAgICAgICAgY29uc3QgdGFyZ2V0U2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudClcblxuICAgICAgICBpZiAodGFyZ2V0U2VsZWN0b3IpIHtcbiAgICAgICAgICB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldFNlbGVjdG9yKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgIGNvbnN0IHRhcmdldEJDUiA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgIGlmICh0YXJnZXRCQ1Iud2lkdGggfHwgdGFyZ2V0QkNSLmhlaWdodCkge1xuICAgICAgICAgICAgLy8gVE9ETyAoZmF0KTogcmVtb3ZlIHNrZXRjaCByZWxpYW5jZSBvbiBqUXVlcnkgcG9zaXRpb24vb2Zmc2V0XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAkKHRhcmdldClbb2Zmc2V0TWV0aG9kXSgpLnRvcCArIG9mZnNldEJhc2UsXG4gICAgICAgICAgICAgIHRhcmdldFNlbGVjdG9yXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9KVxuICAgICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbSlcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhWzBdIC0gYlswXSlcbiAgICAgIC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIHRoaXMuX29mZnNldHMucHVzaChpdGVtWzBdKVxuICAgICAgICB0aGlzLl90YXJnZXRzLnB1c2goaXRlbVsxXSlcbiAgICAgIH0pXG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgICQucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBEQVRBX0tFWSlcbiAgICAkKHRoaXMuX3Njcm9sbEVsZW1lbnQpLm9mZihFVkVOVF9LRVkpXG5cbiAgICB0aGlzLl9lbGVtZW50ICAgICAgID0gbnVsbFxuICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQgPSBudWxsXG4gICAgdGhpcy5fY29uZmlnICAgICAgICA9IG51bGxcbiAgICB0aGlzLl9zZWxlY3RvciAgICAgID0gbnVsbFxuICAgIHRoaXMuX29mZnNldHMgICAgICAgPSBudWxsXG4gICAgdGhpcy5fdGFyZ2V0cyAgICAgICA9IG51bGxcbiAgICB0aGlzLl9hY3RpdmVUYXJnZXQgID0gbnVsbFxuICAgIHRoaXMuX3Njcm9sbEhlaWdodCAgPSBudWxsXG4gIH1cblxuICAvLyBQcml2YXRlXG5cbiAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcgPSB7XG4gICAgICAuLi5EZWZhdWx0LFxuICAgICAgLi4udHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnID8gY29uZmlnIDoge31cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZy50YXJnZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICBsZXQgaWQgPSAkKGNvbmZpZy50YXJnZXQpLmF0dHIoJ2lkJylcbiAgICAgIGlmICghaWQpIHtcbiAgICAgICAgaWQgPSBVdGlsLmdldFVJRChOQU1FKVxuICAgICAgICAkKGNvbmZpZy50YXJnZXQpLmF0dHIoJ2lkJywgaWQpXG4gICAgICB9XG4gICAgICBjb25maWcudGFyZ2V0ID0gYCMke2lkfWBcbiAgICB9XG5cbiAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhOQU1FLCBjb25maWcsIERlZmF1bHRUeXBlKVxuXG4gICAgcmV0dXJuIGNvbmZpZ1xuICB9XG5cbiAgX2dldFNjcm9sbFRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gd2luZG93XG4gICAgICA/IHRoaXMuX3Njcm9sbEVsZW1lbnQucGFnZVlPZmZzZXQgOiB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbFRvcFxuICB9XG5cbiAgX2dldFNjcm9sbEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxIZWlnaHQgfHwgTWF0aC5tYXgoXG4gICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCxcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHRcbiAgICApXG4gIH1cblxuICBfZ2V0T2Zmc2V0SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50ID09PSB3aW5kb3dcbiAgICAgID8gd2luZG93LmlubmVySGVpZ2h0IDogdGhpcy5fc2Nyb2xsRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcbiAgfVxuXG4gIF9wcm9jZXNzKCkge1xuICAgIGNvbnN0IHNjcm9sbFRvcCAgICA9IHRoaXMuX2dldFNjcm9sbFRvcCgpICsgdGhpcy5fY29uZmlnLm9mZnNldFxuICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IHRoaXMuX2dldFNjcm9sbEhlaWdodCgpXG4gICAgY29uc3QgbWF4U2Nyb2xsICAgID0gdGhpcy5fY29uZmlnLm9mZnNldCArXG4gICAgICBzY3JvbGxIZWlnaHQgLVxuICAgICAgdGhpcy5fZ2V0T2Zmc2V0SGVpZ2h0KClcblxuICAgIGlmICh0aGlzLl9zY3JvbGxIZWlnaHQgIT09IHNjcm9sbEhlaWdodCkge1xuICAgICAgdGhpcy5yZWZyZXNoKClcbiAgICB9XG5cbiAgICBpZiAoc2Nyb2xsVG9wID49IG1heFNjcm9sbCkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0c1t0aGlzLl90YXJnZXRzLmxlbmd0aCAtIDFdXG5cbiAgICAgIGlmICh0aGlzLl9hY3RpdmVUYXJnZXQgIT09IHRhcmdldCkge1xuICAgICAgICB0aGlzLl9hY3RpdmF0ZSh0YXJnZXQpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYWN0aXZlVGFyZ2V0ICYmIHNjcm9sbFRvcCA8IHRoaXMuX29mZnNldHNbMF0gJiYgdGhpcy5fb2Zmc2V0c1swXSA+IDApIHtcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGxcbiAgICAgIHRoaXMuX2NsZWFyKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IG9mZnNldExlbmd0aCA9IHRoaXMuX29mZnNldHMubGVuZ3RoXG4gICAgZm9yIChsZXQgaSA9IG9mZnNldExlbmd0aDsgaS0tOykge1xuICAgICAgY29uc3QgaXNBY3RpdmVUYXJnZXQgPSB0aGlzLl9hY3RpdmVUYXJnZXQgIT09IHRoaXMuX3RhcmdldHNbaV0gJiZcbiAgICAgICAgICBzY3JvbGxUb3AgPj0gdGhpcy5fb2Zmc2V0c1tpXSAmJlxuICAgICAgICAgICh0eXBlb2YgdGhpcy5fb2Zmc2V0c1tpICsgMV0gPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgICAgIHNjcm9sbFRvcCA8IHRoaXMuX29mZnNldHNbaSArIDFdKVxuXG4gICAgICBpZiAoaXNBY3RpdmVUYXJnZXQpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZhdGUodGhpcy5fdGFyZ2V0c1tpXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfYWN0aXZhdGUodGFyZ2V0KSB7XG4gICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gdGFyZ2V0XG5cbiAgICB0aGlzLl9jbGVhcigpXG5cbiAgICBjb25zdCBxdWVyaWVzID0gdGhpcy5fc2VsZWN0b3JcbiAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAubWFwKChzZWxlY3RvcikgPT4gYCR7c2VsZWN0b3J9W2RhdGEtdGFyZ2V0PVwiJHt0YXJnZXR9XCJdLCR7c2VsZWN0b3J9W2hyZWY9XCIke3RhcmdldH1cIl1gKVxuXG4gICAgY29uc3QgJGxpbmsgPSAkKFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChxdWVyaWVzLmpvaW4oJywnKSkpKVxuXG4gICAgaWYgKCRsaW5rLmhhc0NsYXNzKENsYXNzTmFtZS5EUk9QRE9XTl9JVEVNKSkge1xuICAgICAgJGxpbmsuY2xvc2VzdChTZWxlY3Rvci5EUk9QRE9XTikuZmluZChTZWxlY3Rvci5EUk9QRE9XTl9UT0dHTEUpLmFkZENsYXNzKENsYXNzTmFtZS5BQ1RJVkUpXG4gICAgICAkbGluay5hZGRDbGFzcyhDbGFzc05hbWUuQUNUSVZFKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXQgdHJpZ2dlcmVkIGxpbmsgYXMgYWN0aXZlXG4gICAgICAkbGluay5hZGRDbGFzcyhDbGFzc05hbWUuQUNUSVZFKVxuICAgICAgLy8gU2V0IHRyaWdnZXJlZCBsaW5rcyBwYXJlbnRzIGFzIGFjdGl2ZVxuICAgICAgLy8gV2l0aCBib3RoIDx1bD4gYW5kIDxuYXY+IG1hcmt1cCBhIHBhcmVudCBpcyB0aGUgcHJldmlvdXMgc2libGluZyBvZiBhbnkgbmF2IGFuY2VzdG9yXG4gICAgICAkbGluay5wYXJlbnRzKFNlbGVjdG9yLk5BVl9MSVNUX0dST1VQKS5wcmV2KGAke1NlbGVjdG9yLk5BVl9MSU5LU30sICR7U2VsZWN0b3IuTElTVF9JVEVNU31gKS5hZGRDbGFzcyhDbGFzc05hbWUuQUNUSVZFKVxuICAgICAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZSB3aGVuIC5uYXYtbGluayBpcyBpbnNpZGUgLm5hdi1pdGVtXG4gICAgICAkbGluay5wYXJlbnRzKFNlbGVjdG9yLk5BVl9MSVNUX0dST1VQKS5wcmV2KFNlbGVjdG9yLk5BVl9JVEVNUykuY2hpbGRyZW4oU2VsZWN0b3IuTkFWX0xJTktTKS5hZGRDbGFzcyhDbGFzc05hbWUuQUNUSVZFKVxuICAgIH1cblxuICAgICQodGhpcy5fc2Nyb2xsRWxlbWVudCkudHJpZ2dlcihFdmVudC5BQ1RJVkFURSwge1xuICAgICAgcmVsYXRlZFRhcmdldDogdGFyZ2V0XG4gICAgfSlcbiAgfVxuXG4gIF9jbGVhcigpIHtcbiAgICBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5fc2VsZWN0b3IpKVxuICAgICAgLmZpbHRlcigobm9kZSkgPT4gbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoQ2xhc3NOYW1lLkFDVElWRSkpXG4gICAgICAuZm9yRWFjaCgobm9kZSkgPT4gbm9kZS5jbGFzc0xpc3QucmVtb3ZlKENsYXNzTmFtZS5BQ1RJVkUpKVxuICB9XG5cbiAgLy8gU3RhdGljXG5cbiAgc3RhdGljIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgZGF0YSA9ICQodGhpcykuZGF0YShEQVRBX0tFWSlcbiAgICAgIGNvbnN0IF9jb25maWcgPSB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWdcblxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgU2Nyb2xsU3B5KHRoaXMsIF9jb25maWcpXG4gICAgICAgICQodGhpcykuZGF0YShEQVRBX0tFWSwgZGF0YSlcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYClcbiAgICAgICAgfVxuICAgICAgICBkYXRhW2NvbmZpZ10oKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4kKHdpbmRvdykub24oRXZlbnQuTE9BRF9EQVRBX0FQSSwgKCkgPT4ge1xuICBjb25zdCBzY3JvbGxTcHlzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNlbGVjdG9yLkRBVEFfU1BZKSlcbiAgY29uc3Qgc2Nyb2xsU3B5c0xlbmd0aCA9IHNjcm9sbFNweXMubGVuZ3RoXG5cbiAgZm9yIChsZXQgaSA9IHNjcm9sbFNweXNMZW5ndGg7IGktLTspIHtcbiAgICBjb25zdCAkc3B5ID0gJChzY3JvbGxTcHlzW2ldKVxuICAgIFNjcm9sbFNweS5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJHNweSwgJHNweS5kYXRhKCkpXG4gIH1cbn0pXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBqUXVlcnlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbiQuZm5bTkFNRV0gPSBTY3JvbGxTcHkuX2pRdWVyeUludGVyZmFjZVxuJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IFNjcm9sbFNweVxuJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gKCkgPT4ge1xuICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUXG4gIHJldHVybiBTY3JvbGxTcHkuX2pRdWVyeUludGVyZmFjZVxufVxuXG5leHBvcnQgZGVmYXVsdCBTY3JvbGxTcHlcbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuNC4xKTogdGFiLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknXG5pbXBvcnQgVXRpbCBmcm9tICcuL3V0aWwnXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE5BTUUgICAgICAgICAgICAgICA9ICd0YWInXG5jb25zdCBWRVJTSU9OICAgICAgICAgICAgPSAnNC40LjEnXG5jb25zdCBEQVRBX0tFWSAgICAgICAgICAgPSAnYnMudGFiJ1xuY29uc3QgRVZFTlRfS0VZICAgICAgICAgID0gYC4ke0RBVEFfS0VZfWBcbmNvbnN0IERBVEFfQVBJX0tFWSAgICAgICA9ICcuZGF0YS1hcGknXG5jb25zdCBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW05BTUVdXG5cbmNvbnN0IEV2ZW50ID0ge1xuICBISURFICAgICAgICAgICA6IGBoaWRlJHtFVkVOVF9LRVl9YCxcbiAgSElEREVOICAgICAgICAgOiBgaGlkZGVuJHtFVkVOVF9LRVl9YCxcbiAgU0hPVyAgICAgICAgICAgOiBgc2hvdyR7RVZFTlRfS0VZfWAsXG4gIFNIT1dOICAgICAgICAgIDogYHNob3duJHtFVkVOVF9LRVl9YCxcbiAgQ0xJQ0tfREFUQV9BUEkgOiBgY2xpY2ske0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gXG59XG5cbmNvbnN0IENsYXNzTmFtZSA9IHtcbiAgRFJPUERPV05fTUVOVSA6ICdkcm9wZG93bi1tZW51JyxcbiAgQUNUSVZFICAgICAgICA6ICdhY3RpdmUnLFxuICBESVNBQkxFRCAgICAgIDogJ2Rpc2FibGVkJyxcbiAgRkFERSAgICAgICAgICA6ICdmYWRlJyxcbiAgU0hPVyAgICAgICAgICA6ICdzaG93J1xufVxuXG5jb25zdCBTZWxlY3RvciA9IHtcbiAgRFJPUERPV04gICAgICAgICAgICAgIDogJy5kcm9wZG93bicsXG4gIE5BVl9MSVNUX0dST1VQICAgICAgICA6ICcubmF2LCAubGlzdC1ncm91cCcsXG4gIEFDVElWRSAgICAgICAgICAgICAgICA6ICcuYWN0aXZlJyxcbiAgQUNUSVZFX1VMICAgICAgICAgICAgIDogJz4gbGkgPiAuYWN0aXZlJyxcbiAgREFUQV9UT0dHTEUgICAgICAgICAgIDogJ1tkYXRhLXRvZ2dsZT1cInRhYlwiXSwgW2RhdGEtdG9nZ2xlPVwicGlsbFwiXSwgW2RhdGEtdG9nZ2xlPVwibGlzdFwiXScsXG4gIERST1BET1dOX1RPR0dMRSAgICAgICA6ICcuZHJvcGRvd24tdG9nZ2xlJyxcbiAgRFJPUERPV05fQUNUSVZFX0NISUxEIDogJz4gLmRyb3Bkb3duLW1lbnUgLmFjdGl2ZSdcbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENsYXNzIERlZmluaXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNsYXNzIFRhYiB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudFxuICB9XG5cbiAgLy8gR2V0dGVyc1xuXG4gIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICByZXR1cm4gVkVSU0lPTlxuICB9XG5cbiAgLy8gUHVibGljXG5cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5fZWxlbWVudC5wYXJlbnROb2RlICYmXG4gICAgICAgIHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiZcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDbGFzc05hbWUuQUNUSVZFKSB8fFxuICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENsYXNzTmFtZS5ESVNBQkxFRCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCB0YXJnZXRcbiAgICBsZXQgcHJldmlvdXNcbiAgICBjb25zdCBsaXN0RWxlbWVudCA9ICQodGhpcy5fZWxlbWVudCkuY2xvc2VzdChTZWxlY3Rvci5OQVZfTElTVF9HUk9VUClbMF1cbiAgICBjb25zdCBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KVxuXG4gICAgaWYgKGxpc3RFbGVtZW50KSB7XG4gICAgICBjb25zdCBpdGVtU2VsZWN0b3IgPSBsaXN0RWxlbWVudC5ub2RlTmFtZSA9PT0gJ1VMJyB8fCBsaXN0RWxlbWVudC5ub2RlTmFtZSA9PT0gJ09MJyA/IFNlbGVjdG9yLkFDVElWRV9VTCA6IFNlbGVjdG9yLkFDVElWRVxuICAgICAgcHJldmlvdXMgPSAkLm1ha2VBcnJheSgkKGxpc3RFbGVtZW50KS5maW5kKGl0ZW1TZWxlY3RvcikpXG4gICAgICBwcmV2aW91cyA9IHByZXZpb3VzW3ByZXZpb3VzLmxlbmd0aCAtIDFdXG4gICAgfVxuXG4gICAgY29uc3QgaGlkZUV2ZW50ID0gJC5FdmVudChFdmVudC5ISURFLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgfSlcblxuICAgIGNvbnN0IHNob3dFdmVudCA9ICQuRXZlbnQoRXZlbnQuU0hPVywge1xuICAgICAgcmVsYXRlZFRhcmdldDogcHJldmlvdXNcbiAgICB9KVxuXG4gICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICAkKHByZXZpb3VzKS50cmlnZ2VyKGhpZGVFdmVudClcbiAgICB9XG5cbiAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc2hvd0V2ZW50KVxuXG4gICAgaWYgKHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fFxuICAgICAgICBoaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgdGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcilcbiAgICB9XG5cbiAgICB0aGlzLl9hY3RpdmF0ZShcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBsaXN0RWxlbWVudFxuICAgIClcblxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgY29uc3QgaGlkZGVuRXZlbnQgPSAkLkV2ZW50KEV2ZW50LkhJRERFTiwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgICB9KVxuXG4gICAgICBjb25zdCBzaG93bkV2ZW50ID0gJC5FdmVudChFdmVudC5TSE9XTiwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiBwcmV2aW91c1xuICAgICAgfSlcblxuICAgICAgJChwcmV2aW91cykudHJpZ2dlcihoaWRkZW5FdmVudClcbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzaG93bkV2ZW50KVxuICAgIH1cblxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMuX2FjdGl2YXRlKHRhcmdldCwgdGFyZ2V0LnBhcmVudE5vZGUsIGNvbXBsZXRlKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21wbGV0ZSgpXG4gICAgfVxuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpXG4gICAgdGhpcy5fZWxlbWVudCA9IG51bGxcbiAgfVxuXG4gIC8vIFByaXZhdGVcblxuICBfYWN0aXZhdGUoZWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnRzID0gY29udGFpbmVyICYmIChjb250YWluZXIubm9kZU5hbWUgPT09ICdVTCcgfHwgY29udGFpbmVyLm5vZGVOYW1lID09PSAnT0wnKVxuICAgICAgPyAkKGNvbnRhaW5lcikuZmluZChTZWxlY3Rvci5BQ1RJVkVfVUwpXG4gICAgICA6ICQoY29udGFpbmVyKS5jaGlsZHJlbihTZWxlY3Rvci5BQ1RJVkUpXG5cbiAgICBjb25zdCBhY3RpdmUgPSBhY3RpdmVFbGVtZW50c1swXVxuICAgIGNvbnN0IGlzVHJhbnNpdGlvbmluZyA9IGNhbGxiYWNrICYmIChhY3RpdmUgJiYgJChhY3RpdmUpLmhhc0NsYXNzKENsYXNzTmFtZS5GQURFKSlcbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHRoaXMuX3RyYW5zaXRpb25Db21wbGV0ZShcbiAgICAgIGVsZW1lbnQsXG4gICAgICBhY3RpdmUsXG4gICAgICBjYWxsYmFja1xuICAgIClcblxuICAgIGlmIChhY3RpdmUgJiYgaXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KGFjdGl2ZSlcblxuICAgICAgJChhY3RpdmUpXG4gICAgICAgIC5yZW1vdmVDbGFzcyhDbGFzc05hbWUuU0hPVylcbiAgICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSlcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcGxldGUoKVxuICAgIH1cbiAgfVxuXG4gIF90cmFuc2l0aW9uQ29tcGxldGUoZWxlbWVudCwgYWN0aXZlLCBjYWxsYmFjaykge1xuICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICQoYWN0aXZlKS5yZW1vdmVDbGFzcyhDbGFzc05hbWUuQUNUSVZFKVxuXG4gICAgICBjb25zdCBkcm9wZG93bkNoaWxkID0gJChhY3RpdmUucGFyZW50Tm9kZSkuZmluZChcbiAgICAgICAgU2VsZWN0b3IuRFJPUERPV05fQUNUSVZFX0NISUxEXG4gICAgICApWzBdXG5cbiAgICAgIGlmIChkcm9wZG93bkNoaWxkKSB7XG4gICAgICAgICQoZHJvcGRvd25DaGlsZCkucmVtb3ZlQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSlcbiAgICAgIH1cblxuICAgICAgaWYgKGFjdGl2ZS5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSA9PT0gJ3RhYicpIHtcbiAgICAgICAgYWN0aXZlLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIGZhbHNlKVxuICAgICAgfVxuICAgIH1cblxuICAgICQoZWxlbWVudCkuYWRkQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSlcbiAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSA9PT0gJ3RhYicpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSlcbiAgICB9XG5cbiAgICBVdGlsLnJlZmxvdyhlbGVtZW50KVxuXG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENsYXNzTmFtZS5GQURFKSkge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKENsYXNzTmFtZS5TSE9XKVxuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnBhcmVudE5vZGUgJiYgJChlbGVtZW50LnBhcmVudE5vZGUpLmhhc0NsYXNzKENsYXNzTmFtZS5EUk9QRE9XTl9NRU5VKSkge1xuICAgICAgY29uc3QgZHJvcGRvd25FbGVtZW50ID0gJChlbGVtZW50KS5jbG9zZXN0KFNlbGVjdG9yLkRST1BET1dOKVswXVxuXG4gICAgICBpZiAoZHJvcGRvd25FbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGRyb3Bkb3duVG9nZ2xlTGlzdCA9IFtdLnNsaWNlLmNhbGwoZHJvcGRvd25FbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU2VsZWN0b3IuRFJPUERPV05fVE9HR0xFKSlcblxuICAgICAgICAkKGRyb3Bkb3duVG9nZ2xlTGlzdCkuYWRkQ2xhc3MoQ2xhc3NOYW1lLkFDVElWRSlcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKVxuICAgIH1cblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKVxuICAgIH1cbiAgfVxuXG4gIC8vIFN0YXRpY1xuXG4gIHN0YXRpYyBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgJHRoaXMgPSAkKHRoaXMpXG4gICAgICBsZXQgZGF0YSA9ICR0aGlzLmRhdGEoREFUQV9LRVkpXG5cbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICBkYXRhID0gbmV3IFRhYih0aGlzKVxuICAgICAgICAkdGhpcy5kYXRhKERBVEFfS0VZLCBkYXRhKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKVxuICAgICAgICB9XG4gICAgICAgIGRhdGFbY29uZmlnXSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbiQoZG9jdW1lbnQpXG4gIC5vbihFdmVudC5DTElDS19EQVRBX0FQSSwgU2VsZWN0b3IuREFUQV9UT0dHTEUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICBUYWIuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQodGhpcyksICdzaG93JylcbiAgfSlcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGpRdWVyeVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuJC5mbltOQU1FXSA9IFRhYi5falF1ZXJ5SW50ZXJmYWNlXG4kLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gVGFiXG4kLmZuW05BTUVdLm5vQ29uZmxpY3QgPSAoKSA9PiB7XG4gICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1RcbiAgcmV0dXJuIFRhYi5falF1ZXJ5SW50ZXJmYWNlXG59XG5cbmV4cG9ydCBkZWZhdWx0IFRhYlxuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC40LjEpOiB0b2FzdC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5J1xuaW1wb3J0IFV0aWwgZnJvbSAnLi91dGlsJ1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FICAgICAgICAgICAgICAgPSAndG9hc3QnXG5jb25zdCBWRVJTSU9OICAgICAgICAgICAgPSAnNC40LjEnXG5jb25zdCBEQVRBX0tFWSAgICAgICAgICAgPSAnYnMudG9hc3QnXG5jb25zdCBFVkVOVF9LRVkgICAgICAgICAgPSBgLiR7REFUQV9LRVl9YFxuY29uc3QgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltOQU1FXVxuXG5jb25zdCBFdmVudCA9IHtcbiAgQ0xJQ0tfRElTTUlTUyA6IGBjbGljay5kaXNtaXNzJHtFVkVOVF9LRVl9YCxcbiAgSElERSAgICAgICAgICA6IGBoaWRlJHtFVkVOVF9LRVl9YCxcbiAgSElEREVOICAgICAgICA6IGBoaWRkZW4ke0VWRU5UX0tFWX1gLFxuICBTSE9XICAgICAgICAgIDogYHNob3cke0VWRU5UX0tFWX1gLFxuICBTSE9XTiAgICAgICAgIDogYHNob3duJHtFVkVOVF9LRVl9YFxufVxuXG5jb25zdCBDbGFzc05hbWUgPSB7XG4gIEZBREUgICAgOiAnZmFkZScsXG4gIEhJREUgICAgOiAnaGlkZScsXG4gIFNIT1cgICAgOiAnc2hvdycsXG4gIFNIT1dJTkcgOiAnc2hvd2luZydcbn1cblxuY29uc3QgRGVmYXVsdFR5cGUgPSB7XG4gIGFuaW1hdGlvbiA6ICdib29sZWFuJyxcbiAgYXV0b2hpZGUgIDogJ2Jvb2xlYW4nLFxuICBkZWxheSAgICAgOiAnbnVtYmVyJ1xufVxuXG5jb25zdCBEZWZhdWx0ID0ge1xuICBhbmltYXRpb24gOiB0cnVlLFxuICBhdXRvaGlkZSAgOiB0cnVlLFxuICBkZWxheSAgICAgOiA1MDBcbn1cblxuY29uc3QgU2VsZWN0b3IgPSB7XG4gIERBVEFfRElTTUlTUyA6ICdbZGF0YS1kaXNtaXNzPVwidG9hc3RcIl0nXG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDbGFzcyBEZWZpbml0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jbGFzcyBUb2FzdCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50XG4gICAgdGhpcy5fY29uZmlnICA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpXG4gICAgdGhpcy5fdGltZW91dCA9IG51bGxcbiAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoKVxuICB9XG5cbiAgLy8gR2V0dGVyc1xuXG4gIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICByZXR1cm4gVkVSU0lPTlxuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGVcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFxuICB9XG5cbiAgLy8gUHVibGljXG5cbiAgc2hvdygpIHtcbiAgICBjb25zdCBzaG93RXZlbnQgPSAkLkV2ZW50KEV2ZW50LlNIT1cpXG5cbiAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc2hvd0V2ZW50KVxuICAgIGlmIChzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb25maWcuYW5pbWF0aW9uKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ2xhc3NOYW1lLkZBREUpXG4gICAgfVxuXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ2xhc3NOYW1lLlNIT1dJTkcpXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ2xhc3NOYW1lLlNIT1cpXG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihFdmVudC5TSE9XTilcblxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5hdXRvaGlkZSkge1xuICAgICAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5oaWRlKClcbiAgICAgICAgfSwgdGhpcy5fY29uZmlnLmRlbGF5KVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDbGFzc05hbWUuSElERSlcbiAgICBVdGlsLnJlZmxvdyh0aGlzLl9lbGVtZW50KVxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDbGFzc05hbWUuU0hPV0lORylcbiAgICBpZiAodGhpcy5fY29uZmlnLmFuaW1hdGlvbikge1xuICAgICAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KVxuXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpXG4gICAgICAgIC5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBsZXRlKClcbiAgICB9XG4gIH1cblxuICBoaWRlKCkge1xuICAgIGlmICghdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ2xhc3NOYW1lLlNIT1cpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBoaWRlRXZlbnQgPSAkLkV2ZW50KEV2ZW50LkhJREUpXG5cbiAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoaGlkZUV2ZW50KVxuICAgIGlmIChoaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2Nsb3NlKClcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpXG4gICAgdGhpcy5fdGltZW91dCA9IG51bGxcblxuICAgIGlmICh0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDbGFzc05hbWUuU0hPVykpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDbGFzc05hbWUuU0hPVylcbiAgICB9XG5cbiAgICAkKHRoaXMuX2VsZW1lbnQpLm9mZihFdmVudC5DTElDS19ESVNNSVNTKVxuXG4gICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZKVxuICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsXG4gICAgdGhpcy5fY29uZmlnICA9IG51bGxcbiAgfVxuXG4gIC8vIFByaXZhdGVcblxuICBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgIGNvbmZpZyA9IHtcbiAgICAgIC4uLkRlZmF1bHQsXG4gICAgICAuLi4kKHRoaXMuX2VsZW1lbnQpLmRhdGEoKSxcbiAgICAgIC4uLnR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZyA/IGNvbmZpZyA6IHt9XG4gICAgfVxuXG4gICAgVXRpbC50eXBlQ2hlY2tDb25maWcoXG4gICAgICBOQU1FLFxuICAgICAgY29uZmlnLFxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZVxuICAgIClcblxuICAgIHJldHVybiBjb25maWdcbiAgfVxuXG4gIF9zZXRMaXN0ZW5lcnMoKSB7XG4gICAgJCh0aGlzLl9lbGVtZW50KS5vbihcbiAgICAgIEV2ZW50LkNMSUNLX0RJU01JU1MsXG4gICAgICBTZWxlY3Rvci5EQVRBX0RJU01JU1MsXG4gICAgICAoKSA9PiB0aGlzLmhpZGUoKVxuICAgIClcbiAgfVxuXG4gIF9jbG9zZSgpIHtcbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDbGFzc05hbWUuSElERSlcbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihFdmVudC5ISURERU4pXG4gICAgfVxuXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENsYXNzTmFtZS5TSE9XKVxuICAgIGlmICh0aGlzLl9jb25maWcuYW5pbWF0aW9uKSB7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpXG5cbiAgICAgICQodGhpcy5fZWxlbWVudClcbiAgICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSlcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcGxldGUoKVxuICAgIH1cbiAgfVxuXG4gIC8vIFN0YXRpY1xuXG4gIHN0YXRpYyBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgJGVsZW1lbnQgPSAkKHRoaXMpXG4gICAgICBsZXQgZGF0YSAgICAgICA9ICRlbGVtZW50LmRhdGEoREFUQV9LRVkpXG4gICAgICBjb25zdCBfY29uZmlnICA9IHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZ1xuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBUb2FzdCh0aGlzLCBfY29uZmlnKVxuICAgICAgICAkZWxlbWVudC5kYXRhKERBVEFfS0VZLCBkYXRhKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKVxuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVtjb25maWddKHRoaXMpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4kLmZuW05BTUVdICAgICAgICAgICAgID0gVG9hc3QuX2pRdWVyeUludGVyZmFjZVxuJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IFRvYXN0XG4kLmZuW05BTUVdLm5vQ29uZmxpY3QgID0gKCkgPT4ge1xuICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUXG4gIHJldHVybiBUb2FzdC5falF1ZXJ5SW50ZXJmYWNlXG59XG5cbmV4cG9ydCBkZWZhdWx0IFRvYXN0XG4iLCIvKipcbiAqIE93bCBDYXJvdXNlbCB2Mi4zLjRcbiAqIENvcHlyaWdodCAyMDEzLTIwMTggRGF2aWQgRGV1dHNjaFxuICogTGljZW5zZWQgdW5kZXI6IFNFRSBMSUNFTlNFIElOIGh0dHBzOi8vZ2l0aHViLmNvbS9Pd2xDYXJvdXNlbDIvT3dsQ2Fyb3VzZWwyL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuLyoqXG4gKiBPd2wgY2Fyb3VzZWxcbiAqIEB2ZXJzaW9uIDIuMy40XG4gKiBAYXV0aG9yIEJhcnRvc3ogV29qY2llY2hvd3NraVxuICogQGF1dGhvciBEYXZpZCBEZXV0c2NoXG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIEB0b2RvIExhenkgTG9hZCBJY29uXG4gKiBAdG9kbyBwcmV2ZW50IGFuaW1hdGlvbmVuZCBidWJsaW5nXG4gKiBAdG9kbyBpdGVtc1NjYWxlVXBcbiAqIEB0b2RvIFRlc3QgWmVwdG9cbiAqIEB0b2RvIHN0YWdlUGFkZGluZyBjYWxjdWxhdGUgd3JvbmcgYWN0aXZlIGNsYXNzZXNcbiAqL1xuOyhmdW5jdGlvbigkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIGNhcm91c2VsLlxuXHQgKiBAY2xhc3MgVGhlIE93bCBDYXJvdXNlbC5cblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fGpRdWVyeX0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIGNyZWF0ZSB0aGUgY2Fyb3VzZWwgZm9yLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnNcblx0ICovXG5cdGZ1bmN0aW9uIE93bChlbGVtZW50LCBvcHRpb25zKSB7XG5cblx0XHQvKipcblx0XHQgKiBDdXJyZW50IHNldHRpbmdzIGZvciB0aGUgY2Fyb3VzZWwuXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQ3VycmVudCBvcHRpb25zIHNldCBieSB0aGUgY2FsbGVyIGluY2x1ZGluZyBkZWZhdWx0cy5cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0dGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIE93bC5EZWZhdWx0cywgb3B0aW9ucyk7XG5cblx0XHQvKipcblx0XHQgKiBQbHVnaW4gZWxlbWVudC5cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0dGhpcy4kZWxlbWVudCA9ICQoZWxlbWVudCk7XG5cblx0XHQvKipcblx0XHQgKiBQcm94aWVkIGV2ZW50IGhhbmRsZXJzLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9oYW5kbGVycyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogUmVmZXJlbmNlcyB0byB0aGUgcnVubmluZyBwbHVnaW5zIG9mIHRoaXMgY2Fyb3VzZWwuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3BsdWdpbnMgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIEN1cnJlbnRseSBzdXBwcmVzc2VkIGV2ZW50cyB0byBwcmV2ZW50IHRoZW0gZnJvbSBiZWluZyByZXRyaWdnZXJlZC5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fc3VwcmVzcyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogQWJzb2x1dGUgY3VycmVudCBwb3NpdGlvbi5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fY3VycmVudCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBBbmltYXRpb24gc3BlZWQgaW4gbWlsbGlzZWNvbmRzLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9zcGVlZCA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBDb29yZGluYXRlcyBvZiBhbGwgaXRlbXMgaW4gcGl4ZWwuXG5cdFx0ICogQHRvZG8gVGhlIG5hbWUgb2YgdGhpcyBtZW1iZXIgaXMgbWlzc2xlYWRpbmcuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX2Nvb3JkaW5hdGVzID0gW107XG5cblx0XHQvKipcblx0XHQgKiBDdXJyZW50IGJyZWFrcG9pbnQuXG5cdFx0ICogQHRvZG8gUmVhbCBtZWRpYSBxdWVyaWVzIHdvdWxkIGJlIG5pY2UuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX2JyZWFrcG9pbnQgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQ3VycmVudCB3aWR0aCBvZiB0aGUgcGx1Z2luIGVsZW1lbnQuXG5cdFx0ICovXG5cdFx0dGhpcy5fd2lkdGggPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogQWxsIHJlYWwgaXRlbXMuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX2l0ZW1zID0gW107XG5cblx0XHQvKipcblx0XHQgKiBBbGwgY2xvbmVkIGl0ZW1zLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9jbG9uZXMgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIE1lcmdlIHZhbHVlcyBvZiBhbGwgaXRlbXMuXG5cdFx0ICogQHRvZG8gTWF5YmUgdGhpcyBjb3VsZCBiZSBwYXJ0IG9mIGEgcGx1Z2luLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHR0aGlzLl9tZXJnZXJzID0gW107XG5cblx0XHQvKipcblx0XHQgKiBXaWR0aHMgb2YgYWxsIGl0ZW1zLlxuXHRcdCAqL1xuXHRcdHRoaXMuX3dpZHRocyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogSW52YWxpZGF0ZWQgcGFydHMgd2l0aGluIHRoZSB1cGRhdGUgcHJvY2Vzcy5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5faW52YWxpZGF0ZWQgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIE9yZGVyZWQgbGlzdCBvZiB3b3JrZXJzIGZvciB0aGUgdXBkYXRlIHByb2Nlc3MuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX3BpcGUgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEN1cnJlbnQgc3RhdGUgaW5mb3JtYXRpb24gZm9yIHRoZSBkcmFnIG9wZXJhdGlvbi5cblx0XHQgKiBAdG9kbyAjMjYxXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdHRoaXMuX2RyYWcgPSB7XG5cdFx0XHR0aW1lOiBudWxsLFxuXHRcdFx0dGFyZ2V0OiBudWxsLFxuXHRcdFx0cG9pbnRlcjogbnVsbCxcblx0XHRcdHN0YWdlOiB7XG5cdFx0XHRcdHN0YXJ0OiBudWxsLFxuXHRcdFx0XHRjdXJyZW50OiBudWxsXG5cdFx0XHR9LFxuXHRcdFx0ZGlyZWN0aW9uOiBudWxsXG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEN1cnJlbnQgc3RhdGUgaW5mb3JtYXRpb24gYW5kIHRoZWlyIHRhZ3MuXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0dGhpcy5fc3RhdGVzID0ge1xuXHRcdFx0Y3VycmVudDoge30sXG5cdFx0XHR0YWdzOiB7XG5cdFx0XHRcdCdpbml0aWFsaXppbmcnOiBbICdidXN5JyBdLFxuXHRcdFx0XHQnYW5pbWF0aW5nJzogWyAnYnVzeScgXSxcblx0XHRcdFx0J2RyYWdnaW5nJzogWyAnaW50ZXJhY3RpbmcnIF1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0JC5lYWNoKFsgJ29uUmVzaXplJywgJ29uVGhyb3R0bGVkUmVzaXplJyBdLCAkLnByb3h5KGZ1bmN0aW9uKGksIGhhbmRsZXIpIHtcblx0XHRcdHRoaXMuX2hhbmRsZXJzW2hhbmRsZXJdID0gJC5wcm94eSh0aGlzW2hhbmRsZXJdLCB0aGlzKTtcblx0XHR9LCB0aGlzKSk7XG5cblx0XHQkLmVhY2goT3dsLlBsdWdpbnMsICQucHJveHkoZnVuY3Rpb24oa2V5LCBwbHVnaW4pIHtcblx0XHRcdHRoaXMuX3BsdWdpbnNba2V5LmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDEpXVxuXHRcdFx0XHQ9IG5ldyBwbHVnaW4odGhpcyk7XG5cdFx0fSwgdGhpcykpO1xuXG5cdFx0JC5lYWNoKE93bC5Xb3JrZXJzLCAkLnByb3h5KGZ1bmN0aW9uKHByaW9yaXR5LCB3b3JrZXIpIHtcblx0XHRcdHRoaXMuX3BpcGUucHVzaCh7XG5cdFx0XHRcdCdmaWx0ZXInOiB3b3JrZXIuZmlsdGVyLFxuXHRcdFx0XHQncnVuJzogJC5wcm94eSh3b3JrZXIucnVuLCB0aGlzKVxuXHRcdFx0fSk7XG5cdFx0fSwgdGhpcykpO1xuXG5cdFx0dGhpcy5zZXR1cCgpO1xuXHRcdHRoaXMuaW5pdGlhbGl6ZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERlZmF1bHQgb3B0aW9ucyBmb3IgdGhlIGNhcm91c2VsLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRPd2wuRGVmYXVsdHMgPSB7XG5cdFx0aXRlbXM6IDMsXG5cdFx0bG9vcDogZmFsc2UsXG5cdFx0Y2VudGVyOiBmYWxzZSxcblx0XHRyZXdpbmQ6IGZhbHNlLFxuXHRcdGNoZWNrVmlzaWJpbGl0eTogdHJ1ZSxcblxuXHRcdG1vdXNlRHJhZzogdHJ1ZSxcblx0XHR0b3VjaERyYWc6IHRydWUsXG5cdFx0cHVsbERyYWc6IHRydWUsXG5cdFx0ZnJlZURyYWc6IGZhbHNlLFxuXG5cdFx0bWFyZ2luOiAwLFxuXHRcdHN0YWdlUGFkZGluZzogMCxcblxuXHRcdG1lcmdlOiBmYWxzZSxcblx0XHRtZXJnZUZpdDogdHJ1ZSxcblx0XHRhdXRvV2lkdGg6IGZhbHNlLFxuXG5cdFx0c3RhcnRQb3NpdGlvbjogMCxcblx0XHRydGw6IGZhbHNlLFxuXG5cdFx0c21hcnRTcGVlZDogMjUwLFxuXHRcdGZsdWlkU3BlZWQ6IGZhbHNlLFxuXHRcdGRyYWdFbmRTcGVlZDogZmFsc2UsXG5cblx0XHRyZXNwb25zaXZlOiB7fSxcblx0XHRyZXNwb25zaXZlUmVmcmVzaFJhdGU6IDIwMCxcblx0XHRyZXNwb25zaXZlQmFzZUVsZW1lbnQ6IHdpbmRvdyxcblxuXHRcdGZhbGxiYWNrRWFzaW5nOiAnc3dpbmcnLFxuXHRcdHNsaWRlVHJhbnNpdGlvbjogJycsXG5cblx0XHRpbmZvOiBmYWxzZSxcblxuXHRcdG5lc3RlZEl0ZW1TZWxlY3RvcjogZmFsc2UsXG5cdFx0aXRlbUVsZW1lbnQ6ICdkaXYnLFxuXHRcdHN0YWdlRWxlbWVudDogJ2RpdicsXG5cblx0XHRyZWZyZXNoQ2xhc3M6ICdvd2wtcmVmcmVzaCcsXG5cdFx0bG9hZGVkQ2xhc3M6ICdvd2wtbG9hZGVkJyxcblx0XHRsb2FkaW5nQ2xhc3M6ICdvd2wtbG9hZGluZycsXG5cdFx0cnRsQ2xhc3M6ICdvd2wtcnRsJyxcblx0XHRyZXNwb25zaXZlQ2xhc3M6ICdvd2wtcmVzcG9uc2l2ZScsXG5cdFx0ZHJhZ0NsYXNzOiAnb3dsLWRyYWcnLFxuXHRcdGl0ZW1DbGFzczogJ293bC1pdGVtJyxcblx0XHRzdGFnZUNsYXNzOiAnb3dsLXN0YWdlJyxcblx0XHRzdGFnZU91dGVyQ2xhc3M6ICdvd2wtc3RhZ2Utb3V0ZXInLFxuXHRcdGdyYWJDbGFzczogJ293bC1ncmFiJ1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbnVtZXJhdGlvbiBmb3Igd2lkdGguXG5cdCAqIEBwdWJsaWNcblx0ICogQHJlYWRvbmx5XG5cdCAqIEBlbnVtIHtTdHJpbmd9XG5cdCAqL1xuXHRPd2wuV2lkdGggPSB7XG5cdFx0RGVmYXVsdDogJ2RlZmF1bHQnLFxuXHRcdElubmVyOiAnaW5uZXInLFxuXHRcdE91dGVyOiAnb3V0ZXInXG5cdH07XG5cblx0LyoqXG5cdCAqIEVudW1lcmF0aW9uIGZvciB0eXBlcy5cblx0ICogQHB1YmxpY1xuXHQgKiBAcmVhZG9ubHlcblx0ICogQGVudW0ge1N0cmluZ31cblx0ICovXG5cdE93bC5UeXBlID0ge1xuXHRcdEV2ZW50OiAnZXZlbnQnLFxuXHRcdFN0YXRlOiAnc3RhdGUnXG5cdH07XG5cblx0LyoqXG5cdCAqIENvbnRhaW5zIGFsbCByZWdpc3RlcmVkIHBsdWdpbnMuXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdE93bC5QbHVnaW5zID0ge307XG5cblx0LyoqXG5cdCAqIExpc3Qgb2Ygd29ya2VycyBpbnZvbHZlZCBpbiB0aGUgdXBkYXRlIHByb2Nlc3MuXG5cdCAqL1xuXHRPd2wuV29ya2VycyA9IFsge1xuXHRcdGZpbHRlcjogWyAnd2lkdGgnLCAnc2V0dGluZ3MnIF0sXG5cdFx0cnVuOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX3dpZHRoID0gdGhpcy4kZWxlbWVudC53aWR0aCgpO1xuXHRcdH1cblx0fSwge1xuXHRcdGZpbHRlcjogWyAnd2lkdGgnLCAnaXRlbXMnLCAnc2V0dGluZ3MnIF0sXG5cdFx0cnVuOiBmdW5jdGlvbihjYWNoZSkge1xuXHRcdFx0Y2FjaGUuY3VycmVudCA9IHRoaXMuX2l0ZW1zICYmIHRoaXMuX2l0ZW1zW3RoaXMucmVsYXRpdmUodGhpcy5fY3VycmVudCldO1xuXHRcdH1cblx0fSwge1xuXHRcdGZpbHRlcjogWyAnaXRlbXMnLCAnc2V0dGluZ3MnIF0sXG5cdFx0cnVuOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuJHN0YWdlLmNoaWxkcmVuKCcuY2xvbmVkJykucmVtb3ZlKCk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0ZmlsdGVyOiBbICd3aWR0aCcsICdpdGVtcycsICdzZXR0aW5ncycgXSxcblx0XHRydW46IGZ1bmN0aW9uKGNhY2hlKSB7XG5cdFx0XHR2YXIgbWFyZ2luID0gdGhpcy5zZXR0aW5ncy5tYXJnaW4gfHwgJycsXG5cdFx0XHRcdGdyaWQgPSAhdGhpcy5zZXR0aW5ncy5hdXRvV2lkdGgsXG5cdFx0XHRcdHJ0bCA9IHRoaXMuc2V0dGluZ3MucnRsLFxuXHRcdFx0XHRjc3MgPSB7XG5cdFx0XHRcdFx0J3dpZHRoJzogJ2F1dG8nLFxuXHRcdFx0XHRcdCdtYXJnaW4tbGVmdCc6IHJ0bCA/IG1hcmdpbiA6ICcnLFxuXHRcdFx0XHRcdCdtYXJnaW4tcmlnaHQnOiBydGwgPyAnJyA6IG1hcmdpblxuXHRcdFx0XHR9O1xuXG5cdFx0XHQhZ3JpZCAmJiB0aGlzLiRzdGFnZS5jaGlsZHJlbigpLmNzcyhjc3MpO1xuXG5cdFx0XHRjYWNoZS5jc3MgPSBjc3M7XG5cdFx0fVxuXHR9LCB7XG5cdFx0ZmlsdGVyOiBbICd3aWR0aCcsICdpdGVtcycsICdzZXR0aW5ncycgXSxcblx0XHRydW46IGZ1bmN0aW9uKGNhY2hlKSB7XG5cdFx0XHR2YXIgd2lkdGggPSAodGhpcy53aWR0aCgpIC8gdGhpcy5zZXR0aW5ncy5pdGVtcykudG9GaXhlZCgzKSAtIHRoaXMuc2V0dGluZ3MubWFyZ2luLFxuXHRcdFx0XHRtZXJnZSA9IG51bGwsXG5cdFx0XHRcdGl0ZXJhdG9yID0gdGhpcy5faXRlbXMubGVuZ3RoLFxuXHRcdFx0XHRncmlkID0gIXRoaXMuc2V0dGluZ3MuYXV0b1dpZHRoLFxuXHRcdFx0XHR3aWR0aHMgPSBbXTtcblxuXHRcdFx0Y2FjaGUuaXRlbXMgPSB7XG5cdFx0XHRcdG1lcmdlOiBmYWxzZSxcblx0XHRcdFx0d2lkdGg6IHdpZHRoXG5cdFx0XHR9O1xuXG5cdFx0XHR3aGlsZSAoaXRlcmF0b3ItLSkge1xuXHRcdFx0XHRtZXJnZSA9IHRoaXMuX21lcmdlcnNbaXRlcmF0b3JdO1xuXHRcdFx0XHRtZXJnZSA9IHRoaXMuc2V0dGluZ3MubWVyZ2VGaXQgJiYgTWF0aC5taW4obWVyZ2UsIHRoaXMuc2V0dGluZ3MuaXRlbXMpIHx8IG1lcmdlO1xuXG5cdFx0XHRcdGNhY2hlLml0ZW1zLm1lcmdlID0gbWVyZ2UgPiAxIHx8IGNhY2hlLml0ZW1zLm1lcmdlO1xuXG5cdFx0XHRcdHdpZHRoc1tpdGVyYXRvcl0gPSAhZ3JpZCA/IHRoaXMuX2l0ZW1zW2l0ZXJhdG9yXS53aWR0aCgpIDogd2lkdGggKiBtZXJnZTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fd2lkdGhzID0gd2lkdGhzO1xuXHRcdH1cblx0fSwge1xuXHRcdGZpbHRlcjogWyAnaXRlbXMnLCAnc2V0dGluZ3MnIF0sXG5cdFx0cnVuOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbG9uZXMgPSBbXSxcblx0XHRcdFx0aXRlbXMgPSB0aGlzLl9pdGVtcyxcblx0XHRcdFx0c2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzLFxuXHRcdFx0XHQvLyBUT0RPOiBTaG91bGQgYmUgY29tcHV0ZWQgZnJvbSBudW1iZXIgb2YgbWluIHdpZHRoIGl0ZW1zIGluIHN0YWdlXG5cdFx0XHRcdHZpZXcgPSBNYXRoLm1heChzZXR0aW5ncy5pdGVtcyAqIDIsIDQpLFxuXHRcdFx0XHRzaXplID0gTWF0aC5jZWlsKGl0ZW1zLmxlbmd0aCAvIDIpICogMixcblx0XHRcdFx0cmVwZWF0ID0gc2V0dGluZ3MubG9vcCAmJiBpdGVtcy5sZW5ndGggPyBzZXR0aW5ncy5yZXdpbmQgPyB2aWV3IDogTWF0aC5tYXgodmlldywgc2l6ZSkgOiAwLFxuXHRcdFx0XHRhcHBlbmQgPSAnJyxcblx0XHRcdFx0cHJlcGVuZCA9ICcnO1xuXG5cdFx0XHRyZXBlYXQgLz0gMjtcblxuXHRcdFx0d2hpbGUgKHJlcGVhdCA+IDApIHtcblx0XHRcdFx0Ly8gU3dpdGNoIHRvIG9ubHkgdXNpbmcgYXBwZW5kZWQgY2xvbmVzXG5cdFx0XHRcdGNsb25lcy5wdXNoKHRoaXMubm9ybWFsaXplKGNsb25lcy5sZW5ndGggLyAyLCB0cnVlKSk7XG5cdFx0XHRcdGFwcGVuZCA9IGFwcGVuZCArIGl0ZW1zW2Nsb25lc1tjbG9uZXMubGVuZ3RoIC0gMV1dWzBdLm91dGVySFRNTDtcblx0XHRcdFx0Y2xvbmVzLnB1c2godGhpcy5ub3JtYWxpemUoaXRlbXMubGVuZ3RoIC0gMSAtIChjbG9uZXMubGVuZ3RoIC0gMSkgLyAyLCB0cnVlKSk7XG5cdFx0XHRcdHByZXBlbmQgPSBpdGVtc1tjbG9uZXNbY2xvbmVzLmxlbmd0aCAtIDFdXVswXS5vdXRlckhUTUwgKyBwcmVwZW5kO1xuXHRcdFx0XHRyZXBlYXQgLT0gMTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fY2xvbmVzID0gY2xvbmVzO1xuXG5cdFx0XHQkKGFwcGVuZCkuYWRkQ2xhc3MoJ2Nsb25lZCcpLmFwcGVuZFRvKHRoaXMuJHN0YWdlKTtcblx0XHRcdCQocHJlcGVuZCkuYWRkQ2xhc3MoJ2Nsb25lZCcpLnByZXBlbmRUbyh0aGlzLiRzdGFnZSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0ZmlsdGVyOiBbICd3aWR0aCcsICdpdGVtcycsICdzZXR0aW5ncycgXSxcblx0XHRydW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHJ0bCA9IHRoaXMuc2V0dGluZ3MucnRsID8gMSA6IC0xLFxuXHRcdFx0XHRzaXplID0gdGhpcy5fY2xvbmVzLmxlbmd0aCArIHRoaXMuX2l0ZW1zLmxlbmd0aCxcblx0XHRcdFx0aXRlcmF0b3IgPSAtMSxcblx0XHRcdFx0cHJldmlvdXMgPSAwLFxuXHRcdFx0XHRjdXJyZW50ID0gMCxcblx0XHRcdFx0Y29vcmRpbmF0ZXMgPSBbXTtcblxuXHRcdFx0d2hpbGUgKCsraXRlcmF0b3IgPCBzaXplKSB7XG5cdFx0XHRcdHByZXZpb3VzID0gY29vcmRpbmF0ZXNbaXRlcmF0b3IgLSAxXSB8fCAwO1xuXHRcdFx0XHRjdXJyZW50ID0gdGhpcy5fd2lkdGhzW3RoaXMucmVsYXRpdmUoaXRlcmF0b3IpXSArIHRoaXMuc2V0dGluZ3MubWFyZ2luO1xuXHRcdFx0XHRjb29yZGluYXRlcy5wdXNoKHByZXZpb3VzICsgY3VycmVudCAqIHJ0bCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2Nvb3JkaW5hdGVzID0gY29vcmRpbmF0ZXM7XG5cdFx0fVxuXHR9LCB7XG5cdFx0ZmlsdGVyOiBbICd3aWR0aCcsICdpdGVtcycsICdzZXR0aW5ncycgXSxcblx0XHRydW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHBhZGRpbmcgPSB0aGlzLnNldHRpbmdzLnN0YWdlUGFkZGluZyxcblx0XHRcdFx0Y29vcmRpbmF0ZXMgPSB0aGlzLl9jb29yZGluYXRlcyxcblx0XHRcdFx0Y3NzID0ge1xuXHRcdFx0XHRcdCd3aWR0aCc6IE1hdGguY2VpbChNYXRoLmFicyhjb29yZGluYXRlc1tjb29yZGluYXRlcy5sZW5ndGggLSAxXSkpICsgcGFkZGluZyAqIDIsXG5cdFx0XHRcdFx0J3BhZGRpbmctbGVmdCc6IHBhZGRpbmcgfHwgJycsXG5cdFx0XHRcdFx0J3BhZGRpbmctcmlnaHQnOiBwYWRkaW5nIHx8ICcnXG5cdFx0XHRcdH07XG5cblx0XHRcdHRoaXMuJHN0YWdlLmNzcyhjc3MpO1xuXHRcdH1cblx0fSwge1xuXHRcdGZpbHRlcjogWyAnd2lkdGgnLCAnaXRlbXMnLCAnc2V0dGluZ3MnIF0sXG5cdFx0cnVuOiBmdW5jdGlvbihjYWNoZSkge1xuXHRcdFx0dmFyIGl0ZXJhdG9yID0gdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoLFxuXHRcdFx0XHRncmlkID0gIXRoaXMuc2V0dGluZ3MuYXV0b1dpZHRoLFxuXHRcdFx0XHRpdGVtcyA9IHRoaXMuJHN0YWdlLmNoaWxkcmVuKCk7XG5cblx0XHRcdGlmIChncmlkICYmIGNhY2hlLml0ZW1zLm1lcmdlKSB7XG5cdFx0XHRcdHdoaWxlIChpdGVyYXRvci0tKSB7XG5cdFx0XHRcdFx0Y2FjaGUuY3NzLndpZHRoID0gdGhpcy5fd2lkdGhzW3RoaXMucmVsYXRpdmUoaXRlcmF0b3IpXTtcblx0XHRcdFx0XHRpdGVtcy5lcShpdGVyYXRvcikuY3NzKGNhY2hlLmNzcyk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoZ3JpZCkge1xuXHRcdFx0XHRjYWNoZS5jc3Mud2lkdGggPSBjYWNoZS5pdGVtcy53aWR0aDtcblx0XHRcdFx0aXRlbXMuY3NzKGNhY2hlLmNzcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LCB7XG5cdFx0ZmlsdGVyOiBbICdpdGVtcycgXSxcblx0XHRydW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoIDwgMSAmJiB0aGlzLiRzdGFnZS5yZW1vdmVBdHRyKCdzdHlsZScpO1xuXHRcdH1cblx0fSwge1xuXHRcdGZpbHRlcjogWyAnd2lkdGgnLCAnaXRlbXMnLCAnc2V0dGluZ3MnIF0sXG5cdFx0cnVuOiBmdW5jdGlvbihjYWNoZSkge1xuXHRcdFx0Y2FjaGUuY3VycmVudCA9IGNhY2hlLmN1cnJlbnQgPyB0aGlzLiRzdGFnZS5jaGlsZHJlbigpLmluZGV4KGNhY2hlLmN1cnJlbnQpIDogMDtcblx0XHRcdGNhY2hlLmN1cnJlbnQgPSBNYXRoLm1heCh0aGlzLm1pbmltdW0oKSwgTWF0aC5taW4odGhpcy5tYXhpbXVtKCksIGNhY2hlLmN1cnJlbnQpKTtcblx0XHRcdHRoaXMucmVzZXQoY2FjaGUuY3VycmVudCk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0ZmlsdGVyOiBbICdwb3NpdGlvbicgXSxcblx0XHRydW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5hbmltYXRlKHRoaXMuY29vcmRpbmF0ZXModGhpcy5fY3VycmVudCkpO1xuXHRcdH1cblx0fSwge1xuXHRcdGZpbHRlcjogWyAnd2lkdGgnLCAncG9zaXRpb24nLCAnaXRlbXMnLCAnc2V0dGluZ3MnIF0sXG5cdFx0cnVuOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBydGwgPSB0aGlzLnNldHRpbmdzLnJ0bCA/IDEgOiAtMSxcblx0XHRcdFx0cGFkZGluZyA9IHRoaXMuc2V0dGluZ3Muc3RhZ2VQYWRkaW5nICogMixcblx0XHRcdFx0YmVnaW4gPSB0aGlzLmNvb3JkaW5hdGVzKHRoaXMuY3VycmVudCgpKSArIHBhZGRpbmcsXG5cdFx0XHRcdGVuZCA9IGJlZ2luICsgdGhpcy53aWR0aCgpICogcnRsLFxuXHRcdFx0XHRpbm5lciwgb3V0ZXIsIG1hdGNoZXMgPSBbXSwgaSwgbjtcblxuXHRcdFx0Zm9yIChpID0gMCwgbiA9IHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHRpbm5lciA9IHRoaXMuX2Nvb3JkaW5hdGVzW2kgLSAxXSB8fCAwO1xuXHRcdFx0XHRvdXRlciA9IE1hdGguYWJzKHRoaXMuX2Nvb3JkaW5hdGVzW2ldKSArIHBhZGRpbmcgKiBydGw7XG5cblx0XHRcdFx0aWYgKCh0aGlzLm9wKGlubmVyLCAnPD0nLCBiZWdpbikgJiYgKHRoaXMub3AoaW5uZXIsICc+JywgZW5kKSkpXG5cdFx0XHRcdFx0fHwgKHRoaXMub3Aob3V0ZXIsICc8JywgYmVnaW4pICYmIHRoaXMub3Aob3V0ZXIsICc+JywgZW5kKSkpIHtcblx0XHRcdFx0XHRtYXRjaGVzLnB1c2goaSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy4kc3RhZ2UuY2hpbGRyZW4oJy5hY3RpdmUnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG5cdFx0XHR0aGlzLiRzdGFnZS5jaGlsZHJlbignOmVxKCcgKyBtYXRjaGVzLmpvaW4oJyksIDplcSgnKSArICcpJykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuXG5cdFx0XHR0aGlzLiRzdGFnZS5jaGlsZHJlbignLmNlbnRlcicpLnJlbW92ZUNsYXNzKCdjZW50ZXInKTtcblx0XHRcdGlmICh0aGlzLnNldHRpbmdzLmNlbnRlcikge1xuXHRcdFx0XHR0aGlzLiRzdGFnZS5jaGlsZHJlbigpLmVxKHRoaXMuY3VycmVudCgpKS5hZGRDbGFzcygnY2VudGVyJyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IF07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSB0aGUgc3RhZ2UgRE9NIGVsZW1lbnRcblx0ICovXG5cdE93bC5wcm90b3R5cGUuaW5pdGlhbGl6ZVN0YWdlID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy4kc3RhZ2UgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy4nICsgdGhpcy5zZXR0aW5ncy5zdGFnZUNsYXNzKTtcblxuXHRcdC8vIGlmIHRoZSBzdGFnZSBpcyBhbHJlYWR5IGluIHRoZSBET00sIGdyYWIgaXQgYW5kIHNraXAgc3RhZ2UgaW5pdGlhbGl6YXRpb25cblx0XHRpZiAodGhpcy4kc3RhZ2UubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMubG9hZGluZ0NsYXNzKTtcblxuXHRcdC8vIGNyZWF0ZSBzdGFnZVxuXHRcdHRoaXMuJHN0YWdlID0gJCgnPCcgKyB0aGlzLnNldHRpbmdzLnN0YWdlRWxlbWVudCArICc+Jywge1xuXHRcdFx0XCJjbGFzc1wiOiB0aGlzLnNldHRpbmdzLnN0YWdlQ2xhc3Ncblx0XHR9KS53cmFwKCAkKCAnPGRpdi8+Jywge1xuXHRcdFx0XCJjbGFzc1wiOiB0aGlzLnNldHRpbmdzLnN0YWdlT3V0ZXJDbGFzc1xuXHRcdH0pKTtcblxuXHRcdC8vIGFwcGVuZCBzdGFnZVxuXHRcdHRoaXMuJGVsZW1lbnQuYXBwZW5kKHRoaXMuJHN0YWdlLnBhcmVudCgpKTtcblx0fTtcblxuXHQvKipcblx0ICogQ3JlYXRlIGl0ZW0gRE9NIGVsZW1lbnRzXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLmluaXRpYWxpemVJdGVtcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciAkaXRlbXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5vd2wtaXRlbScpO1xuXG5cdFx0Ly8gaWYgdGhlIGl0ZW1zIGFyZSBhbHJlYWR5IGluIHRoZSBET00sIGdyYWIgdGhlbSBhbmQgc2tpcCBpdGVtIGluaXRpYWxpemF0aW9uXG5cdFx0aWYgKCRpdGVtcy5sZW5ndGgpIHtcblx0XHRcdHRoaXMuX2l0ZW1zID0gJGl0ZW1zLmdldCgpLm1hcChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdHJldHVybiAkKGl0ZW0pO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuX21lcmdlcnMgPSB0aGlzLl9pdGVtcy5tYXAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMucmVmcmVzaCgpO1xuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gYXBwZW5kIGNvbnRlbnRcblx0XHR0aGlzLnJlcGxhY2UodGhpcy4kZWxlbWVudC5jaGlsZHJlbigpLm5vdCh0aGlzLiRzdGFnZS5wYXJlbnQoKSkpO1xuXG5cdFx0Ly8gY2hlY2sgdmlzaWJpbGl0eVxuXHRcdGlmICh0aGlzLmlzVmlzaWJsZSgpKSB7XG5cdFx0XHQvLyB1cGRhdGUgdmlld1xuXHRcdFx0dGhpcy5yZWZyZXNoKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGludmFsaWRhdGUgd2lkdGhcblx0XHRcdHRoaXMuaW52YWxpZGF0ZSgnd2lkdGgnKTtcblx0XHR9XG5cblx0XHR0aGlzLiRlbGVtZW50XG5cdFx0XHQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmxvYWRpbmdDbGFzcylcblx0XHRcdC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMubG9hZGVkQ2xhc3MpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyB0aGUgY2Fyb3VzZWwuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdE93bC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZW50ZXIoJ2luaXRpYWxpemluZycpO1xuXHRcdHRoaXMudHJpZ2dlcignaW5pdGlhbGl6ZScpO1xuXG5cdFx0dGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyh0aGlzLnNldHRpbmdzLnJ0bENsYXNzLCB0aGlzLnNldHRpbmdzLnJ0bCk7XG5cblx0XHRpZiAodGhpcy5zZXR0aW5ncy5hdXRvV2lkdGggJiYgIXRoaXMuaXMoJ3ByZS1sb2FkaW5nJykpIHtcblx0XHRcdHZhciBpbWdzLCBuZXN0ZWRTZWxlY3Rvciwgd2lkdGg7XG5cdFx0XHRpbWdzID0gdGhpcy4kZWxlbWVudC5maW5kKCdpbWcnKTtcblx0XHRcdG5lc3RlZFNlbGVjdG9yID0gdGhpcy5zZXR0aW5ncy5uZXN0ZWRJdGVtU2VsZWN0b3IgPyAnLicgKyB0aGlzLnNldHRpbmdzLm5lc3RlZEl0ZW1TZWxlY3RvciA6IHVuZGVmaW5lZDtcblx0XHRcdHdpZHRoID0gdGhpcy4kZWxlbWVudC5jaGlsZHJlbihuZXN0ZWRTZWxlY3Rvcikud2lkdGgoKTtcblxuXHRcdFx0aWYgKGltZ3MubGVuZ3RoICYmIHdpZHRoIDw9IDApIHtcblx0XHRcdFx0dGhpcy5wcmVsb2FkQXV0b1dpZHRoSW1hZ2VzKGltZ3MpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuaW5pdGlhbGl6ZVN0YWdlKCk7XG5cdFx0dGhpcy5pbml0aWFsaXplSXRlbXMoKTtcblxuXHRcdC8vIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzXG5cdFx0dGhpcy5yZWdpc3RlckV2ZW50SGFuZGxlcnMoKTtcblxuXHRcdHRoaXMubGVhdmUoJ2luaXRpYWxpemluZycpO1xuXHRcdHRoaXMudHJpZ2dlcignaW5pdGlhbGl6ZWQnKTtcblx0fTtcblxuXHQvKipcblx0ICogQHJldHVybnMge0Jvb2xlYW59IHZpc2liaWxpdHkgb2YgJGVsZW1lbnRcblx0ICogICAgICAgICAgICAgICAgICAgIGlmIHlvdSBrbm93IHRoZSBjYXJvdXNlbCB3aWxsIGFsd2F5cyBiZSB2aXNpYmxlIHlvdSBjYW4gc2V0IGBjaGVja1Zpc2liaWxpdHlgIHRvIGBmYWxzZWAgdG9cblx0ICogICAgICAgICAgICAgICAgICAgIHByZXZlbnQgdGhlIGV4cGVuc2l2ZSBicm93c2VyIGxheW91dCBmb3JjZWQgcmVmbG93IHRoZSAkZWxlbWVudC5pcygnOnZpc2libGUnKSBkb2VzXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnNldHRpbmdzLmNoZWNrVmlzaWJpbGl0eVxuXHRcdFx0PyB0aGlzLiRlbGVtZW50LmlzKCc6dmlzaWJsZScpXG5cdFx0XHQ6IHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHVwcyB0aGUgY3VycmVudCBzZXR0aW5ncy5cblx0ICogQHRvZG8gUmVtb3ZlIHJlc3BvbnNpdmUgY2xhc3Nlcy4gV2h5IHNob3VsZCBhZGFwdGl2ZSBkZXNpZ25zIGJlIGJyb3VnaHQgaW50byBJRTg/XG5cdCAqIEB0b2RvIFN1cHBvcnQgZm9yIG1lZGlhIHF1ZXJpZXMgYnkgdXNpbmcgYG1hdGNoTWVkaWFgIHdvdWxkIGJlIG5pY2UuXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdE93bC5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmlld3BvcnQgPSB0aGlzLnZpZXdwb3J0KCksXG5cdFx0XHRvdmVyd3JpdGVzID0gdGhpcy5vcHRpb25zLnJlc3BvbnNpdmUsXG5cdFx0XHRtYXRjaCA9IC0xLFxuXHRcdFx0c2V0dGluZ3MgPSBudWxsO1xuXG5cdFx0aWYgKCFvdmVyd3JpdGVzKSB7XG5cdFx0XHRzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQkLmVhY2gob3ZlcndyaXRlcywgZnVuY3Rpb24oYnJlYWtwb2ludCkge1xuXHRcdFx0XHRpZiAoYnJlYWtwb2ludCA8PSB2aWV3cG9ydCAmJiBicmVha3BvaW50ID4gbWF0Y2gpIHtcblx0XHRcdFx0XHRtYXRjaCA9IE51bWJlcihicmVha3BvaW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHNldHRpbmdzID0gJC5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgb3ZlcndyaXRlc1ttYXRjaF0pO1xuXHRcdFx0aWYgKHR5cGVvZiBzZXR0aW5ncy5zdGFnZVBhZGRpbmcgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0c2V0dGluZ3Muc3RhZ2VQYWRkaW5nID0gc2V0dGluZ3Muc3RhZ2VQYWRkaW5nKCk7XG5cdFx0XHR9XG5cdFx0XHRkZWxldGUgc2V0dGluZ3MucmVzcG9uc2l2ZTtcblxuXHRcdFx0Ly8gcmVzcG9uc2l2ZSBjbGFzc1xuXHRcdFx0aWYgKHNldHRpbmdzLnJlc3BvbnNpdmVDbGFzcykge1xuXHRcdFx0XHR0aGlzLiRlbGVtZW50LmF0dHIoJ2NsYXNzJyxcblx0XHRcdFx0XHR0aGlzLiRlbGVtZW50LmF0dHIoJ2NsYXNzJykucmVwbGFjZShuZXcgUmVnRXhwKCcoJyArIHRoaXMub3B0aW9ucy5yZXNwb25zaXZlQ2xhc3MgKyAnLSlcXFxcUytcXFxccycsICdnJyksICckMScgKyBtYXRjaClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIHsgcHJvcGVydHk6IHsgbmFtZTogJ3NldHRpbmdzJywgdmFsdWU6IHNldHRpbmdzIH0gfSk7XG5cdFx0dGhpcy5fYnJlYWtwb2ludCA9IG1hdGNoO1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcblx0XHR0aGlzLmludmFsaWRhdGUoJ3NldHRpbmdzJyk7XG5cdFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyBwcm9wZXJ0eTogeyBuYW1lOiAnc2V0dGluZ3MnLCB2YWx1ZTogdGhpcy5zZXR0aW5ncyB9IH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIG9wdGlvbiBsb2dpYyBpZiBuZWNlc3NlcnkuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdE93bC5wcm90b3R5cGUub3B0aW9uc0xvZ2ljID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuc2V0dGluZ3MuYXV0b1dpZHRoKSB7XG5cdFx0XHR0aGlzLnNldHRpbmdzLnN0YWdlUGFkZGluZyA9IGZhbHNlO1xuXHRcdFx0dGhpcy5zZXR0aW5ncy5tZXJnZSA9IGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUHJlcGFyZXMgYW4gaXRlbSBiZWZvcmUgYWRkLlxuXHQgKiBAdG9kbyBSZW5hbWUgZXZlbnQgcGFyYW1ldGVyIGBjb250ZW50YCB0byBgaXRlbWAuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybnMge2pRdWVyeXxIVE1MRWxlbWVudH0gLSBUaGUgaXRlbSBjb250YWluZXIuXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLnByZXBhcmUgPSBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIGV2ZW50ID0gdGhpcy50cmlnZ2VyKCdwcmVwYXJlJywgeyBjb250ZW50OiBpdGVtIH0pO1xuXG5cdFx0aWYgKCFldmVudC5kYXRhKSB7XG5cdFx0XHRldmVudC5kYXRhID0gJCgnPCcgKyB0aGlzLnNldHRpbmdzLml0ZW1FbGVtZW50ICsgJy8+Jylcblx0XHRcdFx0LmFkZENsYXNzKHRoaXMub3B0aW9ucy5pdGVtQ2xhc3MpLmFwcGVuZChpdGVtKVxuXHRcdH1cblxuXHRcdHRoaXMudHJpZ2dlcigncHJlcGFyZWQnLCB7IGNvbnRlbnQ6IGV2ZW50LmRhdGEgfSk7XG5cblx0XHRyZXR1cm4gZXZlbnQuZGF0YTtcblx0fTtcblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgdmlldy5cblx0ICogQHB1YmxpY1xuXHQgKi9cblx0T3dsLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRuID0gdGhpcy5fcGlwZS5sZW5ndGgsXG5cdFx0XHRmaWx0ZXIgPSAkLnByb3h5KGZ1bmN0aW9uKHApIHsgcmV0dXJuIHRoaXNbcF0gfSwgdGhpcy5faW52YWxpZGF0ZWQpLFxuXHRcdFx0Y2FjaGUgPSB7fTtcblxuXHRcdHdoaWxlIChpIDwgbikge1xuXHRcdFx0aWYgKHRoaXMuX2ludmFsaWRhdGVkLmFsbCB8fCAkLmdyZXAodGhpcy5fcGlwZVtpXS5maWx0ZXIsIGZpbHRlcikubGVuZ3RoID4gMCkge1xuXHRcdFx0XHR0aGlzLl9waXBlW2ldLnJ1bihjYWNoZSk7XG5cdFx0XHR9XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0dGhpcy5faW52YWxpZGF0ZWQgPSB7fTtcblxuXHRcdCF0aGlzLmlzKCd2YWxpZCcpICYmIHRoaXMuZW50ZXIoJ3ZhbGlkJyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHdpZHRoIG9mIHRoZSB2aWV3LlxuXHQgKiBAcHVibGljXG5cdCAqIEBwYXJhbSB7T3dsLldpZHRofSBbZGltZW5zaW9uPU93bC5XaWR0aC5EZWZhdWx0XSAtIFRoZSBkaW1lbnNpb24gdG8gcmV0dXJuLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSAtIFRoZSB3aWR0aCBvZiB0aGUgdmlldyBpbiBwaXhlbC5cblx0ICovXG5cdE93bC5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbihkaW1lbnNpb24pIHtcblx0XHRkaW1lbnNpb24gPSBkaW1lbnNpb24gfHwgT3dsLldpZHRoLkRlZmF1bHQ7XG5cdFx0c3dpdGNoIChkaW1lbnNpb24pIHtcblx0XHRcdGNhc2UgT3dsLldpZHRoLklubmVyOlxuXHRcdFx0Y2FzZSBPd2wuV2lkdGguT3V0ZXI6XG5cdFx0XHRcdHJldHVybiB0aGlzLl93aWR0aDtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiB0aGlzLl93aWR0aCAtIHRoaXMuc2V0dGluZ3Muc3RhZ2VQYWRkaW5nICogMiArIHRoaXMuc2V0dGluZ3MubWFyZ2luO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUmVmcmVzaGVzIHRoZSBjYXJvdXNlbCBwcmltYXJpbHkgZm9yIGFkYXB0aXZlIHB1cnBvc2VzLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmVudGVyKCdyZWZyZXNoaW5nJyk7XG5cdFx0dGhpcy50cmlnZ2VyKCdyZWZyZXNoJyk7XG5cblx0XHR0aGlzLnNldHVwKCk7XG5cblx0XHR0aGlzLm9wdGlvbnNMb2dpYygpO1xuXG5cdFx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMucmVmcmVzaENsYXNzKTtcblxuXHRcdHRoaXMudXBkYXRlKCk7XG5cblx0XHR0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5yZWZyZXNoQ2xhc3MpO1xuXG5cdFx0dGhpcy5sZWF2ZSgncmVmcmVzaGluZycpO1xuXHRcdHRoaXMudHJpZ2dlcigncmVmcmVzaGVkJyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrcyB3aW5kb3cgYHJlc2l6ZWAgZXZlbnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdE93bC5wcm90b3R5cGUub25UaHJvdHRsZWRSZXNpemUgPSBmdW5jdGlvbigpIHtcblx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZXIpO1xuXHRcdHRoaXMucmVzaXplVGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLl9oYW5kbGVycy5vblJlc2l6ZSwgdGhpcy5zZXR0aW5ncy5yZXNwb25zaXZlUmVmcmVzaFJhdGUpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGVja3Mgd2luZG93IGByZXNpemVgIGV2ZW50LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLm9uUmVzaXplID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9pdGVtcy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fd2lkdGggPT09IHRoaXMuJGVsZW1lbnQud2lkdGgoKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5pc1Zpc2libGUoKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHRoaXMuZW50ZXIoJ3Jlc2l6aW5nJyk7XG5cblx0XHRpZiAodGhpcy50cmlnZ2VyKCdyZXNpemUnKS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuXHRcdFx0dGhpcy5sZWF2ZSgncmVzaXppbmcnKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR0aGlzLmludmFsaWRhdGUoJ3dpZHRoJyk7XG5cblx0XHR0aGlzLnJlZnJlc2goKTtcblxuXHRcdHRoaXMubGVhdmUoJ3Jlc2l6aW5nJyk7XG5cdFx0dGhpcy50cmlnZ2VyKCdyZXNpemVkJyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBldmVudCBoYW5kbGVycy5cblx0ICogQHRvZG8gQ2hlY2sgYG1zUG9pbnRlckVuYWJsZWRgXG5cdCAqIEB0b2RvICMyNjFcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5yZWdpc3RlckV2ZW50SGFuZGxlcnMgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoJC5zdXBwb3J0LnRyYW5zaXRpb24pIHtcblx0XHRcdHRoaXMuJHN0YWdlLm9uKCQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCArICcub3dsLmNvcmUnLCAkLnByb3h5KHRoaXMub25UcmFuc2l0aW9uRW5kLCB0aGlzKSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuc2V0dGluZ3MucmVzcG9uc2l2ZSAhPT0gZmFsc2UpIHtcblx0XHRcdHRoaXMub24od2luZG93LCAncmVzaXplJywgdGhpcy5faGFuZGxlcnMub25UaHJvdHRsZWRSZXNpemUpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLnNldHRpbmdzLm1vdXNlRHJhZykge1xuXHRcdFx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuZHJhZ0NsYXNzKTtcblx0XHRcdHRoaXMuJHN0YWdlLm9uKCdtb3VzZWRvd24ub3dsLmNvcmUnLCAkLnByb3h5KHRoaXMub25EcmFnU3RhcnQsIHRoaXMpKTtcblx0XHRcdHRoaXMuJHN0YWdlLm9uKCdkcmFnc3RhcnQub3dsLmNvcmUgc2VsZWN0c3RhcnQub3dsLmNvcmUnLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlIH0pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLnNldHRpbmdzLnRvdWNoRHJhZyl7XG5cdFx0XHR0aGlzLiRzdGFnZS5vbigndG91Y2hzdGFydC5vd2wuY29yZScsICQucHJveHkodGhpcy5vbkRyYWdTdGFydCwgdGhpcykpO1xuXHRcdFx0dGhpcy4kc3RhZ2Uub24oJ3RvdWNoY2FuY2VsLm93bC5jb3JlJywgJC5wcm94eSh0aGlzLm9uRHJhZ0VuZCwgdGhpcykpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogSGFuZGxlcyBgdG91Y2hzdGFydGAgYW5kIGBtb3VzZWRvd25gIGV2ZW50cy5cblx0ICogQHRvZG8gSG9yaXpvbnRhbCBzd2lwZSB0aHJlc2hvbGQgYXMgb3B0aW9uXG5cdCAqIEB0b2RvICMyNjFcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCBhcmd1bWVudHMuXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLm9uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgc3RhZ2UgPSBudWxsO1xuXG5cdFx0aWYgKGV2ZW50LndoaWNoID09PSAzKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCQuc3VwcG9ydC50cmFuc2Zvcm0pIHtcblx0XHRcdHN0YWdlID0gdGhpcy4kc3RhZ2UuY3NzKCd0cmFuc2Zvcm0nKS5yZXBsYWNlKC8uKlxcKHxcXCl8IC9nLCAnJykuc3BsaXQoJywnKTtcblx0XHRcdHN0YWdlID0ge1xuXHRcdFx0XHR4OiBzdGFnZVtzdGFnZS5sZW5ndGggPT09IDE2ID8gMTIgOiA0XSxcblx0XHRcdFx0eTogc3RhZ2Vbc3RhZ2UubGVuZ3RoID09PSAxNiA/IDEzIDogNV1cblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0YWdlID0gdGhpcy4kc3RhZ2UucG9zaXRpb24oKTtcblx0XHRcdHN0YWdlID0ge1xuXHRcdFx0XHR4OiB0aGlzLnNldHRpbmdzLnJ0bCA/XG5cdFx0XHRcdFx0c3RhZ2UubGVmdCArIHRoaXMuJHN0YWdlLndpZHRoKCkgLSB0aGlzLndpZHRoKCkgKyB0aGlzLnNldHRpbmdzLm1hcmdpbiA6XG5cdFx0XHRcdFx0c3RhZ2UubGVmdCxcblx0XHRcdFx0eTogc3RhZ2UudG9wXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmlzKCdhbmltYXRpbmcnKSkge1xuXHRcdFx0JC5zdXBwb3J0LnRyYW5zZm9ybSA/IHRoaXMuYW5pbWF0ZShzdGFnZS54KSA6IHRoaXMuJHN0YWdlLnN0b3AoKVxuXHRcdFx0dGhpcy5pbnZhbGlkYXRlKCdwb3NpdGlvbicpO1xuXHRcdH1cblxuXHRcdHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3ModGhpcy5vcHRpb25zLmdyYWJDbGFzcywgZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicpO1xuXG5cdFx0dGhpcy5zcGVlZCgwKTtcblxuXHRcdHRoaXMuX2RyYWcudGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHRcdHRoaXMuX2RyYWcudGFyZ2V0ID0gJChldmVudC50YXJnZXQpO1xuXHRcdHRoaXMuX2RyYWcuc3RhZ2Uuc3RhcnQgPSBzdGFnZTtcblx0XHR0aGlzLl9kcmFnLnN0YWdlLmN1cnJlbnQgPSBzdGFnZTtcblx0XHR0aGlzLl9kcmFnLnBvaW50ZXIgPSB0aGlzLnBvaW50ZXIoZXZlbnQpO1xuXG5cdFx0JChkb2N1bWVudCkub24oJ21vdXNldXAub3dsLmNvcmUgdG91Y2hlbmQub3dsLmNvcmUnLCAkLnByb3h5KHRoaXMub25EcmFnRW5kLCB0aGlzKSk7XG5cblx0XHQkKGRvY3VtZW50KS5vbmUoJ21vdXNlbW92ZS5vd2wuY29yZSB0b3VjaG1vdmUub3dsLmNvcmUnLCAkLnByb3h5KGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHR2YXIgZGVsdGEgPSB0aGlzLmRpZmZlcmVuY2UodGhpcy5fZHJhZy5wb2ludGVyLCB0aGlzLnBvaW50ZXIoZXZlbnQpKTtcblxuXHRcdFx0JChkb2N1bWVudCkub24oJ21vdXNlbW92ZS5vd2wuY29yZSB0b3VjaG1vdmUub3dsLmNvcmUnLCAkLnByb3h5KHRoaXMub25EcmFnTW92ZSwgdGhpcykpO1xuXG5cdFx0XHRpZiAoTWF0aC5hYnMoZGVsdGEueCkgPCBNYXRoLmFicyhkZWx0YS55KSAmJiB0aGlzLmlzKCd2YWxpZCcpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0dGhpcy5lbnRlcignZHJhZ2dpbmcnKTtcblx0XHRcdHRoaXMudHJpZ2dlcignZHJhZycpO1xuXHRcdH0sIHRoaXMpKTtcblx0fTtcblxuXHQvKipcblx0ICogSGFuZGxlcyB0aGUgYHRvdWNobW92ZWAgYW5kIGBtb3VzZW1vdmVgIGV2ZW50cy5cblx0ICogQHRvZG8gIzI2MVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IGFyZ3VtZW50cy5cblx0ICovXG5cdE93bC5wcm90b3R5cGUub25EcmFnTW92ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIG1pbmltdW0gPSBudWxsLFxuXHRcdFx0bWF4aW11bSA9IG51bGwsXG5cdFx0XHRwdWxsID0gbnVsbCxcblx0XHRcdGRlbHRhID0gdGhpcy5kaWZmZXJlbmNlKHRoaXMuX2RyYWcucG9pbnRlciwgdGhpcy5wb2ludGVyKGV2ZW50KSksXG5cdFx0XHRzdGFnZSA9IHRoaXMuZGlmZmVyZW5jZSh0aGlzLl9kcmFnLnN0YWdlLnN0YXJ0LCBkZWx0YSk7XG5cblx0XHRpZiAoIXRoaXMuaXMoJ2RyYWdnaW5nJykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0aWYgKHRoaXMuc2V0dGluZ3MubG9vcCkge1xuXHRcdFx0bWluaW11bSA9IHRoaXMuY29vcmRpbmF0ZXModGhpcy5taW5pbXVtKCkpO1xuXHRcdFx0bWF4aW11bSA9IHRoaXMuY29vcmRpbmF0ZXModGhpcy5tYXhpbXVtKCkgKyAxKSAtIG1pbmltdW07XG5cdFx0XHRzdGFnZS54ID0gKCgoc3RhZ2UueCAtIG1pbmltdW0pICUgbWF4aW11bSArIG1heGltdW0pICUgbWF4aW11bSkgKyBtaW5pbXVtO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtaW5pbXVtID0gdGhpcy5zZXR0aW5ncy5ydGwgPyB0aGlzLmNvb3JkaW5hdGVzKHRoaXMubWF4aW11bSgpKSA6IHRoaXMuY29vcmRpbmF0ZXModGhpcy5taW5pbXVtKCkpO1xuXHRcdFx0bWF4aW11bSA9IHRoaXMuc2V0dGluZ3MucnRsID8gdGhpcy5jb29yZGluYXRlcyh0aGlzLm1pbmltdW0oKSkgOiB0aGlzLmNvb3JkaW5hdGVzKHRoaXMubWF4aW11bSgpKTtcblx0XHRcdHB1bGwgPSB0aGlzLnNldHRpbmdzLnB1bGxEcmFnID8gLTEgKiBkZWx0YS54IC8gNSA6IDA7XG5cdFx0XHRzdGFnZS54ID0gTWF0aC5tYXgoTWF0aC5taW4oc3RhZ2UueCwgbWluaW11bSArIHB1bGwpLCBtYXhpbXVtICsgcHVsbCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZHJhZy5zdGFnZS5jdXJyZW50ID0gc3RhZ2U7XG5cblx0XHR0aGlzLmFuaW1hdGUoc3RhZ2UueCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgdGhlIGB0b3VjaGVuZGAgYW5kIGBtb3VzZXVwYCBldmVudHMuXG5cdCAqIEB0b2RvICMyNjFcblx0ICogQHRvZG8gVGhyZXNob2xkIGZvciBjbGljayBldmVudFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IGFyZ3VtZW50cy5cblx0ICovXG5cdE93bC5wcm90b3R5cGUub25EcmFnRW5kID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgZGVsdGEgPSB0aGlzLmRpZmZlcmVuY2UodGhpcy5fZHJhZy5wb2ludGVyLCB0aGlzLnBvaW50ZXIoZXZlbnQpKSxcblx0XHRcdHN0YWdlID0gdGhpcy5fZHJhZy5zdGFnZS5jdXJyZW50LFxuXHRcdFx0ZGlyZWN0aW9uID0gZGVsdGEueCA+IDAgXiB0aGlzLnNldHRpbmdzLnJ0bCA/ICdsZWZ0JyA6ICdyaWdodCc7XG5cblx0XHQkKGRvY3VtZW50KS5vZmYoJy5vd2wuY29yZScpO1xuXG5cdFx0dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZ3JhYkNsYXNzKTtcblxuXHRcdGlmIChkZWx0YS54ICE9PSAwICYmIHRoaXMuaXMoJ2RyYWdnaW5nJykgfHwgIXRoaXMuaXMoJ3ZhbGlkJykpIHtcblx0XHRcdHRoaXMuc3BlZWQodGhpcy5zZXR0aW5ncy5kcmFnRW5kU3BlZWQgfHwgdGhpcy5zZXR0aW5ncy5zbWFydFNwZWVkKTtcblx0XHRcdHRoaXMuY3VycmVudCh0aGlzLmNsb3Nlc3Qoc3RhZ2UueCwgZGVsdGEueCAhPT0gMCA/IGRpcmVjdGlvbiA6IHRoaXMuX2RyYWcuZGlyZWN0aW9uKSk7XG5cdFx0XHR0aGlzLmludmFsaWRhdGUoJ3Bvc2l0aW9uJyk7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0XHR0aGlzLl9kcmFnLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcblxuXHRcdFx0aWYgKE1hdGguYWJzKGRlbHRhLngpID4gMyB8fCBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuX2RyYWcudGltZSA+IDMwMCkge1xuXHRcdFx0XHR0aGlzLl9kcmFnLnRhcmdldC5vbmUoJ2NsaWNrLm93bC5jb3JlJywgZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmlzKCdkcmFnZ2luZycpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5sZWF2ZSgnZHJhZ2dpbmcnKTtcblx0XHR0aGlzLnRyaWdnZXIoJ2RyYWdnZWQnKTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0cyBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgY2xvc2VzdCBpdGVtIGZvciBhIGNvb3JkaW5hdGUuXG5cdCAqIEB0b2RvIFNldHRpbmcgYGZyZWVEcmFnYCBtYWtlcyBgY2xvc2VzdGAgbm90IHJldXNhYmxlLiBTZWUgIzE2NS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29vcmRpbmF0ZSAtIFRoZSBjb29yZGluYXRlIGluIHBpeGVsLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0aW9uIC0gVGhlIGRpcmVjdGlvbiB0byBjaGVjayBmb3IgdGhlIGNsb3Nlc3QgaXRlbS4gRXRoZXIgYGxlZnRgIG9yIGByaWdodGAuXG5cdCAqIEByZXR1cm4ge051bWJlcn0gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGNsb3Nlc3QgaXRlbS5cblx0ICovXG5cdE93bC5wcm90b3R5cGUuY2xvc2VzdCA9IGZ1bmN0aW9uKGNvb3JkaW5hdGUsIGRpcmVjdGlvbikge1xuXHRcdHZhciBwb3NpdGlvbiA9IC0xLFxuXHRcdFx0cHVsbCA9IDMwLFxuXHRcdFx0d2lkdGggPSB0aGlzLndpZHRoKCksXG5cdFx0XHRjb29yZGluYXRlcyA9IHRoaXMuY29vcmRpbmF0ZXMoKTtcblxuXHRcdGlmICghdGhpcy5zZXR0aW5ncy5mcmVlRHJhZykge1xuXHRcdFx0Ly8gY2hlY2sgY2xvc2VzdCBpdGVtXG5cdFx0XHQkLmVhY2goY29vcmRpbmF0ZXMsICQucHJveHkoZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XG5cdFx0XHRcdC8vIG9uIGEgbGVmdCBwdWxsLCBjaGVjayBvbiBjdXJyZW50IGluZGV4XG5cdFx0XHRcdGlmIChkaXJlY3Rpb24gPT09ICdsZWZ0JyAmJiBjb29yZGluYXRlID4gdmFsdWUgLSBwdWxsICYmIGNvb3JkaW5hdGUgPCB2YWx1ZSArIHB1bGwpIHtcblx0XHRcdFx0XHRwb3NpdGlvbiA9IGluZGV4O1xuXHRcdFx0XHQvLyBvbiBhIHJpZ2h0IHB1bGwsIGNoZWNrIG9uIHByZXZpb3VzIGluZGV4XG5cdFx0XHRcdC8vIHRvIGRvIHNvLCBzdWJ0cmFjdCB3aWR0aCBmcm9tIHZhbHVlIGFuZCBzZXQgcG9zaXRpb24gPSBpbmRleCArIDFcblx0XHRcdFx0fSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdyaWdodCcgJiYgY29vcmRpbmF0ZSA+IHZhbHVlIC0gd2lkdGggLSBwdWxsICYmIGNvb3JkaW5hdGUgPCB2YWx1ZSAtIHdpZHRoICsgcHVsbCkge1xuXHRcdFx0XHRcdHBvc2l0aW9uID0gaW5kZXggKyAxO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMub3AoY29vcmRpbmF0ZSwgJzwnLCB2YWx1ZSlcblx0XHRcdFx0XHQmJiB0aGlzLm9wKGNvb3JkaW5hdGUsICc+JywgY29vcmRpbmF0ZXNbaW5kZXggKyAxXSAhPT0gdW5kZWZpbmVkID8gY29vcmRpbmF0ZXNbaW5kZXggKyAxXSA6IHZhbHVlIC0gd2lkdGgpKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24gPSBkaXJlY3Rpb24gPT09ICdsZWZ0JyA/IGluZGV4ICsgMSA6IGluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwb3NpdGlvbiA9PT0gLTE7XG5cdFx0XHR9LCB0aGlzKSk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLnNldHRpbmdzLmxvb3ApIHtcblx0XHRcdC8vIG5vbiBsb29wIGJvdW5kcmllc1xuXHRcdFx0aWYgKHRoaXMub3AoY29vcmRpbmF0ZSwgJz4nLCBjb29yZGluYXRlc1t0aGlzLm1pbmltdW0oKV0pKSB7XG5cdFx0XHRcdHBvc2l0aW9uID0gY29vcmRpbmF0ZSA9IHRoaXMubWluaW11bSgpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLm9wKGNvb3JkaW5hdGUsICc8JywgY29vcmRpbmF0ZXNbdGhpcy5tYXhpbXVtKCldKSkge1xuXHRcdFx0XHRwb3NpdGlvbiA9IGNvb3JkaW5hdGUgPSB0aGlzLm1heGltdW0oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcG9zaXRpb247XG5cdH07XG5cblx0LyoqXG5cdCAqIEFuaW1hdGVzIHRoZSBzdGFnZS5cblx0ICogQHRvZG8gIzI3MFxuXHQgKiBAcHVibGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb29yZGluYXRlIC0gVGhlIGNvb3JkaW5hdGUgaW4gcGl4ZWxzLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5hbmltYXRlID0gZnVuY3Rpb24oY29vcmRpbmF0ZSkge1xuXHRcdHZhciBhbmltYXRlID0gdGhpcy5zcGVlZCgpID4gMDtcblxuXHRcdHRoaXMuaXMoJ2FuaW1hdGluZycpICYmIHRoaXMub25UcmFuc2l0aW9uRW5kKCk7XG5cblx0XHRpZiAoYW5pbWF0ZSkge1xuXHRcdFx0dGhpcy5lbnRlcignYW5pbWF0aW5nJyk7XG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3RyYW5zbGF0ZScpO1xuXHRcdH1cblxuXHRcdGlmICgkLnN1cHBvcnQudHJhbnNmb3JtM2QgJiYgJC5zdXBwb3J0LnRyYW5zaXRpb24pIHtcblx0XHRcdHRoaXMuJHN0YWdlLmNzcyh7XG5cdFx0XHRcdHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKCcgKyBjb29yZGluYXRlICsgJ3B4LDBweCwwcHgpJyxcblx0XHRcdFx0dHJhbnNpdGlvbjogKHRoaXMuc3BlZWQoKSAvIDEwMDApICsgJ3MnICsgKFxuXHRcdFx0XHRcdHRoaXMuc2V0dGluZ3Muc2xpZGVUcmFuc2l0aW9uID8gJyAnICsgdGhpcy5zZXR0aW5ncy5zbGlkZVRyYW5zaXRpb24gOiAnJ1xuXHRcdFx0XHQpXG5cdFx0XHR9KTtcblx0XHR9IGVsc2UgaWYgKGFuaW1hdGUpIHtcblx0XHRcdHRoaXMuJHN0YWdlLmFuaW1hdGUoe1xuXHRcdFx0XHRsZWZ0OiBjb29yZGluYXRlICsgJ3B4J1xuXHRcdFx0fSwgdGhpcy5zcGVlZCgpLCB0aGlzLnNldHRpbmdzLmZhbGxiYWNrRWFzaW5nLCAkLnByb3h5KHRoaXMub25UcmFuc2l0aW9uRW5kLCB0aGlzKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuJHN0YWdlLmNzcyh7XG5cdFx0XHRcdGxlZnQ6IGNvb3JkaW5hdGUgKyAncHgnXG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrcyB3aGV0aGVyIHRoZSBjYXJvdXNlbCBpcyBpbiBhIHNwZWNpZmljIHN0YXRlIG9yIG5vdC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0YXRlIC0gVGhlIHN0YXRlIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSBUaGUgZmxhZyB3aGljaCBpbmRpY2F0ZXMgaWYgdGhlIGNhcm91c2VsIGlzIGJ1c3kuXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLmlzID0gZnVuY3Rpb24oc3RhdGUpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3RhdGVzLmN1cnJlbnRbc3RhdGVdICYmIHRoaXMuX3N0YXRlcy5jdXJyZW50W3N0YXRlXSA+IDA7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGl0ZW0uXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtwb3NpdGlvbl0gLSBUaGUgbmV3IGFic29sdXRlIHBvc2l0aW9uIG9yIG5vdGhpbmcgdG8gbGVhdmUgaXQgdW5jaGFuZ2VkLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBpdGVtLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcblx0XHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2N1cnJlbnQ7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX2l0ZW1zLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRwb3NpdGlvbiA9IHRoaXMubm9ybWFsaXplKHBvc2l0aW9uKTtcblxuXHRcdGlmICh0aGlzLl9jdXJyZW50ICE9PSBwb3NpdGlvbikge1xuXHRcdFx0dmFyIGV2ZW50ID0gdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB7IHByb3BlcnR5OiB7IG5hbWU6ICdwb3NpdGlvbicsIHZhbHVlOiBwb3NpdGlvbiB9IH0pO1xuXG5cdFx0XHRpZiAoZXZlbnQuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHBvc2l0aW9uID0gdGhpcy5ub3JtYWxpemUoZXZlbnQuZGF0YSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2N1cnJlbnQgPSBwb3NpdGlvbjtcblxuXHRcdFx0dGhpcy5pbnZhbGlkYXRlKCdwb3NpdGlvbicpO1xuXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7IHByb3BlcnR5OiB7IG5hbWU6ICdwb3NpdGlvbicsIHZhbHVlOiB0aGlzLl9jdXJyZW50IH0gfSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX2N1cnJlbnQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIEludmFsaWRhdGVzIHRoZSBnaXZlbiBwYXJ0IG9mIHRoZSB1cGRhdGUgcm91dGluZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtwYXJ0XSAtIFRoZSBwYXJ0IHRvIGludmFsaWRhdGUuXG5cdCAqIEByZXR1cm5zIHtBcnJheS48U3RyaW5nPn0gLSBUaGUgaW52YWxpZGF0ZWQgcGFydHMuXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbihwYXJ0KSB7XG5cdFx0aWYgKCQudHlwZShwYXJ0KSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHRoaXMuX2ludmFsaWRhdGVkW3BhcnRdID0gdHJ1ZTtcblx0XHRcdHRoaXMuaXMoJ3ZhbGlkJykgJiYgdGhpcy5sZWF2ZSgndmFsaWQnKTtcblx0XHR9XG5cdFx0cmV0dXJuICQubWFwKHRoaXMuX2ludmFsaWRhdGVkLCBmdW5jdGlvbih2LCBpKSB7IHJldHVybiBpIH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXNldHMgdGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGl0ZW0uXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gVGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBuZXcgaXRlbS5cblx0ICovXG5cdE93bC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuXHRcdHBvc2l0aW9uID0gdGhpcy5ub3JtYWxpemUocG9zaXRpb24pO1xuXG5cdFx0aWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9zcGVlZCA9IDA7XG5cdFx0dGhpcy5fY3VycmVudCA9IHBvc2l0aW9uO1xuXG5cdFx0dGhpcy5zdXBwcmVzcyhbICd0cmFuc2xhdGUnLCAndHJhbnNsYXRlZCcgXSk7XG5cblx0XHR0aGlzLmFuaW1hdGUodGhpcy5jb29yZGluYXRlcyhwb3NpdGlvbikpO1xuXG5cdFx0dGhpcy5yZWxlYXNlKFsgJ3RyYW5zbGF0ZScsICd0cmFuc2xhdGVkJyBdKTtcblx0fTtcblxuXHQvKipcblx0ICogTm9ybWFsaXplcyBhbiBhYnNvbHV0ZSBvciBhIHJlbGF0aXZlIHBvc2l0aW9uIG9mIGFuIGl0ZW0uXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gVGhlIGFic29sdXRlIG9yIHJlbGF0aXZlIHBvc2l0aW9uIHRvIG5vcm1hbGl6ZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbcmVsYXRpdmU9ZmFsc2VdIC0gV2hldGhlciB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgcmVsYXRpdmUgb3Igbm90LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSAtIFRoZSBub3JtYWxpemVkIHBvc2l0aW9uLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbihwb3NpdGlvbiwgcmVsYXRpdmUpIHtcblx0XHR2YXIgbiA9IHRoaXMuX2l0ZW1zLmxlbmd0aCxcblx0XHRcdG0gPSByZWxhdGl2ZSA/IDAgOiB0aGlzLl9jbG9uZXMubGVuZ3RoO1xuXG5cdFx0aWYgKCF0aGlzLmlzTnVtZXJpYyhwb3NpdGlvbikgfHwgbiA8IDEpIHtcblx0XHRcdHBvc2l0aW9uID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IG4gKyBtKSB7XG5cdFx0XHRwb3NpdGlvbiA9ICgocG9zaXRpb24gLSBtIC8gMikgJSBuICsgbikgJSBuICsgbSAvIDI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBvc2l0aW9uO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhbiBhYnNvbHV0ZSBwb3NpdGlvbiBvZiBhbiBpdGVtIGludG8gYSByZWxhdGl2ZSBvbmUuXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gVGhlIGFic29sdXRlIHBvc2l0aW9uIHRvIGNvbnZlcnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gVGhlIGNvbnZlcnRlZCBwb3NpdGlvbi5cblx0ICovXG5cdE93bC5wcm90b3R5cGUucmVsYXRpdmUgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuXHRcdHBvc2l0aW9uIC09IHRoaXMuX2Nsb25lcy5sZW5ndGggLyAyO1xuXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZShwb3NpdGlvbiwgdHJ1ZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIG1heGltdW0gcG9zaXRpb24gZm9yIHRoZSBjdXJyZW50IGl0ZW0uXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtCb29sZWFufSBbcmVsYXRpdmU9ZmFsc2VdIC0gV2hldGhlciB0byByZXR1cm4gYW4gYWJzb2x1dGUgcG9zaXRpb24gb3IgYSByZWxhdGl2ZSBwb3NpdGlvbi5cblx0ICogQHJldHVybnMge051bWJlcn1cblx0ICovXG5cdE93bC5wcm90b3R5cGUubWF4aW11bSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG5cdFx0dmFyIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncyxcblx0XHRcdG1heGltdW0gPSB0aGlzLl9jb29yZGluYXRlcy5sZW5ndGgsXG5cdFx0XHRpdGVyYXRvcixcblx0XHRcdHJlY2lwcm9jYWxJdGVtc1dpZHRoLFxuXHRcdFx0ZWxlbWVudFdpZHRoO1xuXG5cdFx0aWYgKHNldHRpbmdzLmxvb3ApIHtcblx0XHRcdG1heGltdW0gPSB0aGlzLl9jbG9uZXMubGVuZ3RoIC8gMiArIHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDE7XG5cdFx0fSBlbHNlIGlmIChzZXR0aW5ncy5hdXRvV2lkdGggfHwgc2V0dGluZ3MubWVyZ2UpIHtcblx0XHRcdGl0ZXJhdG9yID0gdGhpcy5faXRlbXMubGVuZ3RoO1xuXHRcdFx0aWYgKGl0ZXJhdG9yKSB7XG5cdFx0XHRcdHJlY2lwcm9jYWxJdGVtc1dpZHRoID0gdGhpcy5faXRlbXNbLS1pdGVyYXRvcl0ud2lkdGgoKTtcblx0XHRcdFx0ZWxlbWVudFdpZHRoID0gdGhpcy4kZWxlbWVudC53aWR0aCgpO1xuXHRcdFx0XHR3aGlsZSAoaXRlcmF0b3ItLSkge1xuXHRcdFx0XHRcdHJlY2lwcm9jYWxJdGVtc1dpZHRoICs9IHRoaXMuX2l0ZW1zW2l0ZXJhdG9yXS53aWR0aCgpICsgdGhpcy5zZXR0aW5ncy5tYXJnaW47XG5cdFx0XHRcdFx0aWYgKHJlY2lwcm9jYWxJdGVtc1dpZHRoID4gZWxlbWVudFdpZHRoKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG1heGltdW0gPSBpdGVyYXRvciArIDE7XG5cdFx0fSBlbHNlIGlmIChzZXR0aW5ncy5jZW50ZXIpIHtcblx0XHRcdG1heGltdW0gPSB0aGlzLl9pdGVtcy5sZW5ndGggLSAxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXhpbXVtID0gdGhpcy5faXRlbXMubGVuZ3RoIC0gc2V0dGluZ3MuaXRlbXM7XG5cdFx0fVxuXG5cdFx0aWYgKHJlbGF0aXZlKSB7XG5cdFx0XHRtYXhpbXVtIC09IHRoaXMuX2Nsb25lcy5sZW5ndGggLyAyO1xuXHRcdH1cblxuXHRcdHJldHVybiBNYXRoLm1heChtYXhpbXVtLCAwKTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgbWluaW11bSBwb3NpdGlvbiBmb3IgdGhlIGN1cnJlbnQgaXRlbS5cblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZWxhdGl2ZT1mYWxzZV0gLSBXaGV0aGVyIHRvIHJldHVybiBhbiBhYnNvbHV0ZSBwb3NpdGlvbiBvciBhIHJlbGF0aXZlIHBvc2l0aW9uLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfVxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5taW5pbXVtID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcblx0XHRyZXR1cm4gcmVsYXRpdmUgPyAwIDogdGhpcy5fY2xvbmVzLmxlbmd0aCAvIDI7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldHMgYW4gaXRlbSBhdCB0aGUgc3BlY2lmaWVkIHJlbGF0aXZlIHBvc2l0aW9uLlxuXHQgKiBAcHVibGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb25dIC0gVGhlIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBpdGVtLlxuXHQgKiBAcmV0dXJuIHtqUXVlcnl8QXJyYXkuPGpRdWVyeT59IC0gVGhlIGl0ZW0gYXQgdGhlIGdpdmVuIHBvc2l0aW9uIG9yIGFsbCBpdGVtcyBpZiBubyBwb3NpdGlvbiB3YXMgZ2l2ZW4uXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLml0ZW1zID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcblx0XHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2l0ZW1zLnNsaWNlKCk7XG5cdFx0fVxuXG5cdFx0cG9zaXRpb24gPSB0aGlzLm5vcm1hbGl6ZShwb3NpdGlvbiwgdHJ1ZSk7XG5cdFx0cmV0dXJuIHRoaXMuX2l0ZW1zW3Bvc2l0aW9uXTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0cyBhbiBpdGVtIGF0IHRoZSBzcGVjaWZpZWQgcmVsYXRpdmUgcG9zaXRpb24uXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtwb3NpdGlvbl0gLSBUaGUgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGl0ZW0uXG5cdCAqIEByZXR1cm4ge2pRdWVyeXxBcnJheS48alF1ZXJ5Pn0gLSBUaGUgaXRlbSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gb3IgYWxsIGl0ZW1zIGlmIG5vIHBvc2l0aW9uIHdhcyBnaXZlbi5cblx0ICovXG5cdE93bC5wcm90b3R5cGUubWVyZ2VycyA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG5cdFx0aWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiB0aGlzLl9tZXJnZXJzLnNsaWNlKCk7XG5cdFx0fVxuXG5cdFx0cG9zaXRpb24gPSB0aGlzLm5vcm1hbGl6ZShwb3NpdGlvbiwgdHJ1ZSk7XG5cdFx0cmV0dXJuIHRoaXMuX21lcmdlcnNbcG9zaXRpb25dO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbnMgb2YgY2xvbmVzIGZvciBhbiBpdGVtLlxuXHQgKiBAcHVibGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb25dIC0gVGhlIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXkuPE51bWJlcj59IC0gVGhlIGFic29sdXRlIHBvc2l0aW9ucyBvZiBjbG9uZXMgZm9yIHRoZSBpdGVtIG9yIGFsbCBpZiBubyBwb3NpdGlvbiB3YXMgZ2l2ZW4uXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLmNsb25lcyA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG5cdFx0dmFyIG9kZCA9IHRoaXMuX2Nsb25lcy5sZW5ndGggLyAyLFxuXHRcdFx0ZXZlbiA9IG9kZCArIHRoaXMuX2l0ZW1zLmxlbmd0aCxcblx0XHRcdG1hcCA9IGZ1bmN0aW9uKGluZGV4KSB7IHJldHVybiBpbmRleCAlIDIgPT09IDAgPyBldmVuICsgaW5kZXggLyAyIDogb2RkIC0gKGluZGV4ICsgMSkgLyAyIH07XG5cblx0XHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuICQubWFwKHRoaXMuX2Nsb25lcywgZnVuY3Rpb24odiwgaSkgeyByZXR1cm4gbWFwKGkpIH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiAkLm1hcCh0aGlzLl9jbG9uZXMsIGZ1bmN0aW9uKHYsIGkpIHsgcmV0dXJuIHYgPT09IHBvc2l0aW9uID8gbWFwKGkpIDogbnVsbCB9KTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgY3VycmVudCBhbmltYXRpb24gc3BlZWQuXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZF0gLSBUaGUgYW5pbWF0aW9uIHNwZWVkIGluIG1pbGxpc2Vjb25kcyBvciBub3RoaW5nIHRvIGxlYXZlIGl0IHVuY2hhbmdlZC5cblx0ICogQHJldHVybnMge051bWJlcn0gLSBUaGUgY3VycmVudCBhbmltYXRpb24gc3BlZWQgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5zcGVlZCA9IGZ1bmN0aW9uKHNwZWVkKSB7XG5cdFx0aWYgKHNwZWVkICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuX3NwZWVkID0gc3BlZWQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX3NwZWVkO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBjb29yZGluYXRlIG9mIGFuIGl0ZW0uXG5cdCAqIEB0b2RvIFRoZSBuYW1lIG9mIHRoaXMgbWV0aG9kIGlzIG1pc3NsZWFuZGluZy5cblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0gd2l0aGluIGBtaW5pbXVtKClgIGFuZCBgbWF4aW11bSgpYC5cblx0ICogQHJldHVybnMge051bWJlcnxBcnJheS48TnVtYmVyPn0gLSBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgaXRlbSBpbiBwaXhlbCBvciBhbGwgY29vcmRpbmF0ZXMuXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLmNvb3JkaW5hdGVzID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcblx0XHR2YXIgbXVsdGlwbGllciA9IDEsXG5cdFx0XHRuZXdQb3NpdGlvbiA9IHBvc2l0aW9uIC0gMSxcblx0XHRcdGNvb3JkaW5hdGU7XG5cblx0XHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuICQubWFwKHRoaXMuX2Nvb3JkaW5hdGVzLCAkLnByb3h5KGZ1bmN0aW9uKGNvb3JkaW5hdGUsIGluZGV4KSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvb3JkaW5hdGVzKGluZGV4KTtcblx0XHRcdH0sIHRoaXMpKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5zZXR0aW5ncy5jZW50ZXIpIHtcblx0XHRcdGlmICh0aGlzLnNldHRpbmdzLnJ0bCkge1xuXHRcdFx0XHRtdWx0aXBsaWVyID0gLTE7XG5cdFx0XHRcdG5ld1Bvc2l0aW9uID0gcG9zaXRpb24gKyAxO1xuXHRcdFx0fVxuXG5cdFx0XHRjb29yZGluYXRlID0gdGhpcy5fY29vcmRpbmF0ZXNbcG9zaXRpb25dO1xuXHRcdFx0Y29vcmRpbmF0ZSArPSAodGhpcy53aWR0aCgpIC0gY29vcmRpbmF0ZSArICh0aGlzLl9jb29yZGluYXRlc1tuZXdQb3NpdGlvbl0gfHwgMCkpIC8gMiAqIG11bHRpcGxpZXI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvb3JkaW5hdGUgPSB0aGlzLl9jb29yZGluYXRlc1tuZXdQb3NpdGlvbl0gfHwgMDtcblx0XHR9XG5cblx0XHRjb29yZGluYXRlID0gTWF0aC5jZWlsKGNvb3JkaW5hdGUpO1xuXG5cdFx0cmV0dXJuIGNvb3JkaW5hdGU7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZXMgdGhlIHNwZWVkIGZvciBhIHRyYW5zbGF0aW9uLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBmcm9tIC0gVGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBzdGFydCBpdGVtLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gdG8gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBpdGVtLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW2ZhY3Rvcj11bmRlZmluZWRdIC0gVGhlIHRpbWUgZmFjdG9yIGluIG1pbGxpc2Vjb25kcy5cblx0ICogQHJldHVybnMge051bWJlcn0gLSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0cmFuc2xhdGlvbi5cblx0ICovXG5cdE93bC5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbihmcm9tLCB0bywgZmFjdG9yKSB7XG5cdFx0aWYgKGZhY3RvciA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIE1hdGgubWluKE1hdGgubWF4KE1hdGguYWJzKHRvIC0gZnJvbSksIDEpLCA2KSAqIE1hdGguYWJzKChmYWN0b3IgfHwgdGhpcy5zZXR0aW5ncy5zbWFydFNwZWVkKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNsaWRlcyB0byB0aGUgc3BlY2lmaWVkIGl0ZW0uXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBpdGVtLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkXSAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRyYW5zaXRpb24uXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLnRvID0gZnVuY3Rpb24ocG9zaXRpb24sIHNwZWVkKSB7XG5cdFx0dmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQoKSxcblx0XHRcdHJldmVydCA9IG51bGwsXG5cdFx0XHRkaXN0YW5jZSA9IHBvc2l0aW9uIC0gdGhpcy5yZWxhdGl2ZShjdXJyZW50KSxcblx0XHRcdGRpcmVjdGlvbiA9IChkaXN0YW5jZSA+IDApIC0gKGRpc3RhbmNlIDwgMCksXG5cdFx0XHRpdGVtcyA9IHRoaXMuX2l0ZW1zLmxlbmd0aCxcblx0XHRcdG1pbmltdW0gPSB0aGlzLm1pbmltdW0oKSxcblx0XHRcdG1heGltdW0gPSB0aGlzLm1heGltdW0oKTtcblxuXHRcdGlmICh0aGlzLnNldHRpbmdzLmxvb3ApIHtcblx0XHRcdGlmICghdGhpcy5zZXR0aW5ncy5yZXdpbmQgJiYgTWF0aC5hYnMoZGlzdGFuY2UpID4gaXRlbXMgLyAyKSB7XG5cdFx0XHRcdGRpc3RhbmNlICs9IGRpcmVjdGlvbiAqIC0xICogaXRlbXM7XG5cdFx0XHR9XG5cblx0XHRcdHBvc2l0aW9uID0gY3VycmVudCArIGRpc3RhbmNlO1xuXHRcdFx0cmV2ZXJ0ID0gKChwb3NpdGlvbiAtIG1pbmltdW0pICUgaXRlbXMgKyBpdGVtcykgJSBpdGVtcyArIG1pbmltdW07XG5cblx0XHRcdGlmIChyZXZlcnQgIT09IHBvc2l0aW9uICYmIHJldmVydCAtIGRpc3RhbmNlIDw9IG1heGltdW0gJiYgcmV2ZXJ0IC0gZGlzdGFuY2UgPiAwKSB7XG5cdFx0XHRcdGN1cnJlbnQgPSByZXZlcnQgLSBkaXN0YW5jZTtcblx0XHRcdFx0cG9zaXRpb24gPSByZXZlcnQ7XG5cdFx0XHRcdHRoaXMucmVzZXQoY3VycmVudCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0aGlzLnNldHRpbmdzLnJld2luZCkge1xuXHRcdFx0bWF4aW11bSArPSAxO1xuXHRcdFx0cG9zaXRpb24gPSAocG9zaXRpb24gJSBtYXhpbXVtICsgbWF4aW11bSkgJSBtYXhpbXVtO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwb3NpdGlvbiA9IE1hdGgubWF4KG1pbmltdW0sIE1hdGgubWluKG1heGltdW0sIHBvc2l0aW9uKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zcGVlZCh0aGlzLmR1cmF0aW9uKGN1cnJlbnQsIHBvc2l0aW9uLCBzcGVlZCkpO1xuXHRcdHRoaXMuY3VycmVudChwb3NpdGlvbik7XG5cblx0XHRpZiAodGhpcy5pc1Zpc2libGUoKSkge1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFNsaWRlcyB0byB0aGUgbmV4dCBpdGVtLlxuXHQgKiBAcHVibGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWRdIC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgdHJhbnNpdGlvbi5cblx0ICovXG5cdE93bC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKHNwZWVkKSB7XG5cdFx0c3BlZWQgPSBzcGVlZCB8fCBmYWxzZTtcblx0XHR0aGlzLnRvKHRoaXMucmVsYXRpdmUodGhpcy5jdXJyZW50KCkpICsgMSwgc3BlZWQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTbGlkZXMgdG8gdGhlIHByZXZpb3VzIGl0ZW0uXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZF0gLSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0cmFuc2l0aW9uLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24oc3BlZWQpIHtcblx0XHRzcGVlZCA9IHNwZWVkIHx8IGZhbHNlO1xuXHRcdHRoaXMudG8odGhpcy5yZWxhdGl2ZSh0aGlzLmN1cnJlbnQoKSkgLSAxLCBzcGVlZCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgdGhlIGVuZCBvZiBhbiBhbmltYXRpb24uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5vblRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0Ly8gaWYgY3NzMiBhbmltYXRpb24gdGhlbiBldmVudCBvYmplY3QgaXMgdW5kZWZpbmVkXG5cdFx0aWYgKGV2ZW50ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0XHQvLyBDYXRjaCBvbmx5IG93bC1zdGFnZSB0cmFuc2l0aW9uRW5kIGV2ZW50XG5cdFx0XHRpZiAoKGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50IHx8IGV2ZW50Lm9yaWdpbmFsVGFyZ2V0KSAhPT0gdGhpcy4kc3RhZ2UuZ2V0KDApKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmxlYXZlKCdhbmltYXRpbmcnKTtcblx0XHR0aGlzLnRyaWdnZXIoJ3RyYW5zbGF0ZWQnKTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0cyB2aWV3cG9ydCB3aWR0aC5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gVGhlIHdpZHRoIGluIHBpeGVsLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS52aWV3cG9ydCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB3aWR0aDtcblx0XHRpZiAodGhpcy5vcHRpb25zLnJlc3BvbnNpdmVCYXNlRWxlbWVudCAhPT0gd2luZG93KSB7XG5cdFx0XHR3aWR0aCA9ICQodGhpcy5vcHRpb25zLnJlc3BvbnNpdmVCYXNlRWxlbWVudCkud2lkdGgoKTtcblx0XHR9IGVsc2UgaWYgKHdpbmRvdy5pbm5lcldpZHRoKSB7XG5cdFx0XHR3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuXHRcdH0gZWxzZSBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCkge1xuXHRcdFx0d2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUud2FybignQ2FuIG5vdCBkZXRlY3Qgdmlld3BvcnQgd2lkdGguJyk7XG5cdFx0fVxuXHRcdHJldHVybiB3aWR0aDtcblx0fTtcblxuXHQvKipcblx0ICogUmVwbGFjZXMgdGhlIGN1cnJlbnQgY29udGVudC5cblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fGpRdWVyeXxTdHJpbmd9IGNvbnRlbnQgLSBUaGUgbmV3IGNvbnRlbnQuXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbihjb250ZW50KSB7XG5cdFx0dGhpcy4kc3RhZ2UuZW1wdHkoKTtcblx0XHR0aGlzLl9pdGVtcyA9IFtdO1xuXG5cdFx0aWYgKGNvbnRlbnQpIHtcblx0XHRcdGNvbnRlbnQgPSAoY29udGVudCBpbnN0YW5jZW9mIGpRdWVyeSkgPyBjb250ZW50IDogJChjb250ZW50KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5zZXR0aW5ncy5uZXN0ZWRJdGVtU2VsZWN0b3IpIHtcblx0XHRcdGNvbnRlbnQgPSBjb250ZW50LmZpbmQoJy4nICsgdGhpcy5zZXR0aW5ncy5uZXN0ZWRJdGVtU2VsZWN0b3IpO1xuXHRcdH1cblxuXHRcdGNvbnRlbnQuZmlsdGVyKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMubm9kZVR5cGUgPT09IDE7XG5cdFx0fSkuZWFjaCgkLnByb3h5KGZ1bmN0aW9uKGluZGV4LCBpdGVtKSB7XG5cdFx0XHRpdGVtID0gdGhpcy5wcmVwYXJlKGl0ZW0pO1xuXHRcdFx0dGhpcy4kc3RhZ2UuYXBwZW5kKGl0ZW0pO1xuXHRcdFx0dGhpcy5faXRlbXMucHVzaChpdGVtKTtcblx0XHRcdHRoaXMuX21lcmdlcnMucHVzaChpdGVtLmZpbmQoJ1tkYXRhLW1lcmdlXScpLmFkZEJhY2soJ1tkYXRhLW1lcmdlXScpLmF0dHIoJ2RhdGEtbWVyZ2UnKSAqIDEgfHwgMSk7XG5cdFx0fSwgdGhpcykpO1xuXG5cdFx0dGhpcy5yZXNldCh0aGlzLmlzTnVtZXJpYyh0aGlzLnNldHRpbmdzLnN0YXJ0UG9zaXRpb24pID8gdGhpcy5zZXR0aW5ncy5zdGFydFBvc2l0aW9uIDogMCk7XG5cblx0XHR0aGlzLmludmFsaWRhdGUoJ2l0ZW1zJyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZHMgYW4gaXRlbS5cblx0ICogQHRvZG8gVXNlIGBpdGVtYCBpbnN0ZWFkIG9mIGBjb250ZW50YCBmb3IgdGhlIGV2ZW50IGFyZ3VtZW50cy5cblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fGpRdWVyeXxTdHJpbmd9IGNvbnRlbnQgLSBUaGUgaXRlbSBjb250ZW50IHRvIGFkZC5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtwb3NpdGlvbl0gLSBUaGUgcmVsYXRpdmUgcG9zaXRpb24gYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBpdGVtIG90aGVyd2lzZSB0aGUgaXRlbSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBlbmQuXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGNvbnRlbnQsIHBvc2l0aW9uKSB7XG5cdFx0dmFyIGN1cnJlbnQgPSB0aGlzLnJlbGF0aXZlKHRoaXMuX2N1cnJlbnQpO1xuXG5cdFx0cG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gdW5kZWZpbmVkID8gdGhpcy5faXRlbXMubGVuZ3RoIDogdGhpcy5ub3JtYWxpemUocG9zaXRpb24sIHRydWUpO1xuXHRcdGNvbnRlbnQgPSBjb250ZW50IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGVudCA6ICQoY29udGVudCk7XG5cblx0XHR0aGlzLnRyaWdnZXIoJ2FkZCcsIHsgY29udGVudDogY29udGVudCwgcG9zaXRpb246IHBvc2l0aW9uIH0pO1xuXG5cdFx0Y29udGVudCA9IHRoaXMucHJlcGFyZShjb250ZW50KTtcblxuXHRcdGlmICh0aGlzLl9pdGVtcy5sZW5ndGggPT09IDAgfHwgcG9zaXRpb24gPT09IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5faXRlbXMubGVuZ3RoID09PSAwICYmIHRoaXMuJHN0YWdlLmFwcGVuZChjb250ZW50KTtcblx0XHRcdHRoaXMuX2l0ZW1zLmxlbmd0aCAhPT0gMCAmJiB0aGlzLl9pdGVtc1twb3NpdGlvbiAtIDFdLmFmdGVyKGNvbnRlbnQpO1xuXHRcdFx0dGhpcy5faXRlbXMucHVzaChjb250ZW50KTtcblx0XHRcdHRoaXMuX21lcmdlcnMucHVzaChjb250ZW50LmZpbmQoJ1tkYXRhLW1lcmdlXScpLmFkZEJhY2soJ1tkYXRhLW1lcmdlXScpLmF0dHIoJ2RhdGEtbWVyZ2UnKSAqIDEgfHwgMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2l0ZW1zW3Bvc2l0aW9uXS5iZWZvcmUoY29udGVudCk7XG5cdFx0XHR0aGlzLl9pdGVtcy5zcGxpY2UocG9zaXRpb24sIDAsIGNvbnRlbnQpO1xuXHRcdFx0dGhpcy5fbWVyZ2Vycy5zcGxpY2UocG9zaXRpb24sIDAsIGNvbnRlbnQuZmluZCgnW2RhdGEtbWVyZ2VdJykuYWRkQmFjaygnW2RhdGEtbWVyZ2VdJykuYXR0cignZGF0YS1tZXJnZScpICogMSB8fCAxKTtcblx0XHR9XG5cblx0XHR0aGlzLl9pdGVtc1tjdXJyZW50XSAmJiB0aGlzLnJlc2V0KHRoaXMuX2l0ZW1zW2N1cnJlbnRdLmluZGV4KCkpO1xuXG5cdFx0dGhpcy5pbnZhbGlkYXRlKCdpdGVtcycpO1xuXG5cdFx0dGhpcy50cmlnZ2VyKCdhZGRlZCcsIHsgY29udGVudDogY29udGVudCwgcG9zaXRpb246IHBvc2l0aW9uIH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGFuIGl0ZW0gYnkgaXRzIHBvc2l0aW9uLlxuXHQgKiBAdG9kbyBVc2UgYGl0ZW1gIGluc3RlYWQgb2YgYGNvbnRlbnRgIGZvciB0aGUgZXZlbnQgYXJndW1lbnRzLlxuXHQgKiBAcHVibGljXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIFRoZSByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgaXRlbSB0byByZW1vdmUuXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG5cdFx0cG9zaXRpb24gPSB0aGlzLm5vcm1hbGl6ZShwb3NpdGlvbiwgdHJ1ZSk7XG5cblx0XHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMudHJpZ2dlcigncmVtb3ZlJywgeyBjb250ZW50OiB0aGlzLl9pdGVtc1twb3NpdGlvbl0sIHBvc2l0aW9uOiBwb3NpdGlvbiB9KTtcblxuXHRcdHRoaXMuX2l0ZW1zW3Bvc2l0aW9uXS5yZW1vdmUoKTtcblx0XHR0aGlzLl9pdGVtcy5zcGxpY2UocG9zaXRpb24sIDEpO1xuXHRcdHRoaXMuX21lcmdlcnMuc3BsaWNlKHBvc2l0aW9uLCAxKTtcblxuXHRcdHRoaXMuaW52YWxpZGF0ZSgnaXRlbXMnKTtcblxuXHRcdHRoaXMudHJpZ2dlcigncmVtb3ZlZCcsIHsgY29udGVudDogbnVsbCwgcG9zaXRpb246IHBvc2l0aW9uIH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQcmVsb2FkcyBpbWFnZXMgd2l0aCBhdXRvIHdpZHRoLlxuXHQgKiBAdG9kbyBSZXBsYWNlIGJ5IGEgbW9yZSBnZW5lcmljIGFwcHJvYWNoXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdE93bC5wcm90b3R5cGUucHJlbG9hZEF1dG9XaWR0aEltYWdlcyA9IGZ1bmN0aW9uKGltYWdlcykge1xuXHRcdGltYWdlcy5lYWNoKCQucHJveHkoZnVuY3Rpb24oaSwgZWxlbWVudCkge1xuXHRcdFx0dGhpcy5lbnRlcigncHJlLWxvYWRpbmcnKTtcblx0XHRcdGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuXHRcdFx0JChuZXcgSW1hZ2UoKSkub25lKCdsb2FkJywgJC5wcm94eShmdW5jdGlvbihlKSB7XG5cdFx0XHRcdGVsZW1lbnQuYXR0cignc3JjJywgZS50YXJnZXQuc3JjKTtcblx0XHRcdFx0ZWxlbWVudC5jc3MoJ29wYWNpdHknLCAxKTtcblx0XHRcdFx0dGhpcy5sZWF2ZSgncHJlLWxvYWRpbmcnKTtcblx0XHRcdFx0IXRoaXMuaXMoJ3ByZS1sb2FkaW5nJykgJiYgIXRoaXMuaXMoJ2luaXRpYWxpemluZycpICYmIHRoaXMucmVmcmVzaCgpO1xuXHRcdFx0fSwgdGhpcykpLmF0dHIoJ3NyYycsIGVsZW1lbnQuYXR0cignc3JjJykgfHwgZWxlbWVudC5hdHRyKCdkYXRhLXNyYycpIHx8IGVsZW1lbnQuYXR0cignZGF0YS1zcmMtcmV0aW5hJykpO1xuXHRcdH0sIHRoaXMpKTtcblx0fTtcblxuXHQvKipcblx0ICogRGVzdHJveXMgdGhlIGNhcm91c2VsLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblxuXHRcdHRoaXMuJGVsZW1lbnQub2ZmKCcub3dsLmNvcmUnKTtcblx0XHR0aGlzLiRzdGFnZS5vZmYoJy5vd2wuY29yZScpO1xuXHRcdCQoZG9jdW1lbnQpLm9mZignLm93bC5jb3JlJyk7XG5cblx0XHRpZiAodGhpcy5zZXR0aW5ncy5yZXNwb25zaXZlICE9PSBmYWxzZSkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlc2l6ZVRpbWVyKTtcblx0XHRcdHRoaXMub2ZmKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX2hhbmRsZXJzLm9uVGhyb3R0bGVkUmVzaXplKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX3BsdWdpbnMpIHtcblx0XHRcdHRoaXMuX3BsdWdpbnNbaV0uZGVzdHJveSgpO1xuXHRcdH1cblxuXHRcdHRoaXMuJHN0YWdlLmNoaWxkcmVuKCcuY2xvbmVkJykucmVtb3ZlKCk7XG5cblx0XHR0aGlzLiRzdGFnZS51bndyYXAoKTtcblx0XHR0aGlzLiRzdGFnZS5jaGlsZHJlbigpLmNvbnRlbnRzKCkudW53cmFwKCk7XG5cdFx0dGhpcy4kc3RhZ2UuY2hpbGRyZW4oKS51bndyYXAoKTtcblx0XHR0aGlzLiRzdGFnZS5yZW1vdmUoKTtcblx0XHR0aGlzLiRlbGVtZW50XG5cdFx0XHQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLnJlZnJlc2hDbGFzcylcblx0XHRcdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMubG9hZGluZ0NsYXNzKVxuXHRcdFx0LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5sb2FkZWRDbGFzcylcblx0XHRcdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMucnRsQ2xhc3MpXG5cdFx0XHQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmRyYWdDbGFzcylcblx0XHRcdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZ3JhYkNsYXNzKVxuXHRcdFx0LmF0dHIoJ2NsYXNzJywgdGhpcy4kZWxlbWVudC5hdHRyKCdjbGFzcycpLnJlcGxhY2UobmV3IFJlZ0V4cCh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZUNsYXNzICsgJy1cXFxcUytcXFxccycsICdnJyksICcnKSlcblx0XHRcdC5yZW1vdmVEYXRhKCdvd2wuY2Fyb3VzZWwnKTtcblx0fTtcblxuXHQvKipcblx0ICogT3BlcmF0b3JzIHRvIGNhbGN1bGF0ZSByaWdodC10by1sZWZ0IGFuZCBsZWZ0LXRvLXJpZ2h0LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYV0gLSBUaGUgbGVmdCBzaWRlIG9wZXJhbmQuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbb10gLSBUaGUgb3BlcmF0b3IuXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbYl0gLSBUaGUgcmlnaHQgc2lkZSBvcGVyYW5kLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5vcCA9IGZ1bmN0aW9uKGEsIG8sIGIpIHtcblx0XHR2YXIgcnRsID0gdGhpcy5zZXR0aW5ncy5ydGw7XG5cdFx0c3dpdGNoIChvKSB7XG5cdFx0XHRjYXNlICc8Jzpcblx0XHRcdFx0cmV0dXJuIHJ0bCA/IGEgPiBiIDogYSA8IGI7XG5cdFx0XHRjYXNlICc+Jzpcblx0XHRcdFx0cmV0dXJuIHJ0bCA/IGEgPCBiIDogYSA+IGI7XG5cdFx0XHRjYXNlICc+PSc6XG5cdFx0XHRcdHJldHVybiBydGwgPyBhIDw9IGIgOiBhID49IGI7XG5cdFx0XHRjYXNlICc8PSc6XG5cdFx0XHRcdHJldHVybiBydGwgPyBhID49IGIgOiBhIDw9IGI7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEF0dGFjaGVzIHRvIGFuIGludGVybmFsIGV2ZW50LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZXZlbnQgc291cmNlLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgLSBUaGUgZXZlbnQgbmFtZS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgZXZlbnQgaGFuZGxlciB0byBhdHRhY2guXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FwdHVyZSAtIFdldGhlciB0aGUgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQgYXQgdGhlIGNhcHR1cmluZyBwaGFzZSBvciBub3QuXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnQsIGxpc3RlbmVyLCBjYXB0dXJlKSB7XG5cdFx0aWYgKGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHRcdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgY2FwdHVyZSk7XG5cdFx0fSBlbHNlIGlmIChlbGVtZW50LmF0dGFjaEV2ZW50KSB7XG5cdFx0XHRlbGVtZW50LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRGV0YWNoZXMgZnJvbSBhbiBpbnRlcm5hbCBldmVudC5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gVGhlIGV2ZW50IHNvdXJjZS5cblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IC0gVGhlIGV2ZW50IG5hbWUuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGF0dGFjaGVkIGV2ZW50IGhhbmRsZXIgdG8gZGV0YWNoLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmUgLSBXZXRoZXIgdGhlIGF0dGFjaGVkIGV2ZW50IGhhbmRsZXIgd2FzIHJlZ2lzdGVyZWQgYXMgYSBjYXB0dXJpbmcgbGlzdGVuZXIgb3Igbm90LlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbihlbGVtZW50LCBldmVudCwgbGlzdGVuZXIsIGNhcHR1cmUpIHtcblx0XHRpZiAoZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG5cdFx0XHRlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBjYXB0dXJlKTtcblx0XHR9IGVsc2UgaWYgKGVsZW1lbnQuZGV0YWNoRXZlbnQpIHtcblx0XHRcdGVsZW1lbnQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUcmlnZ2VycyBhIHB1YmxpYyBldmVudC5cblx0ICogQHRvZG8gUmVtb3ZlIGBzdGF0dXNgLCBgcmVsYXRlZFRhcmdldGAgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSBldmVudCBuYW1lLlxuXHQgKiBAcGFyYW0geyp9IFtkYXRhPW51bGxdIC0gVGhlIGV2ZW50IGRhdGEuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZXNwYWNlPWNhcm91c2VsXSAtIFRoZSBldmVudCBuYW1lc3BhY2UuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbc3RhdGVdIC0gVGhlIHN0YXRlIHdoaWNoIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2VudGVyPWZhbHNlXSAtIEluZGljYXRlcyBpZiB0aGUgY2FsbCBlbnRlcnMgdGhlIHNwZWNpZmllZCBzdGF0ZSBvciBub3QuXG5cdCAqIEByZXR1cm5zIHtFdmVudH0gLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24obmFtZSwgZGF0YSwgbmFtZXNwYWNlLCBzdGF0ZSwgZW50ZXIpIHtcblx0XHR2YXIgc3RhdHVzID0ge1xuXHRcdFx0aXRlbTogeyBjb3VudDogdGhpcy5faXRlbXMubGVuZ3RoLCBpbmRleDogdGhpcy5jdXJyZW50KCkgfVxuXHRcdH0sIGhhbmRsZXIgPSAkLmNhbWVsQ2FzZShcblx0XHRcdCQuZ3JlcChbICdvbicsIG5hbWUsIG5hbWVzcGFjZSBdLCBmdW5jdGlvbih2KSB7IHJldHVybiB2IH0pXG5cdFx0XHRcdC5qb2luKCctJykudG9Mb3dlckNhc2UoKVxuXHRcdCksIGV2ZW50ID0gJC5FdmVudChcblx0XHRcdFsgbmFtZSwgJ293bCcsIG5hbWVzcGFjZSB8fCAnY2Fyb3VzZWwnIF0uam9pbignLicpLnRvTG93ZXJDYXNlKCksXG5cdFx0XHQkLmV4dGVuZCh7IHJlbGF0ZWRUYXJnZXQ6IHRoaXMgfSwgc3RhdHVzLCBkYXRhKVxuXHRcdCk7XG5cblx0XHRpZiAoIXRoaXMuX3N1cHJlc3NbbmFtZV0pIHtcblx0XHRcdCQuZWFjaCh0aGlzLl9wbHVnaW5zLCBmdW5jdGlvbihuYW1lLCBwbHVnaW4pIHtcblx0XHRcdFx0aWYgKHBsdWdpbi5vblRyaWdnZXIpIHtcblx0XHRcdFx0XHRwbHVnaW4ub25UcmlnZ2VyKGV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMucmVnaXN0ZXIoeyB0eXBlOiBPd2wuVHlwZS5FdmVudCwgbmFtZTogbmFtZSB9KTtcblx0XHRcdHRoaXMuJGVsZW1lbnQudHJpZ2dlcihldmVudCk7XG5cblx0XHRcdGlmICh0aGlzLnNldHRpbmdzICYmIHR5cGVvZiB0aGlzLnNldHRpbmdzW2hhbmRsZXJdID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHRoaXMuc2V0dGluZ3NbaGFuZGxlcl0uY2FsbCh0aGlzLCBldmVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbnRlcnMgYSBzdGF0ZS5cblx0ICogQHBhcmFtIG5hbWUgLSBUaGUgc3RhdGUgbmFtZS5cblx0ICovXG5cdE93bC5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG5cdFx0JC5lYWNoKFsgbmFtZSBdLmNvbmNhdCh0aGlzLl9zdGF0ZXMudGFnc1tuYW1lXSB8fCBbXSksICQucHJveHkoZnVuY3Rpb24oaSwgbmFtZSkge1xuXHRcdFx0aWYgKHRoaXMuX3N0YXRlcy5jdXJyZW50W25hbWVdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy5fc3RhdGVzLmN1cnJlbnRbbmFtZV0gPSAwO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9zdGF0ZXMuY3VycmVudFtuYW1lXSsrO1xuXHRcdH0sIHRoaXMpKTtcblx0fTtcblxuXHQvKipcblx0ICogTGVhdmVzIGEgc3RhdGUuXG5cdCAqIEBwYXJhbSBuYW1lIC0gVGhlIHN0YXRlIG5hbWUuXG5cdCAqL1xuXHRPd2wucHJvdG90eXBlLmxlYXZlID0gZnVuY3Rpb24obmFtZSkge1xuXHRcdCQuZWFjaChbIG5hbWUgXS5jb25jYXQodGhpcy5fc3RhdGVzLnRhZ3NbbmFtZV0gfHwgW10pLCAkLnByb3h5KGZ1bmN0aW9uKGksIG5hbWUpIHtcblx0XHRcdHRoaXMuX3N0YXRlcy5jdXJyZW50W25hbWVdLS07XG5cdFx0fSwgdGhpcykpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYW4gZXZlbnQgb3Igc3RhdGUuXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBldmVudCBvciBzdGF0ZSB0byByZWdpc3Rlci5cblx0ICovXG5cdE93bC5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbihvYmplY3QpIHtcblx0XHRpZiAob2JqZWN0LnR5cGUgPT09IE93bC5UeXBlLkV2ZW50KSB7XG5cdFx0XHRpZiAoISQuZXZlbnQuc3BlY2lhbFtvYmplY3QubmFtZV0pIHtcblx0XHRcdFx0JC5ldmVudC5zcGVjaWFsW29iamVjdC5uYW1lXSA9IHt9O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoISQuZXZlbnQuc3BlY2lhbFtvYmplY3QubmFtZV0ub3dsKSB7XG5cdFx0XHRcdHZhciBfZGVmYXVsdCA9ICQuZXZlbnQuc3BlY2lhbFtvYmplY3QubmFtZV0uX2RlZmF1bHQ7XG5cdFx0XHRcdCQuZXZlbnQuc3BlY2lhbFtvYmplY3QubmFtZV0uX2RlZmF1bHQgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0aWYgKF9kZWZhdWx0ICYmIF9kZWZhdWx0LmFwcGx5ICYmICghZS5uYW1lc3BhY2UgfHwgZS5uYW1lc3BhY2UuaW5kZXhPZignb3dsJykgPT09IC0xKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIF9kZWZhdWx0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBlLm5hbWVzcGFjZSAmJiBlLm5hbWVzcGFjZS5pbmRleE9mKCdvd2wnKSA+IC0xO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHQkLmV2ZW50LnNwZWNpYWxbb2JqZWN0Lm5hbWVdLm93bCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChvYmplY3QudHlwZSA9PT0gT3dsLlR5cGUuU3RhdGUpIHtcblx0XHRcdGlmICghdGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdKSB7XG5cdFx0XHRcdHRoaXMuX3N0YXRlcy50YWdzW29iamVjdC5uYW1lXSA9IG9iamVjdC50YWdzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdID0gdGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdLmNvbmNhdChvYmplY3QudGFncyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3N0YXRlcy50YWdzW29iamVjdC5uYW1lXSA9ICQuZ3JlcCh0aGlzLl9zdGF0ZXMudGFnc1tvYmplY3QubmFtZV0sICQucHJveHkoZnVuY3Rpb24odGFnLCBpKSB7XG5cdFx0XHRcdHJldHVybiAkLmluQXJyYXkodGFnLCB0aGlzLl9zdGF0ZXMudGFnc1tvYmplY3QubmFtZV0pID09PSBpO1xuXHRcdFx0fSwgdGhpcykpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogU3VwcHJlc3NlcyBldmVudHMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gZXZlbnRzIC0gVGhlIGV2ZW50cyB0byBzdXBwcmVzcy5cblx0ICovXG5cdE93bC5wcm90b3R5cGUuc3VwcHJlc3MgPSBmdW5jdGlvbihldmVudHMpIHtcblx0XHQkLmVhY2goZXZlbnRzLCAkLnByb3h5KGZ1bmN0aW9uKGluZGV4LCBldmVudCkge1xuXHRcdFx0dGhpcy5fc3VwcmVzc1tldmVudF0gPSB0cnVlO1xuXHRcdH0sIHRoaXMpKTtcblx0fTtcblxuXHQvKipcblx0ICogUmVsZWFzZXMgc3VwcHJlc3NlZCBldmVudHMuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gZXZlbnRzIC0gVGhlIGV2ZW50cyB0byByZWxlYXNlLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24oZXZlbnRzKSB7XG5cdFx0JC5lYWNoKGV2ZW50cywgJC5wcm94eShmdW5jdGlvbihpbmRleCwgZXZlbnQpIHtcblx0XHRcdGRlbGV0ZSB0aGlzLl9zdXByZXNzW2V2ZW50XTtcblx0XHR9LCB0aGlzKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldHMgdW5pZmllZCBwb2ludGVyIGNvb3JkaW5hdGVzIGZyb20gZXZlbnQuXG5cdCAqIEB0b2RvICMyNjFcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge0V2ZW50fSAtIFRoZSBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnQuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IC0gQ29udGFpbnMgYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgb2YgY3VycmVudCBwb2ludGVyIHBvc2l0aW9uLlxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5wb2ludGVyID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgcmVzdWx0ID0geyB4OiBudWxsLCB5OiBudWxsIH07XG5cblx0XHRldmVudCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQgfHwgZXZlbnQgfHwgd2luZG93LmV2ZW50O1xuXG5cdFx0ZXZlbnQgPSBldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID9cblx0XHRcdGV2ZW50LnRvdWNoZXNbMF0gOiBldmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggP1xuXHRcdFx0XHRldmVudC5jaGFuZ2VkVG91Y2hlc1swXSA6IGV2ZW50O1xuXG5cdFx0aWYgKGV2ZW50LnBhZ2VYKSB7XG5cdFx0XHRyZXN1bHQueCA9IGV2ZW50LnBhZ2VYO1xuXHRcdFx0cmVzdWx0LnkgPSBldmVudC5wYWdlWTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0LnggPSBldmVudC5jbGllbnRYO1xuXHRcdFx0cmVzdWx0LnkgPSBldmVudC5jbGllbnRZO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIGlucHV0IGlzIGEgTnVtYmVyIG9yIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGEgTnVtYmVyXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfE9iamVjdHxBcnJheXxCb29sZWFufFJlZ0V4cHxGdW5jdGlvbnxTeW1ib2x9IC0gVGhlIGlucHV0IHRvIGJlIHRlc3RlZFxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSBBbiBpbmRpY2F0aW9uIGlmIHRoZSBpbnB1dCBpcyBhIE51bWJlciBvciBjYW4gYmUgY29lcmNlZCB0byBhIE51bWJlclxuXHQgKi9cblx0T3dsLnByb3RvdHlwZS5pc051bWVyaWMgPSBmdW5jdGlvbihudW1iZXIpIHtcblx0XHRyZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobnVtYmVyKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGRpZmZlcmVuY2Ugb2YgdHdvIHZlY3RvcnMuXG5cdCAqIEB0b2RvICMyNjFcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gLSBUaGUgZmlyc3QgdmVjdG9yLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gLSBUaGUgc2Vjb25kIHZlY3Rvci5cblx0ICogQHJldHVybnMge09iamVjdH0gLSBUaGUgZGlmZmVyZW5jZS5cblx0ICovXG5cdE93bC5wcm90b3R5cGUuZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGZpcnN0LCBzZWNvbmQpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogZmlyc3QueCAtIHNlY29uZC54LFxuXHRcdFx0eTogZmlyc3QueSAtIHNlY29uZC55XG5cdFx0fTtcblx0fTtcblxuXHQvKipcblx0ICogVGhlIGpRdWVyeSBQbHVnaW4gZm9yIHRoZSBPd2wgQ2Fyb3VzZWxcblx0ICogQHRvZG8gTmF2aWdhdGlvbiBwbHVnaW4gYG5leHRgIGFuZCBgcHJldmBcblx0ICogQHB1YmxpY1xuXHQgKi9cblx0JC5mbi5vd2xDYXJvdXNlbCA9IGZ1bmN0aW9uKG9wdGlvbikge1xuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgJHRoaXMgPSAkKHRoaXMpLFxuXHRcdFx0XHRkYXRhID0gJHRoaXMuZGF0YSgnb3dsLmNhcm91c2VsJyk7XG5cblx0XHRcdGlmICghZGF0YSkge1xuXHRcdFx0XHRkYXRhID0gbmV3IE93bCh0aGlzLCB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvbik7XG5cdFx0XHRcdCR0aGlzLmRhdGEoJ293bC5jYXJvdXNlbCcsIGRhdGEpO1xuXG5cdFx0XHRcdCQuZWFjaChbXG5cdFx0XHRcdFx0J25leHQnLCAncHJldicsICd0bycsICdkZXN0cm95JywgJ3JlZnJlc2gnLCAncmVwbGFjZScsICdhZGQnLCAncmVtb3ZlJ1xuXHRcdFx0XHRdLCBmdW5jdGlvbihpLCBldmVudCkge1xuXHRcdFx0XHRcdGRhdGEucmVnaXN0ZXIoeyB0eXBlOiBPd2wuVHlwZS5FdmVudCwgbmFtZTogZXZlbnQgfSk7XG5cdFx0XHRcdFx0ZGF0YS4kZWxlbWVudC5vbihldmVudCArICcub3dsLmNhcm91c2VsLmNvcmUnLCAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRcdGlmIChlLm5hbWVzcGFjZSAmJiBlLnJlbGF0ZWRUYXJnZXQgIT09IHRoaXMpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zdXBwcmVzcyhbIGV2ZW50IF0pO1xuXHRcdFx0XHRcdFx0XHRkYXRhW2V2ZW50XS5hcHBseSh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnJlbGVhc2UoWyBldmVudCBdKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LCBkYXRhKSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJyAmJiBvcHRpb24uY2hhckF0KDApICE9PSAnXycpIHtcblx0XHRcdFx0ZGF0YVtvcHRpb25dLmFwcGx5KGRhdGEsIGFyZ3MpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgY29uc3RydWN0b3IgZm9yIHRoZSBqUXVlcnkgUGx1Z2luXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdCQuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IgPSBPd2w7XG5cbn0pKHdpbmRvdy5aZXB0byB8fCB3aW5kb3cualF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcblxuLyoqXG4gKiBBdXRvUmVmcmVzaCBQbHVnaW5cbiAqIEB2ZXJzaW9uIDIuMy40XG4gKiBAYXV0aG9yIEFydHVzIEtvbGFub3dza2lcbiAqIEBhdXRob3IgRGF2aWQgRGV1dHNjaFxuICogQGxpY2Vuc2UgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKi9cbjsoZnVuY3Rpb24oJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgdGhlIGF1dG8gcmVmcmVzaCBwbHVnaW4uXG5cdCAqIEBjbGFzcyBUaGUgQXV0byBSZWZyZXNoIFBsdWdpblxuXHQgKiBAcGFyYW0ge093bH0gY2Fyb3VzZWwgLSBUaGUgT3dsIENhcm91c2VsXG5cdCAqL1xuXHR2YXIgQXV0b1JlZnJlc2ggPSBmdW5jdGlvbihjYXJvdXNlbCkge1xuXHRcdC8qKlxuXHRcdCAqIFJlZmVyZW5jZSB0byB0aGUgY29yZS5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge093bH1cblx0XHQgKi9cblx0XHR0aGlzLl9jb3JlID0gY2Fyb3VzZWw7XG5cblx0XHQvKipcblx0XHQgKiBSZWZyZXNoIGludGVydmFsLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7bnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMuX2ludGVydmFsID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgY3VycmVudGx5IHZpc2libGUgb3Igbm90LlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHR0aGlzLl92aXNpYmxlID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEFsbCBldmVudCBoYW5kbGVycy5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLl9oYW5kbGVycyA9IHtcblx0XHRcdCdpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b1JlZnJlc2gpIHtcblx0XHRcdFx0XHR0aGlzLndhdGNoKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMpXG5cdFx0fTtcblxuXHRcdC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcblx0XHR0aGlzLl9jb3JlLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgQXV0b1JlZnJlc2guRGVmYXVsdHMsIHRoaXMuX2NvcmUub3B0aW9ucyk7XG5cblx0XHQvLyByZWdpc3RlciBldmVudCBoYW5kbGVyc1xuXHRcdHRoaXMuX2NvcmUuJGVsZW1lbnQub24odGhpcy5faGFuZGxlcnMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZWZhdWx0IG9wdGlvbnMuXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdEF1dG9SZWZyZXNoLkRlZmF1bHRzID0ge1xuXHRcdGF1dG9SZWZyZXNoOiB0cnVlLFxuXHRcdGF1dG9SZWZyZXNoSW50ZXJ2YWw6IDUwMFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBXYXRjaGVzIHRoZSBlbGVtZW50LlxuXHQgKi9cblx0QXV0b1JlZnJlc2gucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2ludGVydmFsKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fdmlzaWJsZSA9IHRoaXMuX2NvcmUuaXNWaXNpYmxlKCk7XG5cdFx0dGhpcy5faW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoJC5wcm94eSh0aGlzLnJlZnJlc2gsIHRoaXMpLCB0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9SZWZyZXNoSW50ZXJ2YWwpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZWZyZXNoZXMgdGhlIGVsZW1lbnQuXG5cdCAqL1xuXHRBdXRvUmVmcmVzaC5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9jb3JlLmlzVmlzaWJsZSgpID09PSB0aGlzLl92aXNpYmxlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fdmlzaWJsZSA9ICF0aGlzLl92aXNpYmxlO1xuXG5cdFx0dGhpcy5fY29yZS4kZWxlbWVudC50b2dnbGVDbGFzcygnb3dsLWhpZGRlbicsICF0aGlzLl92aXNpYmxlKTtcblxuXHRcdHRoaXMuX3Zpc2libGUgJiYgKHRoaXMuX2NvcmUuaW52YWxpZGF0ZSgnd2lkdGgnKSAmJiB0aGlzLl9jb3JlLnJlZnJlc2goKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERlc3Ryb3lzIHRoZSBwbHVnaW4uXG5cdCAqL1xuXHRBdXRvUmVmcmVzaC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYW5kbGVyLCBwcm9wZXJ0eTtcblxuXHRcdHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKTtcblxuXHRcdGZvciAoaGFuZGxlciBpbiB0aGlzLl9oYW5kbGVycykge1xuXHRcdFx0dGhpcy5fY29yZS4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5faGFuZGxlcnNbaGFuZGxlcl0pO1xuXHRcdH1cblx0XHRmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XG5cdFx0XHR0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gJ2Z1bmN0aW9uJyAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcblx0XHR9XG5cdH07XG5cblx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLkF1dG9SZWZyZXNoID0gQXV0b1JlZnJlc2g7XG5cbn0pKHdpbmRvdy5aZXB0byB8fCB3aW5kb3cualF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcblxuLyoqXG4gKiBMYXp5IFBsdWdpblxuICogQHZlcnNpb24gMi4zLjRcbiAqIEBhdXRob3IgQmFydG9zeiBXb2pjaWVjaG93c2tpXG4gKiBAYXV0aG9yIERhdmlkIERldXRzY2hcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICovXG47KGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIHRoZSBsYXp5IHBsdWdpbi5cblx0ICogQGNsYXNzIFRoZSBMYXp5IFBsdWdpblxuXHQgKiBAcGFyYW0ge093bH0gY2Fyb3VzZWwgLSBUaGUgT3dsIENhcm91c2VsXG5cdCAqL1xuXHR2YXIgTGF6eSA9IGZ1bmN0aW9uKGNhcm91c2VsKSB7XG5cblx0XHQvKipcblx0XHQgKiBSZWZlcmVuY2UgdG8gdGhlIGNvcmUuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtPd2x9XG5cdFx0ICovXG5cdFx0dGhpcy5fY29yZSA9IGNhcm91c2VsO1xuXG5cdFx0LyoqXG5cdFx0ICogQWxyZWFkeSBsb2FkZWQgaXRlbXMuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtBcnJheS48alF1ZXJ5Pn1cblx0XHQgKi9cblx0XHR0aGlzLl9sb2FkZWQgPSBbXTtcblxuXHRcdC8qKlxuXHRcdCAqIEV2ZW50IGhhbmRsZXJzLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMuX2hhbmRsZXJzID0ge1xuXHRcdFx0J2luaXRpYWxpemVkLm93bC5jYXJvdXNlbCBjaGFuZ2Uub3dsLmNhcm91c2VsIHJlc2l6ZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XG5cdFx0XHRcdGlmICghZS5uYW1lc3BhY2UpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIXRoaXMuX2NvcmUuc2V0dGluZ3MgfHwgIXRoaXMuX2NvcmUuc2V0dGluZ3MubGF6eUxvYWQpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoKGUucHJvcGVydHkgJiYgZS5wcm9wZXJ0eS5uYW1lID09ICdwb3NpdGlvbicpIHx8IGUudHlwZSA9PSAnaW5pdGlhbGl6ZWQnKSB7XG5cdFx0XHRcdFx0dmFyIHNldHRpbmdzID0gdGhpcy5fY29yZS5zZXR0aW5ncyxcblx0XHRcdFx0XHRcdG4gPSAoc2V0dGluZ3MuY2VudGVyICYmIE1hdGguY2VpbChzZXR0aW5ncy5pdGVtcyAvIDIpIHx8IHNldHRpbmdzLml0ZW1zKSxcblx0XHRcdFx0XHRcdGkgPSAoKHNldHRpbmdzLmNlbnRlciAmJiBuICogLTEpIHx8IDApLFxuXHRcdFx0XHRcdFx0cG9zaXRpb24gPSAoZS5wcm9wZXJ0eSAmJiBlLnByb3BlcnR5LnZhbHVlICE9PSB1bmRlZmluZWQgPyBlLnByb3BlcnR5LnZhbHVlIDogdGhpcy5fY29yZS5jdXJyZW50KCkpICsgaSxcblx0XHRcdFx0XHRcdGNsb25lcyA9IHRoaXMuX2NvcmUuY2xvbmVzKCkubGVuZ3RoLFxuXHRcdFx0XHRcdFx0bG9hZCA9ICQucHJveHkoZnVuY3Rpb24oaSwgdikgeyB0aGlzLmxvYWQodikgfSwgdGhpcyk7XG5cdFx0XHRcdFx0Ly9UT0RPOiBOZWVkIGRvY3VtZW50YXRpb24gZm9yIHRoaXMgbmV3IG9wdGlvblxuXHRcdFx0XHRcdGlmIChzZXR0aW5ncy5sYXp5TG9hZEVhZ2VyID4gMCkge1xuXHRcdFx0XHRcdFx0biArPSBzZXR0aW5ncy5sYXp5TG9hZEVhZ2VyO1xuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIGNhcm91c2VsIGlzIGxvb3BpbmcgYWxzbyBwcmVsb2FkIGltYWdlcyB0aGF0IGFyZSB0byB0aGUgXCJsZWZ0XCJcblx0XHRcdFx0XHRcdGlmIChzZXR0aW5ncy5sb29wKSB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uIC09IHNldHRpbmdzLmxhenlMb2FkRWFnZXI7XG4gICAgICAgICAgICAgIG4rKztcbiAgICAgICAgICAgIH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR3aGlsZSAoaSsrIDwgbikge1xuXHRcdFx0XHRcdFx0dGhpcy5sb2FkKGNsb25lcyAvIDIgKyB0aGlzLl9jb3JlLnJlbGF0aXZlKHBvc2l0aW9uKSk7XG5cdFx0XHRcdFx0XHRjbG9uZXMgJiYgJC5lYWNoKHRoaXMuX2NvcmUuY2xvbmVzKHRoaXMuX2NvcmUucmVsYXRpdmUocG9zaXRpb24pKSwgbG9hZCk7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbisrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcylcblx0XHR9O1xuXG5cdFx0Ly8gc2V0IHRoZSBkZWZhdWx0IG9wdGlvbnNcblx0XHR0aGlzLl9jb3JlLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgTGF6eS5EZWZhdWx0cywgdGhpcy5fY29yZS5vcHRpb25zKTtcblxuXHRcdC8vIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJcblx0XHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcblx0fTtcblxuXHQvKipcblx0ICogRGVmYXVsdCBvcHRpb25zLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRMYXp5LkRlZmF1bHRzID0ge1xuXHRcdGxhenlMb2FkOiBmYWxzZSxcblx0XHRsYXp5TG9hZEVhZ2VyOiAwXG5cdH07XG5cblx0LyoqXG5cdCAqIExvYWRzIGFsbCByZXNvdXJjZXMgb2YgYW4gaXRlbSBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdExhenkucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbihwb3NpdGlvbikge1xuXHRcdHZhciAkaXRlbSA9IHRoaXMuX2NvcmUuJHN0YWdlLmNoaWxkcmVuKCkuZXEocG9zaXRpb24pLFxuXHRcdFx0JGVsZW1lbnRzID0gJGl0ZW0gJiYgJGl0ZW0uZmluZCgnLm93bC1sYXp5Jyk7XG5cblx0XHRpZiAoISRlbGVtZW50cyB8fCAkLmluQXJyYXkoJGl0ZW0uZ2V0KDApLCB0aGlzLl9sb2FkZWQpID4gLTEpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQkZWxlbWVudHMuZWFjaCgkLnByb3h5KGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50KSB7XG5cdFx0XHR2YXIgJGVsZW1lbnQgPSAkKGVsZW1lbnQpLCBpbWFnZSxcbiAgICAgICAgICAgICAgICB1cmwgPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gPiAxICYmICRlbGVtZW50LmF0dHIoJ2RhdGEtc3JjLXJldGluYScpKSB8fCAkZWxlbWVudC5hdHRyKCdkYXRhLXNyYycpIHx8ICRlbGVtZW50LmF0dHIoJ2RhdGEtc3Jjc2V0Jyk7XG5cblx0XHRcdHRoaXMuX2NvcmUudHJpZ2dlcignbG9hZCcsIHsgZWxlbWVudDogJGVsZW1lbnQsIHVybDogdXJsIH0sICdsYXp5Jyk7XG5cblx0XHRcdGlmICgkZWxlbWVudC5pcygnaW1nJykpIHtcblx0XHRcdFx0JGVsZW1lbnQub25lKCdsb2FkLm93bC5sYXp5JywgJC5wcm94eShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQkZWxlbWVudC5jc3MoJ29wYWNpdHknLCAxKTtcblx0XHRcdFx0XHR0aGlzLl9jb3JlLnRyaWdnZXIoJ2xvYWRlZCcsIHsgZWxlbWVudDogJGVsZW1lbnQsIHVybDogdXJsIH0sICdsYXp5Jyk7XG5cdFx0XHRcdH0sIHRoaXMpKS5hdHRyKCdzcmMnLCB1cmwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkZWxlbWVudC5pcygnc291cmNlJykpIHtcbiAgICAgICAgICAgICAgICAkZWxlbWVudC5vbmUoJ2xvYWQub3dsLmxhenknLCAkLnByb3h5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb3JlLnRyaWdnZXIoJ2xvYWRlZCcsIHsgZWxlbWVudDogJGVsZW1lbnQsIHVybDogdXJsIH0sICdsYXp5Jyk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpLmF0dHIoJ3NyY3NldCcsIHVybCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpbWFnZSA9IG5ldyBJbWFnZSgpO1xuXHRcdFx0XHRpbWFnZS5vbmxvYWQgPSAkLnByb3h5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdCRlbGVtZW50LmNzcyh7XG5cdFx0XHRcdFx0XHQnYmFja2dyb3VuZC1pbWFnZSc6ICd1cmwoXCInICsgdXJsICsgJ1wiKScsXG5cdFx0XHRcdFx0XHQnb3BhY2l0eSc6ICcxJ1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHRoaXMuX2NvcmUudHJpZ2dlcignbG9hZGVkJywgeyBlbGVtZW50OiAkZWxlbWVudCwgdXJsOiB1cmwgfSwgJ2xhenknKTtcblx0XHRcdFx0fSwgdGhpcyk7XG5cdFx0XHRcdGltYWdlLnNyYyA9IHVybDtcblx0XHRcdH1cblx0XHR9LCB0aGlzKSk7XG5cblx0XHR0aGlzLl9sb2FkZWQucHVzaCgkaXRlbS5nZXQoMCkpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRMYXp5LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhhbmRsZXIsIHByb3BlcnR5O1xuXG5cdFx0Zm9yIChoYW5kbGVyIGluIHRoaXMuaGFuZGxlcnMpIHtcblx0XHRcdHRoaXMuX2NvcmUuJGVsZW1lbnQub2ZmKGhhbmRsZXIsIHRoaXMuaGFuZGxlcnNbaGFuZGxlcl0pO1xuXHRcdH1cblx0XHRmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XG5cdFx0XHR0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gJ2Z1bmN0aW9uJyAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcblx0XHR9XG5cdH07XG5cblx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLkxhenkgPSBMYXp5O1xuXG59KSh3aW5kb3cuWmVwdG8gfHwgd2luZG93LmpRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XG5cbi8qKlxuICogQXV0b0hlaWdodCBQbHVnaW5cbiAqIEB2ZXJzaW9uIDIuMy40XG4gKiBAYXV0aG9yIEJhcnRvc3ogV29qY2llY2hvd3NraVxuICogQGF1dGhvciBEYXZpZCBEZXV0c2NoXG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqL1xuOyhmdW5jdGlvbigkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcblxuXHQvKipcblx0ICogQ3JlYXRlcyB0aGUgYXV0byBoZWlnaHQgcGx1Z2luLlxuXHQgKiBAY2xhc3MgVGhlIEF1dG8gSGVpZ2h0IFBsdWdpblxuXHQgKiBAcGFyYW0ge093bH0gY2Fyb3VzZWwgLSBUaGUgT3dsIENhcm91c2VsXG5cdCAqL1xuXHR2YXIgQXV0b0hlaWdodCA9IGZ1bmN0aW9uKGNhcm91c2VsKSB7XG5cdFx0LyoqXG5cdFx0ICogUmVmZXJlbmNlIHRvIHRoZSBjb3JlLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7T3dsfVxuXHRcdCAqL1xuXHRcdHRoaXMuX2NvcmUgPSBjYXJvdXNlbDtcblxuXHRcdHRoaXMuX3ByZXZpb3VzSGVpZ2h0ID0gbnVsbDtcblxuXHRcdC8qKlxuXHRcdCAqIEFsbCBldmVudCBoYW5kbGVycy5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLl9oYW5kbGVycyA9IHtcblx0XHRcdCdpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWwgcmVmcmVzaGVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvSGVpZ2h0KSB7XG5cdFx0XHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcyksXG5cdFx0XHQnY2hhbmdlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b0hlaWdodCAmJiBlLnByb3BlcnR5Lm5hbWUgPT09ICdwb3NpdGlvbicpe1xuXHRcdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMpLFxuXHRcdFx0J2xvYWRlZC5vd2wubGF6eSc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvSGVpZ2h0XG5cdFx0XHRcdFx0JiYgZS5lbGVtZW50LmNsb3Nlc3QoJy4nICsgdGhpcy5fY29yZS5zZXR0aW5ncy5pdGVtQ2xhc3MpLmluZGV4KCkgPT09IHRoaXMuX2NvcmUuY3VycmVudCgpKSB7XG5cdFx0XHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcylcblx0XHR9O1xuXG5cdFx0Ly8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuXHRcdHRoaXMuX2NvcmUub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBBdXRvSGVpZ2h0LkRlZmF1bHRzLCB0aGlzLl9jb3JlLm9wdGlvbnMpO1xuXG5cdFx0Ly8gcmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnNcblx0XHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcblx0XHR0aGlzLl9pbnRlcnZhbElkID0gbnVsbDtcblx0XHR2YXIgcmVmVGhpcyA9IHRoaXM7XG5cblx0XHQvLyBUaGVzZSBjaGFuZ2VzIGhhdmUgYmVlbiB0YWtlbiBmcm9tIGEgUFIgYnkgZ2F2cm9jaGVsZWdub3UgcHJvcG9zZWQgaW4gIzE1NzVcblx0XHQvLyBhbmQgaGF2ZSBiZWVuIG1hZGUgY29tcGF0aWJsZSB3aXRoIHRoZSBsYXRlc3QgalF1ZXJ5IHZlcnNpb25cblx0XHQkKHdpbmRvdykub24oJ2xvYWQnLCBmdW5jdGlvbigpIHtcblx0XHRcdGlmIChyZWZUaGlzLl9jb3JlLnNldHRpbmdzLmF1dG9IZWlnaHQpIHtcblx0XHRcdFx0cmVmVGhpcy51cGRhdGUoKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEF1dG9yZXNpemUgdGhlIGhlaWdodCBvZiB0aGUgY2Fyb3VzZWwgd2hlbiB3aW5kb3cgaXMgcmVzaXplZFxuXHRcdC8vIFdoZW4gY2Fyb3VzZWwgaGFzIGltYWdlcywgdGhlIGhlaWdodCBpcyBkZXBlbmRlbnQgb24gdGhlIHdpZHRoXG5cdFx0Ly8gYW5kIHNob3VsZCBhbHNvIGNoYW5nZSBvbiByZXNpemVcblx0XHQkKHdpbmRvdykucmVzaXplKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHJlZlRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b0hlaWdodCkge1xuXHRcdFx0XHRpZiAocmVmVGhpcy5faW50ZXJ2YWxJZCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHJlZlRoaXMuX2ludGVydmFsSWQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVmVGhpcy5faW50ZXJ2YWxJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmVmVGhpcy51cGRhdGUoKTtcblx0XHRcdFx0fSwgMjUwKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZWZhdWx0IG9wdGlvbnMuXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdEF1dG9IZWlnaHQuRGVmYXVsdHMgPSB7XG5cdFx0YXV0b0hlaWdodDogZmFsc2UsXG5cdFx0YXV0b0hlaWdodENsYXNzOiAnb3dsLWhlaWdodCdcblx0fTtcblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgdmlldy5cblx0ICovXG5cdEF1dG9IZWlnaHQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzdGFydCA9IHRoaXMuX2NvcmUuX2N1cnJlbnQsXG5cdFx0XHRlbmQgPSBzdGFydCArIHRoaXMuX2NvcmUuc2V0dGluZ3MuaXRlbXMsXG5cdFx0XHRsYXp5TG9hZEVuYWJsZWQgPSB0aGlzLl9jb3JlLnNldHRpbmdzLmxhenlMb2FkLFxuXHRcdFx0dmlzaWJsZSA9IHRoaXMuX2NvcmUuJHN0YWdlLmNoaWxkcmVuKCkudG9BcnJheSgpLnNsaWNlKHN0YXJ0LCBlbmQpLFxuXHRcdFx0aGVpZ2h0cyA9IFtdLFxuXHRcdFx0bWF4aGVpZ2h0ID0gMDtcblxuXHRcdCQuZWFjaCh2aXNpYmxlLCBmdW5jdGlvbihpbmRleCwgaXRlbSkge1xuXHRcdFx0aGVpZ2h0cy5wdXNoKCQoaXRlbSkuaGVpZ2h0KCkpO1xuXHRcdH0pO1xuXG5cdFx0bWF4aGVpZ2h0ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgaGVpZ2h0cyk7XG5cblx0XHRpZiAobWF4aGVpZ2h0IDw9IDEgJiYgbGF6eUxvYWRFbmFibGVkICYmIHRoaXMuX3ByZXZpb3VzSGVpZ2h0KSB7XG5cdFx0XHRtYXhoZWlnaHQgPSB0aGlzLl9wcmV2aW91c0hlaWdodDtcblx0XHR9XG5cblx0XHR0aGlzLl9wcmV2aW91c0hlaWdodCA9IG1heGhlaWdodDtcblxuXHRcdHRoaXMuX2NvcmUuJHN0YWdlLnBhcmVudCgpXG5cdFx0XHQuaGVpZ2h0KG1heGhlaWdodClcblx0XHRcdC5hZGRDbGFzcyh0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9IZWlnaHRDbGFzcyk7XG5cdH07XG5cblx0QXV0b0hlaWdodC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYW5kbGVyLCBwcm9wZXJ0eTtcblxuXHRcdGZvciAoaGFuZGxlciBpbiB0aGlzLl9oYW5kbGVycykge1xuXHRcdFx0dGhpcy5fY29yZS4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5faGFuZGxlcnNbaGFuZGxlcl0pO1xuXHRcdH1cblx0XHRmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XG5cdFx0XHR0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT09ICdmdW5jdGlvbicgJiYgKHRoaXNbcHJvcGVydHldID0gbnVsbCk7XG5cdFx0fVxuXHR9O1xuXG5cdCQuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IuUGx1Z2lucy5BdXRvSGVpZ2h0ID0gQXV0b0hlaWdodDtcblxufSkod2luZG93LlplcHRvIHx8IHdpbmRvdy5qUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xuXG4vKipcbiAqIFZpZGVvIFBsdWdpblxuICogQHZlcnNpb24gMi4zLjRcbiAqIEBhdXRob3IgQmFydG9zeiBXb2pjaWVjaG93c2tpXG4gKiBAYXV0aG9yIERhdmlkIERldXRzY2hcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICovXG47KGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIHRoZSB2aWRlbyBwbHVnaW4uXG5cdCAqIEBjbGFzcyBUaGUgVmlkZW8gUGx1Z2luXG5cdCAqIEBwYXJhbSB7T3dsfSBjYXJvdXNlbCAtIFRoZSBPd2wgQ2Fyb3VzZWxcblx0ICovXG5cdHZhciBWaWRlbyA9IGZ1bmN0aW9uKGNhcm91c2VsKSB7XG5cdFx0LyoqXG5cdFx0ICogUmVmZXJlbmNlIHRvIHRoZSBjb3JlLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7T3dsfVxuXHRcdCAqL1xuXHRcdHRoaXMuX2NvcmUgPSBjYXJvdXNlbDtcblxuXHRcdC8qKlxuXHRcdCAqIENhY2hlIGFsbCB2aWRlbyBVUkxzLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMuX3ZpZGVvcyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogQ3VycmVudCBwbGF5aW5nIGl0ZW0uXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtqUXVlcnl9XG5cdFx0ICovXG5cdFx0dGhpcy5fcGxheWluZyA9IG51bGw7XG5cblx0XHQvKipcblx0XHQgKiBBbGwgZXZlbnQgaGFuZGxlcnMuXG5cdFx0ICogQHRvZG8gVGhlIGNsb25lZCBjb250ZW50IHJlbW92YWxlIGlzIHRvbyBsYXRlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy5faGFuZGxlcnMgPSB7XG5cdFx0XHQnaW5pdGlhbGl6ZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XG5cdFx0XHRcdGlmIChlLm5hbWVzcGFjZSkge1xuXHRcdFx0XHRcdHRoaXMuX2NvcmUucmVnaXN0ZXIoeyB0eXBlOiAnc3RhdGUnLCBuYW1lOiAncGxheWluZycsIHRhZ3M6IFsgJ2ludGVyYWN0aW5nJyBdIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0aGlzKSxcblx0XHRcdCdyZXNpemUub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XG5cdFx0XHRcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLnNldHRpbmdzLnZpZGVvICYmIHRoaXMuaXNJbkZ1bGxTY3JlZW4oKSkge1xuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcyksXG5cdFx0XHQncmVmcmVzaGVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5pcygncmVzaXppbmcnKSkge1xuXHRcdFx0XHRcdHRoaXMuX2NvcmUuJHN0YWdlLmZpbmQoJy5jbG9uZWQgLm93bC12aWRlby1mcmFtZScpLnJlbW92ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0aGlzKSxcblx0XHRcdCdjaGFuZ2VkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRpZiAoZS5uYW1lc3BhY2UgJiYgZS5wcm9wZXJ0eS5uYW1lID09PSAncG9zaXRpb24nICYmIHRoaXMuX3BsYXlpbmcpIHtcblx0XHRcdFx0XHR0aGlzLnN0b3AoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcyksXG5cdFx0XHQncHJlcGFyZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XG5cdFx0XHRcdGlmICghZS5uYW1lc3BhY2UpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgJGVsZW1lbnQgPSAkKGUuY29udGVudCkuZmluZCgnLm93bC12aWRlbycpO1xuXG5cdFx0XHRcdGlmICgkZWxlbWVudC5sZW5ndGgpIHtcblx0XHRcdFx0XHQkZWxlbWVudC5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuXHRcdFx0XHRcdHRoaXMuZmV0Y2goJGVsZW1lbnQsICQoZS5jb250ZW50KSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMpXG5cdFx0fTtcblxuXHRcdC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcblx0XHR0aGlzLl9jb3JlLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgVmlkZW8uRGVmYXVsdHMsIHRoaXMuX2NvcmUub3B0aW9ucyk7XG5cblx0XHQvLyByZWdpc3RlciBldmVudCBoYW5kbGVyc1xuXHRcdHRoaXMuX2NvcmUuJGVsZW1lbnQub24odGhpcy5faGFuZGxlcnMpO1xuXG5cdFx0dGhpcy5fY29yZS4kZWxlbWVudC5vbignY2xpY2sub3dsLnZpZGVvJywgJy5vd2wtdmlkZW8tcGxheS1pY29uJywgJC5wcm94eShmdW5jdGlvbihlKSB7XG5cdFx0XHR0aGlzLnBsYXkoZSk7XG5cdFx0fSwgdGhpcykpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZWZhdWx0IG9wdGlvbnMuXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdFZpZGVvLkRlZmF1bHRzID0ge1xuXHRcdHZpZGVvOiBmYWxzZSxcblx0XHR2aWRlb0hlaWdodDogZmFsc2UsXG5cdFx0dmlkZW9XaWR0aDogZmFsc2Vcblx0fTtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgdmlkZW8gSUQgYW5kIHRoZSB0eXBlIChZb3VUdWJlL1ZpbWVvL3Z6YWFyIG9ubHkpLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7alF1ZXJ5fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IGNvbnRhaW5pbmcgdGhlIHZpZGVvIGRhdGEuXG5cdCAqIEBwYXJhbSB7alF1ZXJ5fSBpdGVtIC0gVGhlIGl0ZW0gY29udGFpbmluZyB0aGUgdmlkZW8uXG5cdCAqL1xuXHRWaWRlby5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbih0YXJnZXQsIGl0ZW0pIHtcblx0XHRcdHZhciB0eXBlID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICh0YXJnZXQuYXR0cignZGF0YS12aW1lby1pZCcpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJ3ZpbWVvJztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRhcmdldC5hdHRyKCdkYXRhLXZ6YWFyLWlkJykpIHtcblx0XHRcdFx0XHRcdHJldHVybiAndnphYXInXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiAneW91dHViZSc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSgpLFxuXHRcdFx0XHRpZCA9IHRhcmdldC5hdHRyKCdkYXRhLXZpbWVvLWlkJykgfHwgdGFyZ2V0LmF0dHIoJ2RhdGEteW91dHViZS1pZCcpIHx8IHRhcmdldC5hdHRyKCdkYXRhLXZ6YWFyLWlkJyksXG5cdFx0XHRcdHdpZHRoID0gdGFyZ2V0LmF0dHIoJ2RhdGEtd2lkdGgnKSB8fCB0aGlzLl9jb3JlLnNldHRpbmdzLnZpZGVvV2lkdGgsXG5cdFx0XHRcdGhlaWdodCA9IHRhcmdldC5hdHRyKCdkYXRhLWhlaWdodCcpIHx8IHRoaXMuX2NvcmUuc2V0dGluZ3MudmlkZW9IZWlnaHQsXG5cdFx0XHRcdHVybCA9IHRhcmdldC5hdHRyKCdocmVmJyk7XG5cblx0XHRpZiAodXJsKSB7XG5cblx0XHRcdC8qXG5cdFx0XHRcdFx0UGFyc2VzIHRoZSBpZCdzIG91dCBvZiB0aGUgZm9sbG93aW5nIHVybHMgKGFuZCBwcm9iYWJseSBtb3JlKTpcblx0XHRcdFx0XHRodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PTppZFxuXHRcdFx0XHRcdGh0dHBzOi8veW91dHUuYmUvOmlkXG5cdFx0XHRcdFx0aHR0cHM6Ly92aW1lby5jb20vOmlkXG5cdFx0XHRcdFx0aHR0cHM6Ly92aW1lby5jb20vY2hhbm5lbHMvOmNoYW5uZWwvOmlkXG5cdFx0XHRcdFx0aHR0cHM6Ly92aW1lby5jb20vZ3JvdXBzLzpncm91cC92aWRlb3MvOmlkXG5cdFx0XHRcdFx0aHR0cHM6Ly9hcHAudnphYXIuY29tL3ZpZGVvcy86aWRcblxuXHRcdFx0XHRcdFZpc3VhbCBleGFtcGxlOiBodHRwczovL3JlZ2V4cGVyLmNvbS8jKGh0dHAlM0ElN0NodHRwcyUzQSU3QyklNUMlMkYlNUMlMkYocGxheWVyLiU3Q3d3dy4lN0NhcHAuKSUzRih2aW1lbyU1Qy5jb20lN0N5b3V0dShiZSU1Qy5jb20lN0MlNUMuYmUlN0NiZSU1Qy5nb29nbGVhcGlzJTVDLmNvbSklN0N2emFhciU1Qy5jb20pJTVDJTJGKHZpZGVvJTVDJTJGJTdDdmlkZW9zJTVDJTJGJTdDZW1iZWQlNUMlMkYlN0NjaGFubmVscyU1QyUyRi4lMkIlNUMlMkYlN0Nncm91cHMlNUMlMkYuJTJCJTVDJTJGJTdDd2F0Y2glNUMlM0Z2JTNEJTdDdiU1QyUyRiklM0YoJTVCQS1aYS16MC05Ll8lMjUtJTVEKikoJTVDJTI2JTVDUyUyQiklM0Zcblx0XHRcdCovXG5cblx0XHRcdGlkID0gdXJsLm1hdGNoKC8oaHR0cDp8aHR0cHM6fClcXC9cXC8ocGxheWVyLnx3d3cufGFwcC4pPyh2aW1lb1xcLmNvbXx5b3V0dShiZVxcLmNvbXxcXC5iZXxiZVxcLmdvb2dsZWFwaXNcXC5jb218YmVcXC1ub2Nvb2tpZVxcLmNvbSl8dnphYXJcXC5jb20pXFwvKHZpZGVvXFwvfHZpZGVvc1xcL3xlbWJlZFxcL3xjaGFubmVsc1xcLy4rXFwvfGdyb3Vwc1xcLy4rXFwvfHdhdGNoXFw/dj18dlxcLyk/KFtBLVphLXowLTkuXyUtXSopKFxcJlxcUyspPy8pO1xuXG5cdFx0XHRpZiAoaWRbM10uaW5kZXhPZigneW91dHUnKSA+IC0xKSB7XG5cdFx0XHRcdHR5cGUgPSAneW91dHViZSc7XG5cdFx0XHR9IGVsc2UgaWYgKGlkWzNdLmluZGV4T2YoJ3ZpbWVvJykgPiAtMSkge1xuXHRcdFx0XHR0eXBlID0gJ3ZpbWVvJztcblx0XHRcdH0gZWxzZSBpZiAoaWRbM10uaW5kZXhPZigndnphYXInKSA+IC0xKSB7XG5cdFx0XHRcdHR5cGUgPSAndnphYXInO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdWaWRlbyBVUkwgbm90IHN1cHBvcnRlZC4nKTtcblx0XHRcdH1cblx0XHRcdGlkID0gaWRbNl07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTWlzc2luZyB2aWRlbyBVUkwuJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdmlkZW9zW3VybF0gPSB7XG5cdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0aWQ6IGlkLFxuXHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0aGVpZ2h0OiBoZWlnaHRcblx0XHR9O1xuXG5cdFx0aXRlbS5hdHRyKCdkYXRhLXZpZGVvJywgdXJsKTtcblxuXHRcdHRoaXMudGh1bWJuYWlsKHRhcmdldCwgdGhpcy5fdmlkZW9zW3VybF0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIHZpZGVvIHRodW1ibmFpbC5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge2pRdWVyeX0gdGFyZ2V0IC0gVGhlIHRhcmdldCBjb250YWluaW5nIHRoZSB2aWRlbyBkYXRhLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gaW5mbyAtIFRoZSB2aWRlbyBpbmZvIG9iamVjdC5cblx0ICogQHNlZSBgZmV0Y2hgXG5cdCAqL1xuXHRWaWRlby5wcm90b3R5cGUudGh1bWJuYWlsID0gZnVuY3Rpb24odGFyZ2V0LCB2aWRlbykge1xuXHRcdHZhciB0bkxpbmssXG5cdFx0XHRpY29uLFxuXHRcdFx0cGF0aCxcblx0XHRcdGRpbWVuc2lvbnMgPSB2aWRlby53aWR0aCAmJiB2aWRlby5oZWlnaHQgPyAnd2lkdGg6JyArIHZpZGVvLndpZHRoICsgJ3B4O2hlaWdodDonICsgdmlkZW8uaGVpZ2h0ICsgJ3B4OycgOiAnJyxcblx0XHRcdGN1c3RvbVRuID0gdGFyZ2V0LmZpbmQoJ2ltZycpLFxuXHRcdFx0c3JjVHlwZSA9ICdzcmMnLFxuXHRcdFx0bGF6eUNsYXNzID0gJycsXG5cdFx0XHRzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3MsXG5cdFx0XHRjcmVhdGUgPSBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRcdGljb24gPSAnPGRpdiBjbGFzcz1cIm93bC12aWRlby1wbGF5LWljb25cIj48L2Rpdj4nO1xuXG5cdFx0XHRcdGlmIChzZXR0aW5ncy5sYXp5TG9hZCkge1xuXHRcdFx0XHRcdHRuTGluayA9ICQoJzxkaXYvPicse1xuXHRcdFx0XHRcdFx0XCJjbGFzc1wiOiAnb3dsLXZpZGVvLXRuICcgKyBsYXp5Q2xhc3MsXG5cdFx0XHRcdFx0XHRcInNyY1R5cGVcIjogcGF0aFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRuTGluayA9ICQoICc8ZGl2Lz4nLCB7XG5cdFx0XHRcdFx0XHRcImNsYXNzXCI6IFwib3dsLXZpZGVvLXRuXCIsXG5cdFx0XHRcdFx0XHRcInN0eWxlXCI6ICdvcGFjaXR5OjE7YmFja2dyb3VuZC1pbWFnZTp1cmwoJyArIHBhdGggKyAnKSdcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0YXJnZXQuYWZ0ZXIodG5MaW5rKTtcblx0XHRcdFx0dGFyZ2V0LmFmdGVyKGljb24pO1xuXHRcdFx0fTtcblxuXHRcdC8vIHdyYXAgdmlkZW8gY29udGVudCBpbnRvIG93bC12aWRlby13cmFwcGVyIGRpdlxuXHRcdHRhcmdldC53cmFwKCAkKCAnPGRpdi8+Jywge1xuXHRcdFx0XCJjbGFzc1wiOiBcIm93bC12aWRlby13cmFwcGVyXCIsXG5cdFx0XHRcInN0eWxlXCI6IGRpbWVuc2lvbnNcblx0XHR9KSk7XG5cblx0XHRpZiAodGhpcy5fY29yZS5zZXR0aW5ncy5sYXp5TG9hZCkge1xuXHRcdFx0c3JjVHlwZSA9ICdkYXRhLXNyYyc7XG5cdFx0XHRsYXp5Q2xhc3MgPSAnb3dsLWxhenknO1xuXHRcdH1cblxuXHRcdC8vIGN1c3RvbSB0aHVtYm5haWxcblx0XHRpZiAoY3VzdG9tVG4ubGVuZ3RoKSB7XG5cdFx0XHRjcmVhdGUoY3VzdG9tVG4uYXR0cihzcmNUeXBlKSk7XG5cdFx0XHRjdXN0b21Ubi5yZW1vdmUoKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAodmlkZW8udHlwZSA9PT0gJ3lvdXR1YmUnKSB7XG5cdFx0XHRwYXRoID0gXCIvL2ltZy55b3V0dWJlLmNvbS92aS9cIiArIHZpZGVvLmlkICsgXCIvaHFkZWZhdWx0LmpwZ1wiO1xuXHRcdFx0Y3JlYXRlKHBhdGgpO1xuXHRcdH0gZWxzZSBpZiAodmlkZW8udHlwZSA9PT0gJ3ZpbWVvJykge1xuXHRcdFx0JC5hamF4KHtcblx0XHRcdFx0dHlwZTogJ0dFVCcsXG5cdFx0XHRcdHVybDogJy8vdmltZW8uY29tL2FwaS92Mi92aWRlby8nICsgdmlkZW8uaWQgKyAnLmpzb24nLFxuXHRcdFx0XHRqc29ucDogJ2NhbGxiYWNrJyxcblx0XHRcdFx0ZGF0YVR5cGU6ICdqc29ucCcsXG5cdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0XHRwYXRoID0gZGF0YVswXS50aHVtYm5haWxfbGFyZ2U7XG5cdFx0XHRcdFx0Y3JlYXRlKHBhdGgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2UgaWYgKHZpZGVvLnR5cGUgPT09ICd2emFhcicpIHtcblx0XHRcdCQuYWpheCh7XG5cdFx0XHRcdHR5cGU6ICdHRVQnLFxuXHRcdFx0XHR1cmw6ICcvL3Z6YWFyLmNvbS9hcGkvdmlkZW9zLycgKyB2aWRlby5pZCArICcuanNvbicsXG5cdFx0XHRcdGpzb25wOiAnY2FsbGJhY2snLFxuXHRcdFx0XHRkYXRhVHlwZTogJ2pzb25wJyxcblx0XHRcdFx0c3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0XHRcdHBhdGggPSBkYXRhLmZyYW1lZ3JhYl91cmw7XG5cdFx0XHRcdFx0Y3JlYXRlKHBhdGgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0b3BzIHRoZSBjdXJyZW50IHZpZGVvLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRWaWRlby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2NvcmUudHJpZ2dlcignc3RvcCcsIG51bGwsICd2aWRlbycpO1xuXHRcdHRoaXMuX3BsYXlpbmcuZmluZCgnLm93bC12aWRlby1mcmFtZScpLnJlbW92ZSgpO1xuXHRcdHRoaXMuX3BsYXlpbmcucmVtb3ZlQ2xhc3MoJ293bC12aWRlby1wbGF5aW5nJyk7XG5cdFx0dGhpcy5fcGxheWluZyA9IG51bGw7XG5cdFx0dGhpcy5fY29yZS5sZWF2ZSgncGxheWluZycpO1xuXHRcdHRoaXMuX2NvcmUudHJpZ2dlcignc3RvcHBlZCcsIG51bGwsICd2aWRlbycpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdGFydHMgdGhlIGN1cnJlbnQgdmlkZW8uXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxuXHQgKi9cblx0VmlkZW8ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciB0YXJnZXQgPSAkKGV2ZW50LnRhcmdldCksXG5cdFx0XHRpdGVtID0gdGFyZ2V0LmNsb3Nlc3QoJy4nICsgdGhpcy5fY29yZS5zZXR0aW5ncy5pdGVtQ2xhc3MpLFxuXHRcdFx0dmlkZW8gPSB0aGlzLl92aWRlb3NbaXRlbS5hdHRyKCdkYXRhLXZpZGVvJyldLFxuXHRcdFx0d2lkdGggPSB2aWRlby53aWR0aCB8fCAnMTAwJScsXG5cdFx0XHRoZWlnaHQgPSB2aWRlby5oZWlnaHQgfHwgdGhpcy5fY29yZS4kc3RhZ2UuaGVpZ2h0KCksXG5cdFx0XHRodG1sLFxuXHRcdFx0aWZyYW1lO1xuXG5cdFx0aWYgKHRoaXMuX3BsYXlpbmcpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9jb3JlLmVudGVyKCdwbGF5aW5nJyk7XG5cdFx0dGhpcy5fY29yZS50cmlnZ2VyKCdwbGF5JywgbnVsbCwgJ3ZpZGVvJyk7XG5cblx0XHRpdGVtID0gdGhpcy5fY29yZS5pdGVtcyh0aGlzLl9jb3JlLnJlbGF0aXZlKGl0ZW0uaW5kZXgoKSkpO1xuXG5cdFx0dGhpcy5fY29yZS5yZXNldChpdGVtLmluZGV4KCkpO1xuXG5cdFx0aHRtbCA9ICQoICc8aWZyYW1lIGZyYW1lYm9yZGVyPVwiMFwiIGFsbG93ZnVsbHNjcmVlbiBtb3phbGxvd2Z1bGxzY3JlZW4gd2Via2l0QWxsb3dGdWxsU2NyZWVuID48L2lmcmFtZT4nICk7XG5cdFx0aHRtbC5hdHRyKCAnaGVpZ2h0JywgaGVpZ2h0ICk7XG5cdFx0aHRtbC5hdHRyKCAnd2lkdGgnLCB3aWR0aCApO1xuXHRcdGlmICh2aWRlby50eXBlID09PSAneW91dHViZScpIHtcblx0XHRcdGh0bWwuYXR0ciggJ3NyYycsICcvL3d3dy55b3V0dWJlLmNvbS9lbWJlZC8nICsgdmlkZW8uaWQgKyAnP2F1dG9wbGF5PTEmcmVsPTAmdj0nICsgdmlkZW8uaWQgKTtcblx0XHR9IGVsc2UgaWYgKHZpZGVvLnR5cGUgPT09ICd2aW1lbycpIHtcblx0XHRcdGh0bWwuYXR0ciggJ3NyYycsICcvL3BsYXllci52aW1lby5jb20vdmlkZW8vJyArIHZpZGVvLmlkICsgJz9hdXRvcGxheT0xJyApO1xuXHRcdH0gZWxzZSBpZiAodmlkZW8udHlwZSA9PT0gJ3Z6YWFyJykge1xuXHRcdFx0aHRtbC5hdHRyKCAnc3JjJywgJy8vdmlldy52emFhci5jb20vJyArIHZpZGVvLmlkICsgJy9wbGF5ZXI/YXV0b3BsYXk9dHJ1ZScgKTtcblx0XHR9XG5cblx0XHRpZnJhbWUgPSAkKGh0bWwpLndyYXAoICc8ZGl2IGNsYXNzPVwib3dsLXZpZGVvLWZyYW1lXCIgLz4nICkuaW5zZXJ0QWZ0ZXIoaXRlbS5maW5kKCcub3dsLXZpZGVvJykpO1xuXG5cdFx0dGhpcy5fcGxheWluZyA9IGl0ZW0uYWRkQ2xhc3MoJ293bC12aWRlby1wbGF5aW5nJyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrcyB3aGV0aGVyIGFuIHZpZGVvIGlzIGN1cnJlbnRseSBpbiBmdWxsIHNjcmVlbiBtb2RlIG9yIG5vdC5cblx0ICogQHRvZG8gQmFkIHN0eWxlIGJlY2F1c2UgbG9va3MgbGlrZSBhIHJlYWRvbmx5IG1ldGhvZCBidXQgY2hhbmdlcyBtZW1iZXJzLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHQgKi9cblx0VmlkZW8ucHJvdG90eXBlLmlzSW5GdWxsU2NyZWVuID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSBkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCB8fCBkb2N1bWVudC5tb3pGdWxsU2NyZWVuRWxlbWVudCB8fFxuXHRcdFx0XHRkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRWxlbWVudDtcblxuXHRcdHJldHVybiBlbGVtZW50ICYmICQoZWxlbWVudCkucGFyZW50KCkuaGFzQ2xhc3MoJ293bC12aWRlby1mcmFtZScpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxuXHQgKi9cblx0VmlkZW8ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGFuZGxlciwgcHJvcGVydHk7XG5cblx0XHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9mZignY2xpY2sub3dsLnZpZGVvJyk7XG5cblx0XHRmb3IgKGhhbmRsZXIgaW4gdGhpcy5faGFuZGxlcnMpIHtcblx0XHRcdHRoaXMuX2NvcmUuJGVsZW1lbnQub2ZmKGhhbmRsZXIsIHRoaXMuX2hhbmRsZXJzW2hhbmRsZXJdKTtcblx0XHR9XG5cdFx0Zm9yIChwcm9wZXJ0eSBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSkge1xuXHRcdFx0dHlwZW9mIHRoaXNbcHJvcGVydHldICE9ICdmdW5jdGlvbicgJiYgKHRoaXNbcHJvcGVydHldID0gbnVsbCk7XG5cdFx0fVxuXHR9O1xuXG5cdCQuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IuUGx1Z2lucy5WaWRlbyA9IFZpZGVvO1xuXG59KSh3aW5kb3cuWmVwdG8gfHwgd2luZG93LmpRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XG5cbi8qKlxuICogQW5pbWF0ZSBQbHVnaW5cbiAqIEB2ZXJzaW9uIDIuMy40XG4gKiBAYXV0aG9yIEJhcnRvc3ogV29qY2llY2hvd3NraVxuICogQGF1dGhvciBEYXZpZCBEZXV0c2NoXG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqL1xuOyhmdW5jdGlvbigkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcblxuXHQvKipcblx0ICogQ3JlYXRlcyB0aGUgYW5pbWF0ZSBwbHVnaW4uXG5cdCAqIEBjbGFzcyBUaGUgTmF2aWdhdGlvbiBQbHVnaW5cblx0ICogQHBhcmFtIHtPd2x9IHNjb3BlIC0gVGhlIE93bCBDYXJvdXNlbFxuXHQgKi9cblx0dmFyIEFuaW1hdGUgPSBmdW5jdGlvbihzY29wZSkge1xuXHRcdHRoaXMuY29yZSA9IHNjb3BlO1xuXHRcdHRoaXMuY29yZS5vcHRpb25zID0gJC5leHRlbmQoe30sIEFuaW1hdGUuRGVmYXVsdHMsIHRoaXMuY29yZS5vcHRpb25zKTtcblx0XHR0aGlzLnN3YXBwaW5nID0gdHJ1ZTtcblx0XHR0aGlzLnByZXZpb3VzID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcblxuXHRcdHRoaXMuaGFuZGxlcnMgPSB7XG5cdFx0XHQnY2hhbmdlLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRpZiAoZS5uYW1lc3BhY2UgJiYgZS5wcm9wZXJ0eS5uYW1lID09ICdwb3NpdGlvbicpIHtcblx0XHRcdFx0XHR0aGlzLnByZXZpb3VzID0gdGhpcy5jb3JlLmN1cnJlbnQoKTtcblx0XHRcdFx0XHR0aGlzLm5leHQgPSBlLnByb3BlcnR5LnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0aGlzKSxcblx0XHRcdCdkcmFnLm93bC5jYXJvdXNlbCBkcmFnZ2VkLm93bC5jYXJvdXNlbCB0cmFuc2xhdGVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRpZiAoZS5uYW1lc3BhY2UpIHtcblx0XHRcdFx0XHR0aGlzLnN3YXBwaW5nID0gZS50eXBlID09ICd0cmFuc2xhdGVkJztcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcyksXG5cdFx0XHQndHJhbnNsYXRlLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5zd2FwcGluZyAmJiAodGhpcy5jb3JlLm9wdGlvbnMuYW5pbWF0ZU91dCB8fCB0aGlzLmNvcmUub3B0aW9ucy5hbmltYXRlSW4pKSB7XG5cdFx0XHRcdFx0dGhpcy5zd2FwKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMpXG5cdFx0fTtcblxuXHRcdHRoaXMuY29yZS4kZWxlbWVudC5vbih0aGlzLmhhbmRsZXJzKTtcblx0fTtcblxuXHQvKipcblx0ICogRGVmYXVsdCBvcHRpb25zLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRBbmltYXRlLkRlZmF1bHRzID0ge1xuXHRcdGFuaW1hdGVPdXQ6IGZhbHNlLFxuXHRcdGFuaW1hdGVJbjogZmFsc2Vcblx0fTtcblxuXHQvKipcblx0ICogVG9nZ2xlcyB0aGUgYW5pbWF0aW9uIGNsYXNzZXMgd2hlbmV2ZXIgYW4gdHJhbnNsYXRpb25zIHN0YXJ0cy5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbnx1bmRlZmluZWR9XG5cdCAqL1xuXHRBbmltYXRlLnByb3RvdHlwZS5zd2FwID0gZnVuY3Rpb24oKSB7XG5cblx0XHRpZiAodGhpcy5jb3JlLnNldHRpbmdzLml0ZW1zICE9PSAxKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCEkLnN1cHBvcnQuYW5pbWF0aW9uIHx8ICEkLnN1cHBvcnQudHJhbnNpdGlvbikge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuY29yZS5zcGVlZCgwKTtcblxuXHRcdHZhciBsZWZ0LFxuXHRcdFx0Y2xlYXIgPSAkLnByb3h5KHRoaXMuY2xlYXIsIHRoaXMpLFxuXHRcdFx0cHJldmlvdXMgPSB0aGlzLmNvcmUuJHN0YWdlLmNoaWxkcmVuKCkuZXEodGhpcy5wcmV2aW91cyksXG5cdFx0XHRuZXh0ID0gdGhpcy5jb3JlLiRzdGFnZS5jaGlsZHJlbigpLmVxKHRoaXMubmV4dCksXG5cdFx0XHRpbmNvbWluZyA9IHRoaXMuY29yZS5zZXR0aW5ncy5hbmltYXRlSW4sXG5cdFx0XHRvdXRnb2luZyA9IHRoaXMuY29yZS5zZXR0aW5ncy5hbmltYXRlT3V0O1xuXG5cdFx0aWYgKHRoaXMuY29yZS5jdXJyZW50KCkgPT09IHRoaXMucHJldmlvdXMpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAob3V0Z29pbmcpIHtcblx0XHRcdGxlZnQgPSB0aGlzLmNvcmUuY29vcmRpbmF0ZXModGhpcy5wcmV2aW91cykgLSB0aGlzLmNvcmUuY29vcmRpbmF0ZXModGhpcy5uZXh0KTtcblx0XHRcdHByZXZpb3VzLm9uZSgkLnN1cHBvcnQuYW5pbWF0aW9uLmVuZCwgY2xlYXIpXG5cdFx0XHRcdC5jc3MoIHsgJ2xlZnQnOiBsZWZ0ICsgJ3B4JyB9IClcblx0XHRcdFx0LmFkZENsYXNzKCdhbmltYXRlZCBvd2wtYW5pbWF0ZWQtb3V0Jylcblx0XHRcdFx0LmFkZENsYXNzKG91dGdvaW5nKTtcblx0XHR9XG5cblx0XHRpZiAoaW5jb21pbmcpIHtcblx0XHRcdG5leHQub25lKCQuc3VwcG9ydC5hbmltYXRpb24uZW5kLCBjbGVhcilcblx0XHRcdFx0LmFkZENsYXNzKCdhbmltYXRlZCBvd2wtYW5pbWF0ZWQtaW4nKVxuXHRcdFx0XHQuYWRkQ2xhc3MoaW5jb21pbmcpO1xuXHRcdH1cblx0fTtcblxuXHRBbmltYXRlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKGUpIHtcblx0XHQkKGUudGFyZ2V0KS5jc3MoIHsgJ2xlZnQnOiAnJyB9IClcblx0XHRcdC5yZW1vdmVDbGFzcygnYW5pbWF0ZWQgb3dsLWFuaW1hdGVkLW91dCBvd2wtYW5pbWF0ZWQtaW4nKVxuXHRcdFx0LnJlbW92ZUNsYXNzKHRoaXMuY29yZS5zZXR0aW5ncy5hbmltYXRlSW4pXG5cdFx0XHQucmVtb3ZlQ2xhc3ModGhpcy5jb3JlLnNldHRpbmdzLmFuaW1hdGVPdXQpO1xuXHRcdHRoaXMuY29yZS5vblRyYW5zaXRpb25FbmQoKTtcblx0fTtcblxuXHQvKipcblx0ICogRGVzdHJveXMgdGhlIHBsdWdpbi5cblx0ICogQHB1YmxpY1xuXHQgKi9cblx0QW5pbWF0ZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYW5kbGVyLCBwcm9wZXJ0eTtcblxuXHRcdGZvciAoaGFuZGxlciBpbiB0aGlzLmhhbmRsZXJzKSB7XG5cdFx0XHR0aGlzLmNvcmUuJGVsZW1lbnQub2ZmKGhhbmRsZXIsIHRoaXMuaGFuZGxlcnNbaGFuZGxlcl0pO1xuXHRcdH1cblx0XHRmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XG5cdFx0XHR0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gJ2Z1bmN0aW9uJyAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcblx0XHR9XG5cdH07XG5cblx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLkFuaW1hdGUgPSBBbmltYXRlO1xuXG59KSh3aW5kb3cuWmVwdG8gfHwgd2luZG93LmpRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XG5cbi8qKlxuICogQXV0b3BsYXkgUGx1Z2luXG4gKiBAdmVyc2lvbiAyLjMuNFxuICogQGF1dGhvciBCYXJ0b3N6IFdvamNpZWNob3dza2lcbiAqIEBhdXRob3IgQXJ0dXMgS29sYW5vd3NraVxuICogQGF1dGhvciBEYXZpZCBEZXV0c2NoXG4gKiBAYXV0aG9yIFRvbSBEZSBDYWx1d8OpXG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqL1xuOyhmdW5jdGlvbigkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcblxuXHQvKipcblx0ICogQ3JlYXRlcyB0aGUgYXV0b3BsYXkgcGx1Z2luLlxuXHQgKiBAY2xhc3MgVGhlIEF1dG9wbGF5IFBsdWdpblxuXHQgKiBAcGFyYW0ge093bH0gc2NvcGUgLSBUaGUgT3dsIENhcm91c2VsXG5cdCAqL1xuXHR2YXIgQXV0b3BsYXkgPSBmdW5jdGlvbihjYXJvdXNlbCkge1xuXHRcdC8qKlxuXHRcdCAqIFJlZmVyZW5jZSB0byB0aGUgY29yZS5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge093bH1cblx0XHQgKi9cblx0XHR0aGlzLl9jb3JlID0gY2Fyb3VzZWw7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgYXV0b3BsYXkgdGltZW91dCBpZC5cblx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdCAqL1xuXHRcdHRoaXMuX2NhbGwgPSBudWxsO1xuXG5cdFx0LyoqXG5cdFx0ICogRGVwZW5kaW5nIG9uIHRoZSBzdGF0ZSBvZiB0aGUgcGx1Z2luLCB0aGlzIHZhcmlhYmxlIGNvbnRhaW5zIGVpdGhlclxuXHRcdCAqIHRoZSBzdGFydCB0aW1lIG9mIHRoZSB0aW1lciBvciB0aGUgY3VycmVudCB0aW1lciB2YWx1ZSBpZiBpdCdzXG5cdFx0ICogcGF1c2VkLiBTaW5jZSB3ZSBzdGFydCBpbiBhIHBhdXNlZCBzdGF0ZSB3ZSBpbml0aWFsaXplIHRoZSB0aW1lclxuXHRcdCAqIHZhbHVlLlxuXHRcdCAqIEB0eXBlIHtOdW1iZXJ9XG5cdFx0ICovXG5cdFx0dGhpcy5fdGltZSA9IDA7XG5cblx0XHQvKipcblx0XHQgKiBTdG9yZXMgdGhlIHRpbWVvdXQgY3VycmVudGx5IHVzZWQuXG5cdFx0ICogQHR5cGUge051bWJlcn1cblx0XHQgKi9cblx0XHR0aGlzLl90aW1lb3V0ID0gMDtcblxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGVuZXZlciB0aGUgYXV0b3BsYXkgaXMgcGF1c2VkLlxuXHRcdCAqIEB0eXBlIHtCb29sZWFufVxuXHRcdCAqL1xuXHRcdHRoaXMuX3BhdXNlZCA9IHRydWU7XG5cblx0XHQvKipcblx0XHQgKiBBbGwgZXZlbnQgaGFuZGxlcnMuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy5faGFuZGxlcnMgPSB7XG5cdFx0XHQnY2hhbmdlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0aWYgKGUubmFtZXNwYWNlICYmIGUucHJvcGVydHkubmFtZSA9PT0gJ3NldHRpbmdzJykge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5KSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBsYXkoKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5zdG9wKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGUubmFtZXNwYWNlICYmIGUucHJvcGVydHkubmFtZSA9PT0gJ3Bvc2l0aW9uJyAmJiB0aGlzLl9wYXVzZWQpIHtcblx0XHRcdFx0XHQvLyBSZXNldCB0aGUgdGltZXIuIFRoaXMgY29kZSBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgcG9zaXRpb25cblx0XHRcdFx0XHQvLyBvZiB0aGUgY2Fyb3VzZWwgd2FzIGNoYW5nZWQgdGhyb3VnaCB1c2VyIGludGVyYWN0aW9uLlxuXHRcdFx0XHRcdHRoaXMuX3RpbWUgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0aGlzKSxcblx0XHRcdCdpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXkpIHtcblx0XHRcdFx0XHR0aGlzLnBsYXkoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcyksXG5cdFx0XHQncGxheS5vd2wuYXV0b3BsYXknOiAkLnByb3h5KGZ1bmN0aW9uKGUsIHQsIHMpIHtcblx0XHRcdFx0aWYgKGUubmFtZXNwYWNlKSB7XG5cdFx0XHRcdFx0dGhpcy5wbGF5KHQsIHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0aGlzKSxcblx0XHRcdCdzdG9wLm93bC5hdXRvcGxheSc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRpZiAoZS5uYW1lc3BhY2UpIHtcblx0XHRcdFx0XHR0aGlzLnN0b3AoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcyksXG5cdFx0XHQnbW91c2VvdmVyLm93bC5hdXRvcGxheSc6ICQucHJveHkoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5SG92ZXJQYXVzZSAmJiB0aGlzLl9jb3JlLmlzKCdyb3RhdGluZycpKSB7XG5cdFx0XHRcdFx0dGhpcy5wYXVzZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0aGlzKSxcblx0XHRcdCdtb3VzZWxlYXZlLm93bC5hdXRvcGxheSc6ICQucHJveHkoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5SG92ZXJQYXVzZSAmJiB0aGlzLl9jb3JlLmlzKCdyb3RhdGluZycpKSB7XG5cdFx0XHRcdFx0dGhpcy5wbGF5KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMpLFxuXHRcdFx0J3RvdWNoc3RhcnQub3dsLmNvcmUnOiAkLnByb3h5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAodGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheUhvdmVyUGF1c2UgJiYgdGhpcy5fY29yZS5pcygncm90YXRpbmcnKSkge1xuXHRcdFx0XHRcdHRoaXMucGF1c2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcyksXG5cdFx0XHQndG91Y2hlbmQub3dsLmNvcmUnOiAkLnByb3h5KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAodGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheUhvdmVyUGF1c2UpIHtcblx0XHRcdFx0XHR0aGlzLnBsYXkoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcylcblx0XHR9O1xuXG5cdFx0Ly8gcmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnNcblx0XHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcblxuXHRcdC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcblx0XHR0aGlzLl9jb3JlLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgQXV0b3BsYXkuRGVmYXVsdHMsIHRoaXMuX2NvcmUub3B0aW9ucyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERlZmF1bHQgb3B0aW9ucy5cblx0ICogQHB1YmxpY1xuXHQgKi9cblx0QXV0b3BsYXkuRGVmYXVsdHMgPSB7XG5cdFx0YXV0b3BsYXk6IGZhbHNlLFxuXHRcdGF1dG9wbGF5VGltZW91dDogNTAwMCxcblx0XHRhdXRvcGxheUhvdmVyUGF1c2U6IGZhbHNlLFxuXHRcdGF1dG9wbGF5U3BlZWQ6IGZhbHNlXG5cdH07XG5cblx0LyoqXG5cdCAqIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc2xpZGUgYW5kIHNldCBhIHRpbWVvdXQgZm9yIHRoZSBuZXh0IHRyYW5zaXRpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWRdIC0gVGhlIGFuaW1hdGlvbiBzcGVlZCBmb3IgdGhlIGFuaW1hdGlvbnMuXG5cdCAqL1xuXHRBdXRvcGxheS5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbihzcGVlZCkge1xuXHRcdHRoaXMuX2NhbGwgPSB3aW5kb3cuc2V0VGltZW91dChcblx0XHRcdCQucHJveHkodGhpcy5fbmV4dCwgdGhpcywgc3BlZWQpLFxuXHRcdFx0dGhpcy5fdGltZW91dCAqIChNYXRoLnJvdW5kKHRoaXMucmVhZCgpIC8gdGhpcy5fdGltZW91dCkgKyAxKSAtIHRoaXMucmVhZCgpXG5cdFx0KTtcblxuXHRcdGlmICh0aGlzLl9jb3JlLmlzKCdpbnRlcmFjdGluZycpIHx8IGRvY3VtZW50LmhpZGRlbikge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLl9jb3JlLm5leHQoc3BlZWQgfHwgdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheVNwZWVkKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWFkcyB0aGUgY3VycmVudCB0aW1lciB2YWx1ZSB3aGVuIHRoZSB0aW1lciBpcyBwbGF5aW5nLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRBdXRvcGxheS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuX3RpbWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0YXJ0cyB0aGUgYXV0b3BsYXkuXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lb3V0XSAtIFRoZSBpbnRlcnZhbCBiZWZvcmUgdGhlIG5leHQgYW5pbWF0aW9uIHN0YXJ0cy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZF0gLSBUaGUgYW5pbWF0aW9uIHNwZWVkIGZvciB0aGUgYW5pbWF0aW9ucy5cblx0ICovXG5cdEF1dG9wbGF5LnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24odGltZW91dCwgc3BlZWQpIHtcblx0XHR2YXIgZWxhcHNlZDtcblxuXHRcdGlmICghdGhpcy5fY29yZS5pcygncm90YXRpbmcnKSkge1xuXHRcdFx0dGhpcy5fY29yZS5lbnRlcigncm90YXRpbmcnKTtcblx0XHR9XG5cblx0XHR0aW1lb3V0ID0gdGltZW91dCB8fCB0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5VGltZW91dDtcblxuXHRcdC8vIENhbGN1bGF0ZSB0aGUgZWxhcHNlZCB0aW1lIHNpbmNlIHRoZSBsYXN0IHRyYW5zaXRpb24uIElmIHRoZSBjYXJvdXNlbFxuXHRcdC8vIHdhc24ndCBwbGF5aW5nIHRoaXMgY2FsY3VsYXRpb24gd2lsbCB5aWVsZCB6ZXJvLlxuXHRcdGVsYXBzZWQgPSBNYXRoLm1pbih0aGlzLl90aW1lICUgKHRoaXMuX3RpbWVvdXQgfHwgdGltZW91dCksIHRpbWVvdXQpO1xuXG5cdFx0aWYgKHRoaXMuX3BhdXNlZCkge1xuXHRcdFx0Ly8gU3RhcnQgdGhlIGNsb2NrLlxuXHRcdFx0dGhpcy5fdGltZSA9IHRoaXMucmVhZCgpO1xuXHRcdFx0dGhpcy5fcGF1c2VkID0gZmFsc2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIENsZWFyIHRoZSBhY3RpdmUgdGltZW91dCB0byBhbGxvdyByZXBsYWNlbWVudC5cblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fY2FsbCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWRqdXN0IHRoZSBvcmlnaW4gb2YgdGhlIHRpbWVyIHRvIG1hdGNoIHRoZSBuZXcgdGltZW91dCB2YWx1ZS5cblx0XHR0aGlzLl90aW1lICs9IHRoaXMucmVhZCgpICUgdGltZW91dCAtIGVsYXBzZWQ7XG5cblx0XHR0aGlzLl90aW1lb3V0ID0gdGltZW91dDtcblx0XHR0aGlzLl9jYWxsID0gd2luZG93LnNldFRpbWVvdXQoJC5wcm94eSh0aGlzLl9uZXh0LCB0aGlzLCBzcGVlZCksIHRpbWVvdXQgLSBlbGFwc2VkKTtcblx0fTtcblxuXHQvKipcblx0ICogU3RvcHMgdGhlIGF1dG9wbGF5LlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRBdXRvcGxheS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9jb3JlLmlzKCdyb3RhdGluZycpKSB7XG5cdFx0XHQvLyBSZXNldCB0aGUgY2xvY2suXG5cdFx0XHR0aGlzLl90aW1lID0gMDtcblx0XHRcdHRoaXMuX3BhdXNlZCA9IHRydWU7XG5cblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fY2FsbCk7XG5cdFx0XHR0aGlzLl9jb3JlLmxlYXZlKCdyb3RhdGluZycpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUGF1c2VzIHRoZSBhdXRvcGxheS5cblx0ICogQHB1YmxpY1xuXHQgKi9cblx0QXV0b3BsYXkucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2NvcmUuaXMoJ3JvdGF0aW5nJykgJiYgIXRoaXMuX3BhdXNlZCkge1xuXHRcdFx0Ly8gUGF1c2UgdGhlIGNsb2NrLlxuXHRcdFx0dGhpcy5fdGltZSA9IHRoaXMucmVhZCgpO1xuXHRcdFx0dGhpcy5fcGF1c2VkID0gdHJ1ZTtcblxuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCh0aGlzLl9jYWxsKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIERlc3Ryb3lzIHRoZSBwbHVnaW4uXG5cdCAqL1xuXHRBdXRvcGxheS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYW5kbGVyLCBwcm9wZXJ0eTtcblxuXHRcdHRoaXMuc3RvcCgpO1xuXG5cdFx0Zm9yIChoYW5kbGVyIGluIHRoaXMuX2hhbmRsZXJzKSB7XG5cdFx0XHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9mZihoYW5kbGVyLCB0aGlzLl9oYW5kbGVyc1toYW5kbGVyXSk7XG5cdFx0fVxuXHRcdGZvciAocHJvcGVydHkgaW4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpIHtcblx0XHRcdHR5cGVvZiB0aGlzW3Byb3BlcnR5XSAhPSAnZnVuY3Rpb24nICYmICh0aGlzW3Byb3BlcnR5XSA9IG51bGwpO1xuXHRcdH1cblx0fTtcblxuXHQkLmZuLm93bENhcm91c2VsLkNvbnN0cnVjdG9yLlBsdWdpbnMuYXV0b3BsYXkgPSBBdXRvcGxheTtcblxufSkod2luZG93LlplcHRvIHx8IHdpbmRvdy5qUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xuXG4vKipcbiAqIE5hdmlnYXRpb24gUGx1Z2luXG4gKiBAdmVyc2lvbiAyLjMuNFxuICogQGF1dGhvciBBcnR1cyBLb2xhbm93c2tpXG4gKiBAYXV0aG9yIERhdmlkIERldXRzY2hcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICovXG47KGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgdGhlIG5hdmlnYXRpb24gcGx1Z2luLlxuXHQgKiBAY2xhc3MgVGhlIE5hdmlnYXRpb24gUGx1Z2luXG5cdCAqIEBwYXJhbSB7T3dsfSBjYXJvdXNlbCAtIFRoZSBPd2wgQ2Fyb3VzZWwuXG5cdCAqL1xuXHR2YXIgTmF2aWdhdGlvbiA9IGZ1bmN0aW9uKGNhcm91c2VsKSB7XG5cdFx0LyoqXG5cdFx0ICogUmVmZXJlbmNlIHRvIHRoZSBjb3JlLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7T3dsfVxuXHRcdCAqL1xuXHRcdHRoaXMuX2NvcmUgPSBjYXJvdXNlbDtcblxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBwbHVnaW4gaXMgaW5pdGlhbGl6ZWQgb3Igbm90LlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHR0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGN1cnJlbnQgcGFnaW5nIGluZGV4ZXMuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKi9cblx0XHR0aGlzLl9wYWdlcyA9IFtdO1xuXG5cdFx0LyoqXG5cdFx0ICogQWxsIERPTSBlbGVtZW50cyBvZiB0aGUgdXNlciBpbnRlcmZhY2UuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy5fY29udHJvbHMgPSB7fTtcblxuXHRcdC8qKlxuXHRcdCAqIE1hcmt1cCBmb3IgYW4gaW5kaWNhdG9yLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7QXJyYXkuPFN0cmluZz59XG5cdFx0ICovXG5cdFx0dGhpcy5fdGVtcGxhdGVzID0gW107XG5cblx0XHQvKipcblx0XHQgKiBUaGUgY2Fyb3VzZWwgZWxlbWVudC5cblx0XHQgKiBAdHlwZSB7alF1ZXJ5fVxuXHRcdCAqL1xuXHRcdHRoaXMuJGVsZW1lbnQgPSB0aGlzLl9jb3JlLiRlbGVtZW50O1xuXG5cdFx0LyoqXG5cdFx0ICogT3ZlcnJpZGRlbiBtZXRob2RzIG9mIHRoZSBjYXJvdXNlbC5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLl9vdmVycmlkZXMgPSB7XG5cdFx0XHRuZXh0OiB0aGlzLl9jb3JlLm5leHQsXG5cdFx0XHRwcmV2OiB0aGlzLl9jb3JlLnByZXYsXG5cdFx0XHR0bzogdGhpcy5fY29yZS50b1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBBbGwgZXZlbnQgaGFuZGxlcnMuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0dGhpcy5faGFuZGxlcnMgPSB7XG5cdFx0XHQncHJlcGFyZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XG5cdFx0XHRcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLnNldHRpbmdzLmRvdHNEYXRhKSB7XG5cdFx0XHRcdFx0dGhpcy5fdGVtcGxhdGVzLnB1c2goJzxkaXYgY2xhc3M9XCInICsgdGhpcy5fY29yZS5zZXR0aW5ncy5kb3RDbGFzcyArICdcIj4nICtcblx0XHRcdFx0XHRcdCQoZS5jb250ZW50KS5maW5kKCdbZGF0YS1kb3RdJykuYWRkQmFjaygnW2RhdGEtZG90XScpLmF0dHIoJ2RhdGEtZG90JykgKyAnPC9kaXY+Jyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMpLFxuXHRcdFx0J2FkZGVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5kb3RzRGF0YSkge1xuXHRcdFx0XHRcdHRoaXMuX3RlbXBsYXRlcy5zcGxpY2UoZS5wb3NpdGlvbiwgMCwgdGhpcy5fdGVtcGxhdGVzLnBvcCgpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcyksXG5cdFx0XHQncmVtb3ZlLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5kb3RzRGF0YSkge1xuXHRcdFx0XHRcdHRoaXMuX3RlbXBsYXRlcy5zcGxpY2UoZS5wb3NpdGlvbiwgMSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMpLFxuXHRcdFx0J2NoYW5nZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XG5cdFx0XHRcdGlmIChlLm5hbWVzcGFjZSAmJiBlLnByb3BlcnR5Lm5hbWUgPT0gJ3Bvc2l0aW9uJykge1xuXHRcdFx0XHRcdHRoaXMuZHJhdygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0aGlzKSxcblx0XHRcdCdpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0aWYgKGUubmFtZXNwYWNlICYmICF0aGlzLl9pbml0aWFsaXplZCkge1xuXHRcdFx0XHRcdHRoaXMuX2NvcmUudHJpZ2dlcignaW5pdGlhbGl6ZScsIG51bGwsICduYXZpZ2F0aW9uJyk7XG5cdFx0XHRcdFx0dGhpcy5pbml0aWFsaXplKCk7XG5cdFx0XHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdFx0XHR0aGlzLmRyYXcoKTtcblx0XHRcdFx0XHR0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG5cdFx0XHRcdFx0dGhpcy5fY29yZS50cmlnZ2VyKCdpbml0aWFsaXplZCcsIG51bGwsICduYXZpZ2F0aW9uJyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMpLFxuXHRcdFx0J3JlZnJlc2hlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2luaXRpYWxpemVkKSB7XG5cdFx0XHRcdFx0dGhpcy5fY29yZS50cmlnZ2VyKCdyZWZyZXNoJywgbnVsbCwgJ25hdmlnYXRpb24nKTtcblx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0XHRcdHRoaXMuZHJhdygpO1xuXHRcdFx0XHRcdHRoaXMuX2NvcmUudHJpZ2dlcigncmVmcmVzaGVkJywgbnVsbCwgJ25hdmlnYXRpb24nKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcylcblx0XHR9O1xuXG5cdFx0Ly8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuXHRcdHRoaXMuX2NvcmUub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBOYXZpZ2F0aW9uLkRlZmF1bHRzLCB0aGlzLl9jb3JlLm9wdGlvbnMpO1xuXG5cdFx0Ly8gcmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnNcblx0XHR0aGlzLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcblx0fTtcblxuXHQvKipcblx0ICogRGVmYXVsdCBvcHRpb25zLlxuXHQgKiBAcHVibGljXG5cdCAqIEB0b2RvIFJlbmFtZSBgc2xpZGVCeWAgdG8gYG5hdkJ5YFxuXHQgKi9cblx0TmF2aWdhdGlvbi5EZWZhdWx0cyA9IHtcblx0XHRuYXY6IGZhbHNlLFxuXHRcdG5hdlRleHQ6IFtcblx0XHRcdCc8c3BhbiBhcmlhLWxhYmVsPVwiJyArICdQcmV2aW91cycgKyAnXCI+JiN4MjAzOTs8L3NwYW4+Jyxcblx0XHRcdCc8c3BhbiBhcmlhLWxhYmVsPVwiJyArICdOZXh0JyArICdcIj4mI3gyMDNhOzwvc3Bhbj4nXG5cdFx0XSxcblx0XHRuYXZTcGVlZDogZmFsc2UsXG5cdFx0bmF2RWxlbWVudDogJ2J1dHRvbiB0eXBlPVwiYnV0dG9uXCIgcm9sZT1cInByZXNlbnRhdGlvblwiJyxcblx0XHRuYXZDb250YWluZXI6IGZhbHNlLFxuXHRcdG5hdkNvbnRhaW5lckNsYXNzOiAnb3dsLW5hdicsXG5cdFx0bmF2Q2xhc3M6IFtcblx0XHRcdCdvd2wtcHJldicsXG5cdFx0XHQnb3dsLW5leHQnXG5cdFx0XSxcblx0XHRzbGlkZUJ5OiAxLFxuXHRcdGRvdENsYXNzOiAnb3dsLWRvdCcsXG5cdFx0ZG90c0NsYXNzOiAnb3dsLWRvdHMnLFxuXHRcdGRvdHM6IHRydWUsXG5cdFx0ZG90c0VhY2g6IGZhbHNlLFxuXHRcdGRvdHNEYXRhOiBmYWxzZSxcblx0XHRkb3RzU3BlZWQ6IGZhbHNlLFxuXHRcdGRvdHNDb250YWluZXI6IGZhbHNlXG5cdH07XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemVzIHRoZSBsYXlvdXQgb2YgdGhlIHBsdWdpbiBhbmQgZXh0ZW5kcyB0aGUgY2Fyb3VzZWwuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdE5hdmlnYXRpb24ucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3ZlcnJpZGUsXG5cdFx0XHRzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3M7XG5cblx0XHQvLyBjcmVhdGUgRE9NIHN0cnVjdHVyZSBmb3IgcmVsYXRpdmUgbmF2aWdhdGlvblxuXHRcdHRoaXMuX2NvbnRyb2xzLiRyZWxhdGl2ZSA9IChzZXR0aW5ncy5uYXZDb250YWluZXIgPyAkKHNldHRpbmdzLm5hdkNvbnRhaW5lcilcblx0XHRcdDogJCgnPGRpdj4nKS5hZGRDbGFzcyhzZXR0aW5ncy5uYXZDb250YWluZXJDbGFzcykuYXBwZW5kVG8odGhpcy4kZWxlbWVudCkpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xuXG5cdFx0dGhpcy5fY29udHJvbHMuJHByZXZpb3VzID0gJCgnPCcgKyBzZXR0aW5ncy5uYXZFbGVtZW50ICsgJz4nKVxuXHRcdFx0LmFkZENsYXNzKHNldHRpbmdzLm5hdkNsYXNzWzBdKVxuXHRcdFx0Lmh0bWwoc2V0dGluZ3MubmF2VGV4dFswXSlcblx0XHRcdC5wcmVwZW5kVG8odGhpcy5fY29udHJvbHMuJHJlbGF0aXZlKVxuXHRcdFx0Lm9uKCdjbGljaycsICQucHJveHkoZnVuY3Rpb24oZSkge1xuXHRcdFx0XHR0aGlzLnByZXYoc2V0dGluZ3MubmF2U3BlZWQpO1xuXHRcdFx0fSwgdGhpcykpO1xuXHRcdHRoaXMuX2NvbnRyb2xzLiRuZXh0ID0gJCgnPCcgKyBzZXR0aW5ncy5uYXZFbGVtZW50ICsgJz4nKVxuXHRcdFx0LmFkZENsYXNzKHNldHRpbmdzLm5hdkNsYXNzWzFdKVxuXHRcdFx0Lmh0bWwoc2V0dGluZ3MubmF2VGV4dFsxXSlcblx0XHRcdC5hcHBlbmRUbyh0aGlzLl9jb250cm9scy4kcmVsYXRpdmUpXG5cdFx0XHQub24oJ2NsaWNrJywgJC5wcm94eShmdW5jdGlvbihlKSB7XG5cdFx0XHRcdHRoaXMubmV4dChzZXR0aW5ncy5uYXZTcGVlZCk7XG5cdFx0XHR9LCB0aGlzKSk7XG5cblx0XHQvLyBjcmVhdGUgRE9NIHN0cnVjdHVyZSBmb3IgYWJzb2x1dGUgbmF2aWdhdGlvblxuXHRcdGlmICghc2V0dGluZ3MuZG90c0RhdGEpIHtcblx0XHRcdHRoaXMuX3RlbXBsYXRlcyA9IFsgJCgnPGJ1dHRvbiByb2xlPVwiYnV0dG9uXCI+Jylcblx0XHRcdFx0LmFkZENsYXNzKHNldHRpbmdzLmRvdENsYXNzKVxuXHRcdFx0XHQuYXBwZW5kKCQoJzxzcGFuPicpKVxuXHRcdFx0XHQucHJvcCgnb3V0ZXJIVE1MJykgXTtcblx0XHR9XG5cblx0XHR0aGlzLl9jb250cm9scy4kYWJzb2x1dGUgPSAoc2V0dGluZ3MuZG90c0NvbnRhaW5lciA/ICQoc2V0dGluZ3MuZG90c0NvbnRhaW5lcilcblx0XHRcdDogJCgnPGRpdj4nKS5hZGRDbGFzcyhzZXR0aW5ncy5kb3RzQ2xhc3MpLmFwcGVuZFRvKHRoaXMuJGVsZW1lbnQpKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcblxuXHRcdHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZS5vbignY2xpY2snLCAnYnV0dG9uJywgJC5wcm94eShmdW5jdGlvbihlKSB7XG5cdFx0XHR2YXIgaW5kZXggPSAkKGUudGFyZ2V0KS5wYXJlbnQoKS5pcyh0aGlzLl9jb250cm9scy4kYWJzb2x1dGUpXG5cdFx0XHRcdD8gJChlLnRhcmdldCkuaW5kZXgoKSA6ICQoZS50YXJnZXQpLnBhcmVudCgpLmluZGV4KCk7XG5cblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0dGhpcy50byhpbmRleCwgc2V0dGluZ3MuZG90c1NwZWVkKTtcblx0XHR9LCB0aGlzKSk7XG5cblx0XHQvKiRlbC5vbignZm9jdXNpbicsIGZ1bmN0aW9uKCkge1xuXHRcdFx0JChkb2N1bWVudCkub2ZmKFwiLmNhcm91c2VsXCIpO1xuXG5cdFx0XHQkKGRvY3VtZW50KS5vbigna2V5ZG93bi5jYXJvdXNlbCcsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0aWYoZS5rZXlDb2RlID09IDM3KSB7XG5cdFx0XHRcdFx0JGVsLnRyaWdnZXIoJ3ByZXYub3dsJylcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihlLmtleUNvZGUgPT0gMzkpIHtcblx0XHRcdFx0XHQkZWwudHJpZ2dlcignbmV4dC5vd2wnKVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTsqL1xuXG5cdFx0Ly8gb3ZlcnJpZGUgcHVibGljIG1ldGhvZHMgb2YgdGhlIGNhcm91c2VsXG5cdFx0Zm9yIChvdmVycmlkZSBpbiB0aGlzLl9vdmVycmlkZXMpIHtcblx0XHRcdHRoaXMuX2NvcmVbb3ZlcnJpZGVdID0gJC5wcm94eSh0aGlzW292ZXJyaWRlXSwgdGhpcyk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHROYXZpZ2F0aW9uLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhhbmRsZXIsIGNvbnRyb2wsIHByb3BlcnR5LCBvdmVycmlkZSwgc2V0dGluZ3M7XG5cdFx0c2V0dGluZ3MgPSB0aGlzLl9jb3JlLnNldHRpbmdzO1xuXG5cdFx0Zm9yIChoYW5kbGVyIGluIHRoaXMuX2hhbmRsZXJzKSB7XG5cdFx0XHR0aGlzLiRlbGVtZW50Lm9mZihoYW5kbGVyLCB0aGlzLl9oYW5kbGVyc1toYW5kbGVyXSk7XG5cdFx0fVxuXHRcdGZvciAoY29udHJvbCBpbiB0aGlzLl9jb250cm9scykge1xuXHRcdFx0aWYgKGNvbnRyb2wgPT09ICckcmVsYXRpdmUnICYmIHNldHRpbmdzLm5hdkNvbnRhaW5lcikge1xuXHRcdFx0XHR0aGlzLl9jb250cm9sc1tjb250cm9sXS5odG1sKCcnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX2NvbnRyb2xzW2NvbnRyb2xdLnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmb3IgKG92ZXJyaWRlIGluIHRoaXMub3ZlcmlkZXMpIHtcblx0XHRcdHRoaXMuX2NvcmVbb3ZlcnJpZGVdID0gdGhpcy5fb3ZlcnJpZGVzW292ZXJyaWRlXTtcblx0XHR9XG5cdFx0Zm9yIChwcm9wZXJ0eSBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSkge1xuXHRcdFx0dHlwZW9mIHRoaXNbcHJvcGVydHldICE9ICdmdW5jdGlvbicgJiYgKHRoaXNbcHJvcGVydHldID0gbnVsbCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBpbnRlcm5hbCBzdGF0ZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0TmF2aWdhdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGksIGosIGssXG5cdFx0XHRsb3dlciA9IHRoaXMuX2NvcmUuY2xvbmVzKCkubGVuZ3RoIC8gMixcblx0XHRcdHVwcGVyID0gbG93ZXIgKyB0aGlzLl9jb3JlLml0ZW1zKCkubGVuZ3RoLFxuXHRcdFx0bWF4aW11bSA9IHRoaXMuX2NvcmUubWF4aW11bSh0cnVlKSxcblx0XHRcdHNldHRpbmdzID0gdGhpcy5fY29yZS5zZXR0aW5ncyxcblx0XHRcdHNpemUgPSBzZXR0aW5ncy5jZW50ZXIgfHwgc2V0dGluZ3MuYXV0b1dpZHRoIHx8IHNldHRpbmdzLmRvdHNEYXRhXG5cdFx0XHRcdD8gMSA6IHNldHRpbmdzLmRvdHNFYWNoIHx8IHNldHRpbmdzLml0ZW1zO1xuXG5cdFx0aWYgKHNldHRpbmdzLnNsaWRlQnkgIT09ICdwYWdlJykge1xuXHRcdFx0c2V0dGluZ3Muc2xpZGVCeSA9IE1hdGgubWluKHNldHRpbmdzLnNsaWRlQnksIHNldHRpbmdzLml0ZW1zKTtcblx0XHR9XG5cblx0XHRpZiAoc2V0dGluZ3MuZG90cyB8fCBzZXR0aW5ncy5zbGlkZUJ5ID09ICdwYWdlJykge1xuXHRcdFx0dGhpcy5fcGFnZXMgPSBbXTtcblxuXHRcdFx0Zm9yIChpID0gbG93ZXIsIGogPSAwLCBrID0gMDsgaSA8IHVwcGVyOyBpKyspIHtcblx0XHRcdFx0aWYgKGogPj0gc2l6ZSB8fCBqID09PSAwKSB7XG5cdFx0XHRcdFx0dGhpcy5fcGFnZXMucHVzaCh7XG5cdFx0XHRcdFx0XHRzdGFydDogTWF0aC5taW4obWF4aW11bSwgaSAtIGxvd2VyKSxcblx0XHRcdFx0XHRcdGVuZDogaSAtIGxvd2VyICsgc2l6ZSAtIDFcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRpZiAoTWF0aC5taW4obWF4aW11bSwgaSAtIGxvd2VyKSA9PT0gbWF4aW11bSkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGogPSAwLCArK2s7XG5cdFx0XHRcdH1cblx0XHRcdFx0aiArPSB0aGlzLl9jb3JlLm1lcmdlcnModGhpcy5fY29yZS5yZWxhdGl2ZShpKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBEcmF3cyB0aGUgdXNlciBpbnRlcmZhY2UuXG5cdCAqIEB0b2RvIFRoZSBvcHRpb24gYGRvdHNEYXRhYCB3b250IHdvcmsuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdE5hdmlnYXRpb24ucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGlmZmVyZW5jZSxcblx0XHRcdHNldHRpbmdzID0gdGhpcy5fY29yZS5zZXR0aW5ncyxcblx0XHRcdGRpc2FibGVkID0gdGhpcy5fY29yZS5pdGVtcygpLmxlbmd0aCA8PSBzZXR0aW5ncy5pdGVtcyxcblx0XHRcdGluZGV4ID0gdGhpcy5fY29yZS5yZWxhdGl2ZSh0aGlzLl9jb3JlLmN1cnJlbnQoKSksXG5cdFx0XHRsb29wID0gc2V0dGluZ3MubG9vcCB8fCBzZXR0aW5ncy5yZXdpbmQ7XG5cblx0XHR0aGlzLl9jb250cm9scy4kcmVsYXRpdmUudG9nZ2xlQ2xhc3MoJ2Rpc2FibGVkJywgIXNldHRpbmdzLm5hdiB8fCBkaXNhYmxlZCk7XG5cblx0XHRpZiAoc2V0dGluZ3MubmF2KSB7XG5cdFx0XHR0aGlzLl9jb250cm9scy4kcHJldmlvdXMudG9nZ2xlQ2xhc3MoJ2Rpc2FibGVkJywgIWxvb3AgJiYgaW5kZXggPD0gdGhpcy5fY29yZS5taW5pbXVtKHRydWUpKTtcblx0XHRcdHRoaXMuX2NvbnRyb2xzLiRuZXh0LnRvZ2dsZUNsYXNzKCdkaXNhYmxlZCcsICFsb29wICYmIGluZGV4ID49IHRoaXMuX2NvcmUubWF4aW11bSh0cnVlKSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fY29udHJvbHMuJGFic29sdXRlLnRvZ2dsZUNsYXNzKCdkaXNhYmxlZCcsICFzZXR0aW5ncy5kb3RzIHx8IGRpc2FibGVkKTtcblxuXHRcdGlmIChzZXR0aW5ncy5kb3RzKSB7XG5cdFx0XHRkaWZmZXJlbmNlID0gdGhpcy5fcGFnZXMubGVuZ3RoIC0gdGhpcy5fY29udHJvbHMuJGFic29sdXRlLmNoaWxkcmVuKCkubGVuZ3RoO1xuXG5cdFx0XHRpZiAoc2V0dGluZ3MuZG90c0RhdGEgJiYgZGlmZmVyZW5jZSAhPT0gMCkge1xuXHRcdFx0XHR0aGlzLl9jb250cm9scy4kYWJzb2x1dGUuaHRtbCh0aGlzLl90ZW1wbGF0ZXMuam9pbignJykpO1xuXHRcdFx0fSBlbHNlIGlmIChkaWZmZXJlbmNlID4gMCkge1xuXHRcdFx0XHR0aGlzLl9jb250cm9scy4kYWJzb2x1dGUuYXBwZW5kKG5ldyBBcnJheShkaWZmZXJlbmNlICsgMSkuam9pbih0aGlzLl90ZW1wbGF0ZXNbMF0pKTtcblx0XHRcdH0gZWxzZSBpZiAoZGlmZmVyZW5jZSA8IDApIHtcblx0XHRcdFx0dGhpcy5fY29udHJvbHMuJGFic29sdXRlLmNoaWxkcmVuKCkuc2xpY2UoZGlmZmVyZW5jZSkucmVtb3ZlKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZS5maW5kKCcuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuXHRcdFx0dGhpcy5fY29udHJvbHMuJGFic29sdXRlLmNoaWxkcmVuKCkuZXEoJC5pbkFycmF5KHRoaXMuY3VycmVudCgpLCB0aGlzLl9wYWdlcykpLmFkZENsYXNzKCdhY3RpdmUnKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEV4dGVuZHMgZXZlbnQgZGF0YS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCBvYmplY3Qgd2hpY2ggZ2V0cyB0aHJvd24uXG5cdCAqL1xuXHROYXZpZ2F0aW9uLnByb3RvdHlwZS5vblRyaWdnZXIgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3M7XG5cblx0XHRldmVudC5wYWdlID0ge1xuXHRcdFx0aW5kZXg6ICQuaW5BcnJheSh0aGlzLmN1cnJlbnQoKSwgdGhpcy5fcGFnZXMpLFxuXHRcdFx0Y291bnQ6IHRoaXMuX3BhZ2VzLmxlbmd0aCxcblx0XHRcdHNpemU6IHNldHRpbmdzICYmIChzZXR0aW5ncy5jZW50ZXIgfHwgc2V0dGluZ3MuYXV0b1dpZHRoIHx8IHNldHRpbmdzLmRvdHNEYXRhXG5cdFx0XHRcdD8gMSA6IHNldHRpbmdzLmRvdHNFYWNoIHx8IHNldHRpbmdzLml0ZW1zKVxuXHRcdH07XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGN1cnJlbnQgcGFnZSBwb3NpdGlvbiBvZiB0aGUgY2Fyb3VzZWwuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybnMge051bWJlcn1cblx0ICovXG5cdE5hdmlnYXRpb24ucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VycmVudCA9IHRoaXMuX2NvcmUucmVsYXRpdmUodGhpcy5fY29yZS5jdXJyZW50KCkpO1xuXHRcdHJldHVybiAkLmdyZXAodGhpcy5fcGFnZXMsICQucHJveHkoZnVuY3Rpb24ocGFnZSwgaW5kZXgpIHtcblx0XHRcdHJldHVybiBwYWdlLnN0YXJ0IDw9IGN1cnJlbnQgJiYgcGFnZS5lbmQgPj0gY3VycmVudDtcblx0XHR9LCB0aGlzKSkucG9wKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGN1cnJlbnQgc3VjY2Vzb3IvcHJlZGVjZXNzb3IgcG9zaXRpb24uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybnMge051bWJlcn1cblx0ICovXG5cdE5hdmlnYXRpb24ucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24oc3VjY2Vzc29yKSB7XG5cdFx0dmFyIHBvc2l0aW9uLCBsZW5ndGgsXG5cdFx0XHRzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3M7XG5cblx0XHRpZiAoc2V0dGluZ3Muc2xpZGVCeSA9PSAncGFnZScpIHtcblx0XHRcdHBvc2l0aW9uID0gJC5pbkFycmF5KHRoaXMuY3VycmVudCgpLCB0aGlzLl9wYWdlcyk7XG5cdFx0XHRsZW5ndGggPSB0aGlzLl9wYWdlcy5sZW5ndGg7XG5cdFx0XHRzdWNjZXNzb3IgPyArK3Bvc2l0aW9uIDogLS1wb3NpdGlvbjtcblx0XHRcdHBvc2l0aW9uID0gdGhpcy5fcGFnZXNbKChwb3NpdGlvbiAlIGxlbmd0aCkgKyBsZW5ndGgpICUgbGVuZ3RoXS5zdGFydDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cG9zaXRpb24gPSB0aGlzLl9jb3JlLnJlbGF0aXZlKHRoaXMuX2NvcmUuY3VycmVudCgpKTtcblx0XHRcdGxlbmd0aCA9IHRoaXMuX2NvcmUuaXRlbXMoKS5sZW5ndGg7XG5cdFx0XHRzdWNjZXNzb3IgPyBwb3NpdGlvbiArPSBzZXR0aW5ncy5zbGlkZUJ5IDogcG9zaXRpb24gLT0gc2V0dGluZ3Muc2xpZGVCeTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcG9zaXRpb247XG5cdH07XG5cblx0LyoqXG5cdCAqIFNsaWRlcyB0byB0aGUgbmV4dCBpdGVtIG9yIHBhZ2UuXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZD1mYWxzZV0gLSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0cmFuc2l0aW9uLlxuXHQgKi9cblx0TmF2aWdhdGlvbi5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKHNwZWVkKSB7XG5cdFx0JC5wcm94eSh0aGlzLl9vdmVycmlkZXMudG8sIHRoaXMuX2NvcmUpKHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSksIHNwZWVkKTtcblx0fTtcblxuXHQvKipcblx0ICogU2xpZGVzIHRvIHRoZSBwcmV2aW91cyBpdGVtIG9yIHBhZ2UuXG5cdCAqIEBwdWJsaWNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZD1mYWxzZV0gLSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0cmFuc2l0aW9uLlxuXHQgKi9cblx0TmF2aWdhdGlvbi5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uKHNwZWVkKSB7XG5cdFx0JC5wcm94eSh0aGlzLl9vdmVycmlkZXMudG8sIHRoaXMuX2NvcmUpKHRoaXMuZ2V0UG9zaXRpb24oZmFsc2UpLCBzcGVlZCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNsaWRlcyB0byB0aGUgc3BlY2lmaWVkIGl0ZW0gb3IgcGFnZS5cblx0ICogQHB1YmxpY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0gb3IgcGFnZS5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZF0gLSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0cmFuc2l0aW9uLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGFuZGFyZD1mYWxzZV0gLSBXaGV0aGVyIHRvIHVzZSB0aGUgc3RhbmRhcmQgYmVoYXZpb3VyIG9yIG5vdC5cblx0ICovXG5cdE5hdmlnYXRpb24ucHJvdG90eXBlLnRvID0gZnVuY3Rpb24ocG9zaXRpb24sIHNwZWVkLCBzdGFuZGFyZCkge1xuXHRcdHZhciBsZW5ndGg7XG5cblx0XHRpZiAoIXN0YW5kYXJkICYmIHRoaXMuX3BhZ2VzLmxlbmd0aCkge1xuXHRcdFx0bGVuZ3RoID0gdGhpcy5fcGFnZXMubGVuZ3RoO1xuXHRcdFx0JC5wcm94eSh0aGlzLl9vdmVycmlkZXMudG8sIHRoaXMuX2NvcmUpKHRoaXMuX3BhZ2VzWygocG9zaXRpb24gJSBsZW5ndGgpICsgbGVuZ3RoKSAlIGxlbmd0aF0uc3RhcnQsIHNwZWVkKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0JC5wcm94eSh0aGlzLl9vdmVycmlkZXMudG8sIHRoaXMuX2NvcmUpKHBvc2l0aW9uLCBzcGVlZCk7XG5cdFx0fVxuXHR9O1xuXG5cdCQuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IuUGx1Z2lucy5OYXZpZ2F0aW9uID0gTmF2aWdhdGlvbjtcblxufSkod2luZG93LlplcHRvIHx8IHdpbmRvdy5qUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xuXG4vKipcbiAqIEhhc2ggUGx1Z2luXG4gKiBAdmVyc2lvbiAyLjMuNFxuICogQGF1dGhvciBBcnR1cyBLb2xhbm93c2tpXG4gKiBAYXV0aG9yIERhdmlkIERldXRzY2hcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICovXG47KGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgdGhlIGhhc2ggcGx1Z2luLlxuXHQgKiBAY2xhc3MgVGhlIEhhc2ggUGx1Z2luXG5cdCAqIEBwYXJhbSB7T3dsfSBjYXJvdXNlbCAtIFRoZSBPd2wgQ2Fyb3VzZWxcblx0ICovXG5cdHZhciBIYXNoID0gZnVuY3Rpb24oY2Fyb3VzZWwpIHtcblx0XHQvKipcblx0XHQgKiBSZWZlcmVuY2UgdG8gdGhlIGNvcmUuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEB0eXBlIHtPd2x9XG5cdFx0ICovXG5cdFx0dGhpcy5fY29yZSA9IGNhcm91c2VsO1xuXG5cdFx0LyoqXG5cdFx0ICogSGFzaCBpbmRleCBmb3IgdGhlIGl0ZW1zLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAdHlwZSB7T2JqZWN0fVxuXHRcdCAqL1xuXHRcdHRoaXMuX2hhc2hlcyA9IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGNhcm91c2VsIGVsZW1lbnQuXG5cdFx0ICogQHR5cGUge2pRdWVyeX1cblx0XHQgKi9cblx0XHR0aGlzLiRlbGVtZW50ID0gdGhpcy5fY29yZS4kZWxlbWVudDtcblxuXHRcdC8qKlxuXHRcdCAqIEFsbCBldmVudCBoYW5kbGVycy5cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHR5cGUge09iamVjdH1cblx0XHQgKi9cblx0XHR0aGlzLl9oYW5kbGVycyA9IHtcblx0XHRcdCdpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2NvcmUuc2V0dGluZ3Muc3RhcnRQb3NpdGlvbiA9PT0gJ1VSTEhhc2gnKSB7XG5cdFx0XHRcdFx0JCh3aW5kb3cpLnRyaWdnZXIoJ2hhc2hjaGFuZ2Uub3dsLm5hdmlnYXRpb24nKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcyksXG5cdFx0XHQncHJlcGFyZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbihlKSB7XG5cdFx0XHRcdGlmIChlLm5hbWVzcGFjZSkge1xuXHRcdFx0XHRcdHZhciBoYXNoID0gJChlLmNvbnRlbnQpLmZpbmQoJ1tkYXRhLWhhc2hdJykuYWRkQmFjaygnW2RhdGEtaGFzaF0nKS5hdHRyKCdkYXRhLWhhc2gnKTtcblxuXHRcdFx0XHRcdGlmICghaGFzaCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuX2hhc2hlc1toYXNoXSA9IGUuY29udGVudDtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcyksXG5cdFx0XHQnY2hhbmdlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0aWYgKGUubmFtZXNwYWNlICYmIGUucHJvcGVydHkubmFtZSA9PT0gJ3Bvc2l0aW9uJykge1xuXHRcdFx0XHRcdHZhciBjdXJyZW50ID0gdGhpcy5fY29yZS5pdGVtcyh0aGlzLl9jb3JlLnJlbGF0aXZlKHRoaXMuX2NvcmUuY3VycmVudCgpKSksXG5cdFx0XHRcdFx0XHRoYXNoID0gJC5tYXAodGhpcy5faGFzaGVzLCBmdW5jdGlvbihpdGVtLCBoYXNoKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBpdGVtID09PSBjdXJyZW50ID8gaGFzaCA6IG51bGw7XG5cdFx0XHRcdFx0XHR9KS5qb2luKCk7XG5cblx0XHRcdFx0XHRpZiAoIWhhc2ggfHwgd2luZG93LmxvY2F0aW9uLmhhc2guc2xpY2UoMSkgPT09IGhhc2gpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR3aW5kb3cubG9jYXRpb24uaGFzaCA9IGhhc2g7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMpXG5cdFx0fTtcblxuXHRcdC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcblx0XHR0aGlzLl9jb3JlLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgSGFzaC5EZWZhdWx0cywgdGhpcy5fY29yZS5vcHRpb25zKTtcblxuXHRcdC8vIHJlZ2lzdGVyIHRoZSBldmVudCBoYW5kbGVyc1xuXHRcdHRoaXMuJGVsZW1lbnQub24odGhpcy5faGFuZGxlcnMpO1xuXG5cdFx0Ly8gcmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXIgZm9yIGhhc2ggbmF2aWdhdGlvblxuXHRcdCQod2luZG93KS5vbignaGFzaGNoYW5nZS5vd2wubmF2aWdhdGlvbicsICQucHJveHkoZnVuY3Rpb24oZSkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaC5zdWJzdHJpbmcoMSksXG5cdFx0XHRcdGl0ZW1zID0gdGhpcy5fY29yZS4kc3RhZ2UuY2hpbGRyZW4oKSxcblx0XHRcdFx0cG9zaXRpb24gPSB0aGlzLl9oYXNoZXNbaGFzaF0gJiYgaXRlbXMuaW5kZXgodGhpcy5faGFzaGVzW2hhc2hdKTtcblxuXHRcdFx0aWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb24gPT09IHRoaXMuX2NvcmUuY3VycmVudCgpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fY29yZS50byh0aGlzLl9jb3JlLnJlbGF0aXZlKHBvc2l0aW9uKSwgZmFsc2UsIHRydWUpO1xuXHRcdH0sIHRoaXMpKTtcblx0fTtcblxuXHQvKipcblx0ICogRGVmYXVsdCBvcHRpb25zLlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRIYXNoLkRlZmF1bHRzID0ge1xuXHRcdFVSTGhhc2hMaXN0ZW5lcjogZmFsc2Vcblx0fTtcblxuXHQvKipcblx0ICogRGVzdHJveXMgdGhlIHBsdWdpbi5cblx0ICogQHB1YmxpY1xuXHQgKi9cblx0SGFzaC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYW5kbGVyLCBwcm9wZXJ0eTtcblxuXHRcdCQod2luZG93KS5vZmYoJ2hhc2hjaGFuZ2Uub3dsLm5hdmlnYXRpb24nKTtcblxuXHRcdGZvciAoaGFuZGxlciBpbiB0aGlzLl9oYW5kbGVycykge1xuXHRcdFx0dGhpcy5fY29yZS4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5faGFuZGxlcnNbaGFuZGxlcl0pO1xuXHRcdH1cblx0XHRmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XG5cdFx0XHR0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gJ2Z1bmN0aW9uJyAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcblx0XHR9XG5cdH07XG5cblx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLkhhc2ggPSBIYXNoO1xuXG59KSh3aW5kb3cuWmVwdG8gfHwgd2luZG93LmpRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XG5cbi8qKlxuICogU3VwcG9ydCBQbHVnaW5cbiAqXG4gKiBAdmVyc2lvbiAyLjMuNFxuICogQGF1dGhvciBWaXZpZCBQbGFuZXQgU29mdHdhcmUgR21iSFxuICogQGF1dGhvciBBcnR1cyBLb2xhbm93c2tpXG4gKiBAYXV0aG9yIERhdmlkIERldXRzY2hcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICovXG47KGZ1bmN0aW9uKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuXG5cdHZhciBzdHlsZSA9ICQoJzxzdXBwb3J0PicpLmdldCgwKS5zdHlsZSxcblx0XHRwcmVmaXhlcyA9ICdXZWJraXQgTW96IE8gbXMnLnNwbGl0KCcgJyksXG5cdFx0ZXZlbnRzID0ge1xuXHRcdFx0dHJhbnNpdGlvbjoge1xuXHRcdFx0XHRlbmQ6IHtcblx0XHRcdFx0XHRXZWJraXRUcmFuc2l0aW9uOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG5cdFx0XHRcdFx0TW96VHJhbnNpdGlvbjogJ3RyYW5zaXRpb25lbmQnLFxuXHRcdFx0XHRcdE9UcmFuc2l0aW9uOiAnb1RyYW5zaXRpb25FbmQnLFxuXHRcdFx0XHRcdHRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJ1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0YW5pbWF0aW9uOiB7XG5cdFx0XHRcdGVuZDoge1xuXHRcdFx0XHRcdFdlYmtpdEFuaW1hdGlvbjogJ3dlYmtpdEFuaW1hdGlvbkVuZCcsXG5cdFx0XHRcdFx0TW96QW5pbWF0aW9uOiAnYW5pbWF0aW9uZW5kJyxcblx0XHRcdFx0XHRPQW5pbWF0aW9uOiAnb0FuaW1hdGlvbkVuZCcsXG5cdFx0XHRcdFx0YW5pbWF0aW9uOiAnYW5pbWF0aW9uZW5kJ1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR0ZXN0cyA9IHtcblx0XHRcdGNzc3RyYW5zZm9ybXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISF0ZXN0KCd0cmFuc2Zvcm0nKTtcblx0XHRcdH0sXG5cdFx0XHRjc3N0cmFuc2Zvcm1zM2Q6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISF0ZXN0KCdwZXJzcGVjdGl2ZScpO1xuXHRcdFx0fSxcblx0XHRcdGNzc3RyYW5zaXRpb25zOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhdGVzdCgndHJhbnNpdGlvbicpO1xuXHRcdFx0fSxcblx0XHRcdGNzc2FuaW1hdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISF0ZXN0KCdhbmltYXRpb24nKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdGZ1bmN0aW9uIHRlc3QocHJvcGVydHksIHByZWZpeGVkKSB7XG5cdFx0dmFyIHJlc3VsdCA9IGZhbHNlLFxuXHRcdFx0dXBwZXIgPSBwcm9wZXJ0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG5cdFx0JC5lYWNoKChwcm9wZXJ0eSArICcgJyArIHByZWZpeGVzLmpvaW4odXBwZXIgKyAnICcpICsgdXBwZXIpLnNwbGl0KCcgJyksIGZ1bmN0aW9uKGksIHByb3BlcnR5KSB7XG5cdFx0XHRpZiAoc3R5bGVbcHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmVzdWx0ID0gcHJlZml4ZWQgPyBwcm9wZXJ0eSA6IHRydWU7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRmdW5jdGlvbiBwcmVmaXhlZChwcm9wZXJ0eSkge1xuXHRcdHJldHVybiB0ZXN0KHByb3BlcnR5LCB0cnVlKTtcblx0fVxuXG5cdGlmICh0ZXN0cy5jc3N0cmFuc2l0aW9ucygpKSB7XG5cdFx0LyoganNoaW50IC1XMDUzICovXG5cdFx0JC5zdXBwb3J0LnRyYW5zaXRpb24gPSBuZXcgU3RyaW5nKHByZWZpeGVkKCd0cmFuc2l0aW9uJykpXG5cdFx0JC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kID0gZXZlbnRzLnRyYW5zaXRpb24uZW5kWyAkLnN1cHBvcnQudHJhbnNpdGlvbiBdO1xuXHR9XG5cblx0aWYgKHRlc3RzLmNzc2FuaW1hdGlvbnMoKSkge1xuXHRcdC8qIGpzaGludCAtVzA1MyAqL1xuXHRcdCQuc3VwcG9ydC5hbmltYXRpb24gPSBuZXcgU3RyaW5nKHByZWZpeGVkKCdhbmltYXRpb24nKSlcblx0XHQkLnN1cHBvcnQuYW5pbWF0aW9uLmVuZCA9IGV2ZW50cy5hbmltYXRpb24uZW5kWyAkLnN1cHBvcnQuYW5pbWF0aW9uIF07XG5cdH1cblxuXHRpZiAodGVzdHMuY3NzdHJhbnNmb3JtcygpKSB7XG5cdFx0LyoganNoaW50IC1XMDUzICovXG5cdFx0JC5zdXBwb3J0LnRyYW5zZm9ybSA9IG5ldyBTdHJpbmcocHJlZml4ZWQoJ3RyYW5zZm9ybScpKTtcblx0XHQkLnN1cHBvcnQudHJhbnNmb3JtM2QgPSB0ZXN0cy5jc3N0cmFuc2Zvcm1zM2QoKTtcblx0fVxuXG59KSh3aW5kb3cuWmVwdG8gfHwgd2luZG93LmpRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XG4iLCJleHBvcnQgZGVmYXVsdCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnO1xuIiwiaW1wb3J0IGlzQnJvd3NlciBmcm9tICcuL2lzQnJvd3Nlcic7XG5cbmNvbnN0IHRpbWVvdXREdXJhdGlvbiA9IChmdW5jdGlvbigpe1xuICBjb25zdCBsb25nZXJUaW1lb3V0QnJvd3NlcnMgPSBbJ0VkZ2UnLCAnVHJpZGVudCcsICdGaXJlZm94J107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbG9uZ2VyVGltZW91dEJyb3dzZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGlzQnJvd3NlciAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YobG9uZ2VyVGltZW91dEJyb3dzZXJzW2ldKSA+PSAwKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59KCkpO1xuXG5leHBvcnQgZnVuY3Rpb24gbWljcm90YXNrRGVib3VuY2UoZm4pIHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlXG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWVcbiAgICB3aW5kb3cuUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICBjYWxsZWQgPSBmYWxzZVxuICAgICAgZm4oKVxuICAgIH0pXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRhc2tEZWJvdW5jZShmbikge1xuICBsZXQgc2NoZWR1bGVkID0gZmFsc2U7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICAgIHNjaGVkdWxlZCA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIGZuKCk7XG4gICAgICB9LCB0aW1lb3V0RHVyYXRpb24pO1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3Qgc3VwcG9ydHNNaWNyb1Rhc2tzID0gaXNCcm93c2VyICYmIHdpbmRvdy5Qcm9taXNlXG5cblxuLyoqXG4qIENyZWF0ZSBhIGRlYm91bmNlZCB2ZXJzaW9uIG9mIGEgbWV0aG9kLCB0aGF0J3MgYXN5bmNocm9ub3VzbHkgZGVmZXJyZWRcbiogYnV0IGNhbGxlZCBpbiB0aGUgbWluaW11bSB0aW1lIHBvc3NpYmxlLlxuKlxuKiBAbWV0aG9kXG4qIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiogQGFyZ3VtZW50IHtGdW5jdGlvbn0gZm5cbiogQHJldHVybnMge0Z1bmN0aW9ufVxuKi9cbmV4cG9ydCBkZWZhdWx0IChzdXBwb3J0c01pY3JvVGFza3NcbiAgPyBtaWNyb3Rhc2tEZWJvdW5jZVxuICA6IHRhc2tEZWJvdW5jZSk7XG4iLCIvKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FueX0gZnVuY3Rpb25Ub0NoZWNrIC0gdmFyaWFibGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSBhbnN3ZXIgdG86IGlzIGEgZnVuY3Rpb24/XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuY3Rpb25Ub0NoZWNrKSB7XG4gIGNvbnN0IGdldFR5cGUgPSB7fTtcbiAgcmV0dXJuIChcbiAgICBmdW5jdGlvblRvQ2hlY2sgJiZcbiAgICBnZXRUeXBlLnRvU3RyaW5nLmNhbGwoZnVuY3Rpb25Ub0NoZWNrKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJ1xuICApO1xufVxuIiwiLyoqXG4gKiBHZXQgQ1NTIGNvbXB1dGVkIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICBjb25zdCB3aW5kb3cgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIGNvbnN0IGNzcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuICByZXR1cm4gcHJvcGVydHkgPyBjc3NbcHJvcGVydHldIDogY3NzO1xufVxuIiwiLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXJlbnROb2RlIG9yIHRoZSBob3N0IG9mIHRoZSBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBwYXJlbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5wYXJlbnROb2RlIHx8IGVsZW1lbnQuaG9zdDtcbn1cbiIsImltcG9ydCBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkgZnJvbSAnLi9nZXRTdHlsZUNvbXB1dGVkUHJvcGVydHknO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSAnLi9nZXRQYXJlbnROb2RlJztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY3JvbGxpbmcgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBzY3JvbGwgcGFyZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChlbGVtZW50KSB7XG4gIC8vIFJldHVybiBib2R5LCBgZ2V0U2Nyb2xsYCB3aWxsIHRha2UgY2FyZSB0byBnZXQgdGhlIGNvcnJlY3QgYHNjcm9sbFRvcGAgZnJvbSBpdFxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keVxuICB9XG5cbiAgc3dpdGNoIChlbGVtZW50Lm5vZGVOYW1lKSB7XG4gICAgY2FzZSAnSFRNTCc6XG4gICAgY2FzZSAnQk9EWSc6XG4gICAgICByZXR1cm4gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHlcbiAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuYm9keVxuICB9XG5cbiAgLy8gRmlyZWZveCB3YW50IHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gIGNvbnN0IHsgb3ZlcmZsb3csIG92ZXJmbG93WCwgb3ZlcmZsb3dZIH0gPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCk7XG4gIGlmICgvKGF1dG98c2Nyb2xsfG92ZXJsYXkpLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKSkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbn1cbiIsIi8qKlxuICogUmV0dXJucyB0aGUgcmVmZXJlbmNlIG5vZGUgb2YgdGhlIHJlZmVyZW5jZSBvYmplY3QsIG9yIHRoZSByZWZlcmVuY2Ugb2JqZWN0IGl0c2VsZi5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IHJlZmVyZW5jZSAtIHRoZSByZWZlcmVuY2UgZWxlbWVudCAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcGFyZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFJlZmVyZW5jZU5vZGUocmVmZXJlbmNlKSB7XG4gIHJldHVybiByZWZlcmVuY2UgJiYgcmVmZXJlbmNlLnJlZmVyZW5jZU5vZGUgPyByZWZlcmVuY2UucmVmZXJlbmNlTm9kZSA6IHJlZmVyZW5jZTtcbn1cbiIsImltcG9ydCBpc0Jyb3dzZXIgZnJvbSAnLi9pc0Jyb3dzZXInO1xuXG5jb25zdCBpc0lFMTEgPSBpc0Jyb3dzZXIgJiYgISEod2luZG93Lk1TSW5wdXRNZXRob2RDb250ZXh0ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSk7XG5jb25zdCBpc0lFMTAgPSBpc0Jyb3dzZXIgJiYgL01TSUUgMTAvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgYnJvd3NlciBpcyBJbnRlcm5ldCBFeHBsb3JlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtOdW1iZXJ9IHZlcnNpb24gdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSBpc0lFXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzSUUodmVyc2lvbikge1xuICBpZiAodmVyc2lvbiA9PT0gMTEpIHtcbiAgICByZXR1cm4gaXNJRTExO1xuICB9XG4gIGlmICh2ZXJzaW9uID09PSAxMCkge1xuICAgIHJldHVybiBpc0lFMTA7XG4gIH1cbiAgcmV0dXJuIGlzSUUxMSB8fCBpc0lFMTA7XG59XG4iLCJpbXBvcnQgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5IGZyb20gJy4vZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5JztcbmltcG9ydCBpc0lFIGZyb20gJy4vaXNJRSc7XG4vKipcbiAqIFJldHVybnMgdGhlIG9mZnNldCBwYXJlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IG9mZnNldCBwYXJlbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIGNvbnN0IG5vT2Zmc2V0UGFyZW50ID0gaXNJRSgxMCkgPyBkb2N1bWVudC5ib2R5IDogbnVsbDtcblxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICBsZXQgb2Zmc2V0UGFyZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQgfHwgbnVsbDtcbiAgLy8gU2tpcCBoaWRkZW4gZWxlbWVudHMgd2hpY2ggZG9uJ3QgaGF2ZSBhbiBvZmZzZXRQYXJlbnRcbiAgd2hpbGUgKG9mZnNldFBhcmVudCA9PT0gbm9PZmZzZXRQYXJlbnQgJiYgZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSAoZWxlbWVudCA9IGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKS5vZmZzZXRQYXJlbnQ7XG4gIH1cblxuICBjb25zdCBub2RlTmFtZSA9IG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQubm9kZU5hbWU7XG5cbiAgaWYgKCFub2RlTmFtZSB8fCBub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZWxlbWVudCA/IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyAub2Zmc2V0UGFyZW50IHdpbGwgcmV0dXJuIHRoZSBjbG9zZXN0IFRILCBURCBvciBUQUJMRSBpbiBjYXNlXG4gIC8vIG5vIG9mZnNldFBhcmVudCBpcyBwcmVzZW50LCBJIGhhdGUgdGhpcyBqb2IuLi5cbiAgaWYgKFxuICAgIFsnVEgnLCAnVEQnLCAnVEFCTEUnXS5pbmRleE9mKG9mZnNldFBhcmVudC5ub2RlTmFtZSkgIT09IC0xICYmXG4gICAgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KG9mZnNldFBhcmVudCwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnXG4gICkge1xuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQ7XG59XG4iLCJpbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gJy4vZ2V0T2Zmc2V0UGFyZW50JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNPZmZzZXRDb250YWluZXIoZWxlbWVudCkge1xuICBjb25zdCB7IG5vZGVOYW1lIH0gPSBlbGVtZW50O1xuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIG5vZGVOYW1lID09PSAnSFRNTCcgfHwgZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpID09PSBlbGVtZW50XG4gICk7XG59XG4iLCIvKipcbiAqIEZpbmRzIHRoZSByb290IG5vZGUgKGRvY3VtZW50LCBzaGFkb3dET00gcm9vdCkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybnMge0VsZW1lbnR9IHJvb3Qgbm9kZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRSb290KG5vZGUpIHtcbiAgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBnZXRSb290KG5vZGUucGFyZW50Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cbiIsImltcG9ydCBpc09mZnNldENvbnRhaW5lciBmcm9tICcuL2lzT2Zmc2V0Q29udGFpbmVyJztcbmltcG9ydCBnZXRSb290IGZyb20gJy4vZ2V0Um9vdCc7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gJy4vZ2V0T2Zmc2V0UGFyZW50JztcblxuLyoqXG4gKiBGaW5kcyB0aGUgb2Zmc2V0IHBhcmVudCBjb21tb24gdG8gdGhlIHR3byBwcm92aWRlZCBub2Rlc1xuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MVxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MlxuICogQHJldHVybnMge0VsZW1lbnR9IGNvbW1vbiBvZmZzZXQgcGFyZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGVsZW1lbnQyKSB7XG4gIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHRvIGF2b2lkIGVycm9ycyBpbiBjYXNlIG9uZSBvZiB0aGUgZWxlbWVudHMgaXNuJ3QgZGVmaW5lZCBmb3IgYW55IHJlYXNvblxuICBpZiAoIWVsZW1lbnQxIHx8ICFlbGVtZW50MS5ub2RlVHlwZSB8fCAhZWxlbWVudDIgfHwgIWVsZW1lbnQyLm5vZGVUeXBlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIEhlcmUgd2UgbWFrZSBzdXJlIHRvIGdpdmUgYXMgXCJzdGFydFwiIHRoZSBlbGVtZW50IHRoYXQgY29tZXMgZmlyc3QgaW4gdGhlIERPTVxuICBjb25zdCBvcmRlciA9XG4gICAgZWxlbWVudDEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZWxlbWVudDIpICZcbiAgICBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORztcbiAgY29uc3Qgc3RhcnQgPSBvcmRlciA/IGVsZW1lbnQxIDogZWxlbWVudDI7XG4gIGNvbnN0IGVuZCA9IG9yZGVyID8gZWxlbWVudDIgOiBlbGVtZW50MTtcblxuICAvLyBHZXQgY29tbW9uIGFuY2VzdG9yIGNvbnRhaW5lclxuICBjb25zdCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIHJhbmdlLnNldFN0YXJ0KHN0YXJ0LCAwKTtcbiAgcmFuZ2Uuc2V0RW5kKGVuZCwgMCk7XG4gIGNvbnN0IHsgY29tbW9uQW5jZXN0b3JDb250YWluZXIgfSA9IHJhbmdlO1xuXG4gIC8vIEJvdGggbm9kZXMgYXJlIGluc2lkZSAjZG9jdW1lbnRcbiAgaWYgKFxuICAgIChlbGVtZW50MSAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgJiZcbiAgICAgIGVsZW1lbnQyICE9PSBjb21tb25BbmNlc3RvckNvbnRhaW5lcikgfHxcbiAgICBzdGFydC5jb250YWlucyhlbmQpXG4gICkge1xuICAgIGlmIChpc09mZnNldENvbnRhaW5lcihjb21tb25BbmNlc3RvckNvbnRhaW5lcikpIHtcbiAgICAgIHJldHVybiBjb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKTtcbiAgfVxuXG4gIC8vIG9uZSBvZiB0aGUgbm9kZXMgaXMgaW5zaWRlIHNoYWRvd0RPTSwgZmluZCB3aGljaCBvbmVcbiAgY29uc3QgZWxlbWVudDFyb290ID0gZ2V0Um9vdChlbGVtZW50MSk7XG4gIGlmIChlbGVtZW50MXJvb3QuaG9zdCkge1xuICAgIHJldHVybiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxcm9vdC5ob3N0LCBlbGVtZW50Mik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGdldFJvb3QoZWxlbWVudDIpLmhvc3QpO1xuICB9XG59XG4iLCIvKipcbiAqIEdldHMgdGhlIHNjcm9sbCB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBpbiB0aGUgZ2l2ZW4gc2lkZSAodG9wIGFuZCBsZWZ0KVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge1N0cmluZ30gc2lkZSBgdG9wYCBvciBgbGVmdGBcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGFtb3VudCBvZiBzY3JvbGxlZCBwaXhlbHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U2Nyb2xsKGVsZW1lbnQsIHNpZGUgPSAndG9wJykge1xuICBjb25zdCB1cHBlclNpZGUgPSBzaWRlID09PSAndG9wJyA/ICdzY3JvbGxUb3AnIDogJ3Njcm9sbExlZnQnO1xuICBjb25zdCBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIGNvbnN0IGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIGNvbnN0IHNjcm9sbGluZ0VsZW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBodG1sO1xuICAgIHJldHVybiBzY3JvbGxpbmdFbGVtZW50W3VwcGVyU2lkZV07XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFt1cHBlclNpZGVdO1xufVxuIiwiaW1wb3J0IGdldFNjcm9sbCBmcm9tICcuL2dldFNjcm9sbCc7XG5cbi8qXG4gKiBTdW0gb3Igc3VidHJhY3QgdGhlIGVsZW1lbnQgc2Nyb2xsIHZhbHVlcyAobGVmdCBhbmQgdG9wKSBmcm9tIGEgZ2l2ZW4gcmVjdCBvYmplY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IC0gUmVjdCBvYmplY3QgeW91IHdhbnQgdG8gY2hhbmdlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgZnJvbSB0aGUgZnVuY3Rpb24gcmVhZHMgdGhlIHNjcm9sbCB2YWx1ZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3VidHJhY3QgLSBzZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBzdWJ0cmFjdCB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHJldHVybiB7T2JqZWN0fSByZWN0IC0gVGhlIG1vZGlmaWVyIHJlY3Qgb2JqZWN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluY2x1ZGVTY3JvbGwocmVjdCwgZWxlbWVudCwgc3VidHJhY3QgPSBmYWxzZSkge1xuICBjb25zdCBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICBjb25zdCBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jyk7XG4gIGNvbnN0IG1vZGlmaWVyID0gc3VidHJhY3QgPyAtMSA6IDE7XG4gIHJlY3QudG9wICs9IHNjcm9sbFRvcCAqIG1vZGlmaWVyO1xuICByZWN0LmJvdHRvbSArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgcmVjdC5sZWZ0ICs9IHNjcm9sbExlZnQgKiBtb2RpZmllcjtcbiAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0ICogbW9kaWZpZXI7XG4gIHJldHVybiByZWN0O1xufVxuIiwiLypcbiAqIEhlbHBlciB0byBkZXRlY3QgYm9yZGVycyBvZiBhIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXG4gKiBSZXN1bHQgb2YgYGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eWAgb24gdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBheGlzIC0gYHhgIG9yIGB5YFxuICogQHJldHVybiB7bnVtYmVyfSBib3JkZXJzIC0gVGhlIGJvcmRlcnMgc2l6ZSBvZiB0aGUgZ2l2ZW4gYXhpc1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcywgYXhpcykge1xuICBjb25zdCBzaWRlQSA9IGF4aXMgPT09ICd4JyA/ICdMZWZ0JyA6ICdUb3AnO1xuICBjb25zdCBzaWRlQiA9IHNpZGVBID09PSAnTGVmdCcgPyAnUmlnaHQnIDogJ0JvdHRvbSc7XG5cbiAgcmV0dXJuIChcbiAgICBwYXJzZUZsb2F0KHN0eWxlc1tgYm9yZGVyJHtzaWRlQX1XaWR0aGBdLCAxMCkgK1xuICAgIHBhcnNlRmxvYXQoc3R5bGVzW2Bib3JkZXIke3NpZGVCfVdpZHRoYF0sIDEwKVxuICApO1xufVxuIiwiaW1wb3J0IGlzSUUgZnJvbSAnLi9pc0lFJztcblxuZnVuY3Rpb24gZ2V0U2l6ZShheGlzLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSB7XG4gIHJldHVybiBNYXRoLm1heChcbiAgICBib2R5W2BvZmZzZXQke2F4aXN9YF0sXG4gICAgYm9keVtgc2Nyb2xsJHtheGlzfWBdLFxuICAgIGh0bWxbYGNsaWVudCR7YXhpc31gXSxcbiAgICBodG1sW2BvZmZzZXQke2F4aXN9YF0sXG4gICAgaHRtbFtgc2Nyb2xsJHtheGlzfWBdLFxuICAgIGlzSUUoMTApXG4gICAgICA/IChwYXJzZUludChodG1sW2BvZmZzZXQke2F4aXN9YF0pICsgXG4gICAgICBwYXJzZUludChjb21wdXRlZFN0eWxlW2BtYXJnaW4ke2F4aXMgPT09ICdIZWlnaHQnID8gJ1RvcCcgOiAnTGVmdCd9YF0pICsgXG4gICAgICBwYXJzZUludChjb21wdXRlZFN0eWxlW2BtYXJnaW4ke2F4aXMgPT09ICdIZWlnaHQnID8gJ0JvdHRvbScgOiAnUmlnaHQnfWBdKSlcbiAgICA6IDAgXG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1NpemVzKGRvY3VtZW50KSB7XG4gIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICBjb25zdCBodG1sID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICBjb25zdCBjb21wdXRlZFN0eWxlID0gaXNJRSgxMCkgJiYgZ2V0Q29tcHV0ZWRTdHlsZShodG1sKTtcblxuICByZXR1cm4ge1xuICAgIGhlaWdodDogZ2V0U2l6ZSgnSGVpZ2h0JywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSksXG4gICAgd2lkdGg6IGdldFNpemUoJ1dpZHRoJywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSksXG4gIH07XG59XG4iLCIvKipcbiAqIEdpdmVuIGVsZW1lbnQgb2Zmc2V0cywgZ2VuZXJhdGUgYW4gb3V0cHV0IHNpbWlsYXIgdG8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gb2Zmc2V0c1xuICogQHJldHVybnMge09iamVjdH0gQ2xpZW50UmVjdCBsaWtlIG91dHB1dFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDbGllbnRSZWN0KG9mZnNldHMpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5vZmZzZXRzLFxuICAgIHJpZ2h0OiBvZmZzZXRzLmxlZnQgKyBvZmZzZXRzLndpZHRoLFxuICAgIGJvdHRvbTogb2Zmc2V0cy50b3AgKyBvZmZzZXRzLmhlaWdodCxcbiAgfTtcbn1cbiIsImltcG9ydCBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkgZnJvbSAnLi9nZXRTdHlsZUNvbXB1dGVkUHJvcGVydHknO1xuaW1wb3J0IGdldEJvcmRlcnNTaXplIGZyb20gJy4vZ2V0Qm9yZGVyc1NpemUnO1xuaW1wb3J0IGdldFdpbmRvd1NpemVzIGZyb20gJy4vZ2V0V2luZG93U2l6ZXMnO1xuaW1wb3J0IGdldFNjcm9sbCBmcm9tICcuL2dldFNjcm9sbCc7XG5pbXBvcnQgZ2V0Q2xpZW50UmVjdCBmcm9tICcuL2dldENsaWVudFJlY3QnO1xuaW1wb3J0IGlzSUUgZnJvbSAnLi9pc0lFJztcblxuLyoqXG4gKiBHZXQgYm91bmRpbmcgY2xpZW50IHJlY3Qgb2YgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7T2JqZWN0fSBjbGllbnQgcmVjdFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCkge1xuICBsZXQgcmVjdCA9IHt9O1xuXG4gIC8vIElFMTAgMTAgRklYOiBQbGVhc2UsIGRvbid0IGFzaywgdGhlIGVsZW1lbnQgaXNuJ3RcbiAgLy8gY29uc2lkZXJlZCBpbiBET00gaW4gc29tZSBjaXJjdW1zdGFuY2VzLi4uXG4gIC8vIFRoaXMgaXNuJ3QgcmVwcm9kdWNpYmxlIGluIElFMTAgY29tcGF0aWJpbGl0eSBtb2RlIG9mIElFMTFcbiAgdHJ5IHtcbiAgICBpZiAoaXNJRSgxMCkpIHtcbiAgICAgIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICd0b3AnKTtcbiAgICAgIGNvbnN0IHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgICAgIHJlY3QudG9wICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0O1xuICAgICAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH1cbiAgfVxuICBjYXRjaChlKXt9XG5cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICB0b3A6IHJlY3QudG9wLFxuICAgIHdpZHRoOiByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LFxuICAgIGhlaWdodDogcmVjdC5ib3R0b20gLSByZWN0LnRvcCxcbiAgfTtcblxuICAvLyBzdWJ0cmFjdCBzY3JvbGxiYXIgc2l6ZSBmcm9tIHNpemVzXG4gIGNvbnN0IHNpemVzID0gZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnID8gZ2V0V2luZG93U2l6ZXMoZWxlbWVudC5vd25lckRvY3VtZW50KSA6IHt9O1xuICBjb25zdCB3aWR0aCA9XG4gICAgc2l6ZXMud2lkdGggfHwgZWxlbWVudC5jbGllbnRXaWR0aCB8fCByZXN1bHQud2lkdGg7XG4gIGNvbnN0IGhlaWdodCA9XG4gICAgc2l6ZXMuaGVpZ2h0IHx8IGVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IHJlc3VsdC5oZWlnaHQ7XG5cbiAgbGV0IGhvcml6U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRXaWR0aCAtIHdpZHRoO1xuICBsZXQgdmVydFNjcm9sbGJhciA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IC0gaGVpZ2h0O1xuXG4gIC8vIGlmIGFuIGh5cG90aGV0aWNhbCBzY3JvbGxiYXIgaXMgZGV0ZWN0ZWQsIHdlIG11c3QgYmUgc3VyZSBpdCdzIG5vdCBhIGBib3JkZXJgXG4gIC8vIHdlIG1ha2UgdGhpcyBjaGVjayBjb25kaXRpb25hbCBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICBpZiAoaG9yaXpTY3JvbGxiYXIgfHwgdmVydFNjcm9sbGJhcikge1xuICAgIGNvbnN0IHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KTtcbiAgICBob3JpelNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd4Jyk7XG4gICAgdmVydFNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd5Jyk7XG5cbiAgICByZXN1bHQud2lkdGggLT0gaG9yaXpTY3JvbGxiYXI7XG4gICAgcmVzdWx0LmhlaWdodCAtPSB2ZXJ0U2Nyb2xsYmFyO1xuICB9XG5cbiAgcmV0dXJuIGdldENsaWVudFJlY3QocmVzdWx0KTtcbn1cbiIsImltcG9ydCBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkgZnJvbSAnLi9nZXRTdHlsZUNvbXB1dGVkUHJvcGVydHknO1xuaW1wb3J0IGluY2x1ZGVTY3JvbGwgZnJvbSAnLi9pbmNsdWRlU2Nyb2xsJztcbmltcG9ydCBnZXRTY3JvbGxQYXJlbnQgZnJvbSAnLi9nZXRTY3JvbGxQYXJlbnQnO1xuaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tICcuL2dldEJvdW5kaW5nQ2xpZW50UmVjdCc7XG5pbXBvcnQgcnVuSXNJRSBmcm9tICcuL2lzSUUnO1xuaW1wb3J0IGdldENsaWVudFJlY3QgZnJvbSAnLi9nZXRDbGllbnRSZWN0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGNoaWxkcmVuLCBwYXJlbnQsIGZpeGVkUG9zaXRpb24gPSBmYWxzZSkge1xuICBjb25zdCBpc0lFMTAgPSBydW5Jc0lFKDEwKTtcbiAgY29uc3QgaXNIVE1MID0gcGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCc7XG4gIGNvbnN0IGNoaWxkcmVuUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChjaGlsZHJlbik7XG4gIGNvbnN0IHBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocGFyZW50KTtcbiAgY29uc3Qgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGNoaWxkcmVuKTtcblxuICBjb25zdCBzdHlsZXMgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkocGFyZW50KTtcbiAgY29uc3QgYm9yZGVyVG9wV2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJUb3BXaWR0aCwgMTApO1xuICBjb25zdCBib3JkZXJMZWZ0V2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJMZWZ0V2lkdGgsIDEwKTtcblxuICAvLyBJbiBjYXNlcyB3aGVyZSB0aGUgcGFyZW50IGlzIGZpeGVkLCB3ZSBtdXN0IGlnbm9yZSBuZWdhdGl2ZSBzY3JvbGwgaW4gb2Zmc2V0IGNhbGNcbiAgaWYoZml4ZWRQb3NpdGlvbiAmJiBpc0hUTUwpIHtcbiAgICBwYXJlbnRSZWN0LnRvcCA9IE1hdGgubWF4KHBhcmVudFJlY3QudG9wLCAwKTtcbiAgICBwYXJlbnRSZWN0LmxlZnQgPSBNYXRoLm1heChwYXJlbnRSZWN0LmxlZnQsIDApO1xuICB9XG4gIGxldCBvZmZzZXRzID0gZ2V0Q2xpZW50UmVjdCh7XG4gICAgdG9wOiBjaGlsZHJlblJlY3QudG9wIC0gcGFyZW50UmVjdC50b3AgLSBib3JkZXJUb3BXaWR0aCxcbiAgICBsZWZ0OiBjaGlsZHJlblJlY3QubGVmdCAtIHBhcmVudFJlY3QubGVmdCAtIGJvcmRlckxlZnRXaWR0aCxcbiAgICB3aWR0aDogY2hpbGRyZW5SZWN0LndpZHRoLFxuICAgIGhlaWdodDogY2hpbGRyZW5SZWN0LmhlaWdodCxcbiAgfSk7XG4gIG9mZnNldHMubWFyZ2luVG9wID0gMDtcbiAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gMDtcblxuICAvLyBTdWJ0cmFjdCBtYXJnaW5zIG9mIGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGl0J3MgYmVpbmcgdXNlZCBhcyBwYXJlbnRcbiAgLy8gd2UgZG8gdGhpcyBvbmx5IG9uIEhUTUwgYmVjYXVzZSBpdCdzIHRoZSBvbmx5IGVsZW1lbnQgdGhhdCBiZWhhdmVzXG4gIC8vIGRpZmZlcmVudGx5IHdoZW4gbWFyZ2lucyBhcmUgYXBwbGllZCB0byBpdC4gVGhlIG1hcmdpbnMgYXJlIGluY2x1ZGVkIGluXG4gIC8vIHRoZSBib3ggb2YgdGhlIGRvY3VtZW50RWxlbWVudCwgaW4gdGhlIG90aGVyIGNhc2VzIG5vdC5cbiAgaWYgKCFpc0lFMTAgJiYgaXNIVE1MKSB7XG4gICAgY29uc3QgbWFyZ2luVG9wID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wLCAxMCk7XG4gICAgY29uc3QgbWFyZ2luTGVmdCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQsIDEwKTtcblxuICAgIG9mZnNldHMudG9wIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMuYm90dG9tIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubGVmdCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuICAgIG9mZnNldHMucmlnaHQgLT0gYm9yZGVyTGVmdFdpZHRoIC0gbWFyZ2luTGVmdDtcblxuICAgIC8vIEF0dGFjaCBtYXJnaW5Ub3AgYW5kIG1hcmdpbkxlZnQgYmVjYXVzZSBpbiBzb21lIGNpcmN1bXN0YW5jZXMgd2UgbWF5IG5lZWQgdGhlbVxuICAgIG9mZnNldHMubWFyZ2luVG9wID0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubWFyZ2luTGVmdCA9IG1hcmdpbkxlZnQ7XG4gIH1cblxuICBpZiAoXG4gICAgaXNJRTEwICYmICFmaXhlZFBvc2l0aW9uXG4gICAgICA/IHBhcmVudC5jb250YWlucyhzY3JvbGxQYXJlbnQpXG4gICAgICA6IHBhcmVudCA9PT0gc2Nyb2xsUGFyZW50ICYmIHNjcm9sbFBhcmVudC5ub2RlTmFtZSAhPT0gJ0JPRFknXG4gICkge1xuICAgIG9mZnNldHMgPSBpbmNsdWRlU2Nyb2xsKG9mZnNldHMsIHBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn1cbiIsImltcG9ydCBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUgZnJvbSAnLi9nZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUnO1xuaW1wb3J0IGdldFNjcm9sbCBmcm9tICcuL2dldFNjcm9sbCc7XG5pbXBvcnQgZ2V0Q2xpZW50UmVjdCBmcm9tICcuL2dldENsaWVudFJlY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUoZWxlbWVudCwgZXhjbHVkZVNjcm9sbCA9IGZhbHNlKSB7XG4gIGNvbnN0IGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICBjb25zdCByZWxhdGl2ZU9mZnNldCA9IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShlbGVtZW50LCBodG1sKTtcbiAgY29uc3Qgd2lkdGggPSBNYXRoLm1heChodG1sLmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgY29uc3QgaGVpZ2h0ID0gTWF0aC5tYXgoaHRtbC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcblxuICBjb25zdCBzY3JvbGxUb3AgPSAhZXhjbHVkZVNjcm9sbCA/IGdldFNjcm9sbChodG1sKSA6IDA7XG4gIGNvbnN0IHNjcm9sbExlZnQgPSAhZXhjbHVkZVNjcm9sbCA/IGdldFNjcm9sbChodG1sLCAnbGVmdCcpIDogMDtcblxuICBjb25zdCBvZmZzZXQgPSB7XG4gICAgdG9wOiBzY3JvbGxUb3AgLSByZWxhdGl2ZU9mZnNldC50b3AgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5Ub3AsXG4gICAgbGVmdDogc2Nyb2xsTGVmdCAtIHJlbGF0aXZlT2Zmc2V0LmxlZnQgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5MZWZ0LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgfTtcblxuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChvZmZzZXQpO1xufVxuIiwiaW1wb3J0IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eSBmcm9tICcuL2dldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eSc7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tICcuL2dldFBhcmVudE5vZGUnO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGZpeGVkIG9yIGlzIGluc2lkZSBhIGZpeGVkIHBhcmVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGN1c3RvbUNvbnRhaW5lclxuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0byBcImlzRml4ZWQ/XCJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNGaXhlZChlbGVtZW50KSB7XG4gIGNvbnN0IG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsICdwb3NpdGlvbicpID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIGlmICghcGFyZW50Tm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNGaXhlZChwYXJlbnROb2RlKTtcbn1cbiIsImltcG9ydCBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkgZnJvbSAnLi9nZXRTdHlsZUNvbXB1dGVkUHJvcGVydHknO1xuaW1wb3J0IGlzSUUgZnJvbSAnLi9pc0lFJztcbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IHBhcmVudCBvZiBhbiBlbGVtZW50IHRoYXQgaGFzIGEgdHJhbnNmb3JtZWQgcHJvcGVydHkgZGVmaW5lZFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gZmlyc3QgdHJhbnNmb3JtZWQgcGFyZW50IG9yIGRvY3VtZW50RWxlbWVudFxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICAvLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCB0byBhdm9pZCBlcnJvcnMgaW4gY2FzZSBvbmUgb2YgdGhlIGVsZW1lbnRzIGlzbid0IGRlZmluZWQgZm9yIGFueSByZWFzb25cbiAgIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5wYXJlbnRFbGVtZW50IHx8IGlzSUUoKSkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cbiAgbGV0IGVsID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICB3aGlsZSAoZWwgJiYgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsLCAndHJhbnNmb3JtJykgPT09ICdub25lJykge1xuICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcbiAgfVxuICByZXR1cm4gZWwgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG59XG4iLCJpbXBvcnQgZ2V0U2Nyb2xsUGFyZW50IGZyb20gJy4vZ2V0U2Nyb2xsUGFyZW50JztcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gJy4vZ2V0UGFyZW50Tm9kZSc7XG5pbXBvcnQgZ2V0UmVmZXJlbmNlTm9kZSBmcm9tICcuL2dldFJlZmVyZW5jZU5vZGUnO1xuaW1wb3J0IGZpbmRDb21tb25PZmZzZXRQYXJlbnQgZnJvbSAnLi9maW5kQ29tbW9uT2Zmc2V0UGFyZW50JztcbmltcG9ydCBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUgZnJvbSAnLi9nZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUnO1xuaW1wb3J0IGdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZSBmcm9tICcuL2dldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZSc7XG5pbXBvcnQgZ2V0V2luZG93U2l6ZXMgZnJvbSAnLi9nZXRXaW5kb3dTaXplcyc7XG5pbXBvcnQgaXNGaXhlZCBmcm9tICcuL2lzRml4ZWQnO1xuaW1wb3J0IGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQgZnJvbSAnLi9nZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50JztcblxuLyoqXG4gKiBDb21wdXRlZCB0aGUgYm91bmRhcmllcyBsaW1pdHMgYW5kIHJldHVybiB0aGVtXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmdcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50IC0gRWxlbWVudCB1c2VkIHRvIGRlZmluZSB0aGUgYm91bmRhcmllc1xuICogQHBhcmFtIHtCb29sZWFufSBmaXhlZFBvc2l0aW9uIC0gSXMgaW4gZml4ZWQgcG9zaXRpb24gbW9kZVxuICogQHJldHVybnMge09iamVjdH0gQ29vcmRpbmF0ZXMgb2YgdGhlIGJvdW5kYXJpZXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Qm91bmRhcmllcyhcbiAgcG9wcGVyLFxuICByZWZlcmVuY2UsXG4gIHBhZGRpbmcsXG4gIGJvdW5kYXJpZXNFbGVtZW50LFxuICBmaXhlZFBvc2l0aW9uID0gZmFsc2Vcbikge1xuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuXG4gIGxldCBib3VuZGFyaWVzID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgY29uc3Qgb2Zmc2V0UGFyZW50ID0gZml4ZWRQb3NpdGlvbiA/IGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQocG9wcGVyKSA6IGZpbmRDb21tb25PZmZzZXRQYXJlbnQocG9wcGVyLCBnZXRSZWZlcmVuY2VOb2RlKHJlZmVyZW5jZSkpO1xuXG4gIC8vIEhhbmRsZSB2aWV3cG9ydCBjYXNlXG4gIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3ZpZXdwb3J0JyApIHtcbiAgICBib3VuZGFyaWVzID0gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKG9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG4gIH1cblxuICBlbHNlIHtcbiAgICAvLyBIYW5kbGUgb3RoZXIgY2FzZXMgYmFzZWQgb24gRE9NIGVsZW1lbnQgdXNlZCBhcyBib3VuZGFyaWVzXG4gICAgbGV0IGJvdW5kYXJpZXNOb2RlO1xuICAgIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3Njcm9sbFBhcmVudCcpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUocmVmZXJlbmNlKSk7XG4gICAgICBpZiAoYm91bmRhcmllc05vZGUubm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgICAgICBib3VuZGFyaWVzTm9kZSA9IHBvcHBlci5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAnd2luZG93Jykge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBwb3BwZXIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gYm91bmRhcmllc0VsZW1lbnQ7XG4gICAgfVxuXG4gICAgY29uc3Qgb2Zmc2V0cyA9IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShcbiAgICAgIGJvdW5kYXJpZXNOb2RlLFxuICAgICAgb2Zmc2V0UGFyZW50LFxuICAgICAgZml4ZWRQb3NpdGlvblxuICAgICk7XG5cbiAgICAvLyBJbiBjYXNlIG9mIEhUTUwsIHdlIG5lZWQgYSBkaWZmZXJlbnQgY29tcHV0YXRpb25cbiAgICBpZiAoYm91bmRhcmllc05vZGUubm9kZU5hbWUgPT09ICdIVE1MJyAmJiAhaXNGaXhlZChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBjb25zdCB7IGhlaWdodCwgd2lkdGggfSA9IGdldFdpbmRvd1NpemVzKHBvcHBlci5vd25lckRvY3VtZW50KTtcbiAgICAgIGJvdW5kYXJpZXMudG9wICs9IG9mZnNldHMudG9wIC0gb2Zmc2V0cy5tYXJnaW5Ub3A7XG4gICAgICBib3VuZGFyaWVzLmJvdHRvbSA9IGhlaWdodCArIG9mZnNldHMudG9wO1xuICAgICAgYm91bmRhcmllcy5sZWZ0ICs9IG9mZnNldHMubGVmdCAtIG9mZnNldHMubWFyZ2luTGVmdDtcbiAgICAgIGJvdW5kYXJpZXMucmlnaHQgPSB3aWR0aCArIG9mZnNldHMubGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9yIGFsbCB0aGUgb3RoZXIgRE9NIGVsZW1lbnRzLCB0aGlzIG9uZSBpcyBnb29kXG4gICAgICBib3VuZGFyaWVzID0gb2Zmc2V0cztcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgcGFkZGluZ3NcbiAgcGFkZGluZyA9IHBhZGRpbmcgfHwgMDtcbiAgY29uc3QgaXNQYWRkaW5nTnVtYmVyID0gdHlwZW9mIHBhZGRpbmcgPT09ICdudW1iZXInO1xuICBib3VuZGFyaWVzLmxlZnQgKz0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcubGVmdCB8fCAwOyBcbiAgYm91bmRhcmllcy50b3AgKz0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcudG9wIHx8IDA7IFxuICBib3VuZGFyaWVzLnJpZ2h0IC09IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLnJpZ2h0IHx8IDA7IFxuICBib3VuZGFyaWVzLmJvdHRvbSAtPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5ib3R0b20gfHwgMDsgXG5cbiAgcmV0dXJuIGJvdW5kYXJpZXM7XG59XG4iLCJpbXBvcnQgZ2V0Qm91bmRhcmllcyBmcm9tICcuLi91dGlscy9nZXRCb3VuZGFyaWVzJztcblxuZnVuY3Rpb24gZ2V0QXJlYSh7IHdpZHRoLCBoZWlnaHQgfSkge1xuICByZXR1cm4gd2lkdGggKiBoZWlnaHQ7XG59XG5cbi8qKlxuICogVXRpbGl0eSB1c2VkIHRvIHRyYW5zZm9ybSB0aGUgYGF1dG9gIHBsYWNlbWVudCB0byB0aGUgcGxhY2VtZW50IHdpdGggbW9yZVxuICogYXZhaWxhYmxlIHNwYWNlLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoXG4gIHBsYWNlbWVudCxcbiAgcmVmUmVjdCxcbiAgcG9wcGVyLFxuICByZWZlcmVuY2UsXG4gIGJvdW5kYXJpZXNFbGVtZW50LFxuICBwYWRkaW5nID0gMFxuKSB7XG4gIGlmIChwbGFjZW1lbnQuaW5kZXhPZignYXV0bycpID09PSAtMSkge1xuICAgIHJldHVybiBwbGFjZW1lbnQ7XG4gIH1cblxuICBjb25zdCBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhcbiAgICBwb3BwZXIsXG4gICAgcmVmZXJlbmNlLFxuICAgIHBhZGRpbmcsXG4gICAgYm91bmRhcmllc0VsZW1lbnRcbiAgKTtcblxuICBjb25zdCByZWN0cyA9IHtcbiAgICB0b3A6IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWZSZWN0LnRvcCAtIGJvdW5kYXJpZXMudG9wLFxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLnJpZ2h0IC0gcmVmUmVjdC5yaWdodCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5oZWlnaHQsXG4gICAgfSxcbiAgICBib3R0b206IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmJvdHRvbSAtIHJlZlJlY3QuYm90dG9tLFxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgd2lkdGg6IHJlZlJlY3QubGVmdCAtIGJvdW5kYXJpZXMubGVmdCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5oZWlnaHQsXG4gICAgfSxcbiAgfTtcblxuICBjb25zdCBzb3J0ZWRBcmVhcyA9IE9iamVjdC5rZXlzKHJlY3RzKVxuICAgIC5tYXAoa2V5ID0+ICh7XG4gICAgICBrZXksXG4gICAgICAuLi5yZWN0c1trZXldLFxuICAgICAgYXJlYTogZ2V0QXJlYShyZWN0c1trZXldKSxcbiAgICB9KSlcbiAgICAuc29ydCgoYSwgYikgPT4gYi5hcmVhIC0gYS5hcmVhKTtcblxuICBjb25zdCBmaWx0ZXJlZEFyZWFzID0gc29ydGVkQXJlYXMuZmlsdGVyKFxuICAgICh7IHdpZHRoLCBoZWlnaHQgfSkgPT5cbiAgICAgIHdpZHRoID49IHBvcHBlci5jbGllbnRXaWR0aCAmJiBoZWlnaHQgPj0gcG9wcGVyLmNsaWVudEhlaWdodFxuICApO1xuXG4gIGNvbnN0IGNvbXB1dGVkUGxhY2VtZW50ID0gZmlsdGVyZWRBcmVhcy5sZW5ndGggPiAwXG4gICAgPyBmaWx0ZXJlZEFyZWFzWzBdLmtleVxuICAgIDogc29ydGVkQXJlYXNbMF0ua2V5O1xuXG4gIGNvbnN0IHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuXG4gIHJldHVybiBjb21wdXRlZFBsYWNlbWVudCArICh2YXJpYXRpb24gPyBgLSR7dmFyaWF0aW9ufWAgOiAnJyk7XG59XG4iLCJpbXBvcnQgZmluZENvbW1vbk9mZnNldFBhcmVudCBmcm9tICcuL2ZpbmRDb21tb25PZmZzZXRQYXJlbnQnO1xuaW1wb3J0IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZSBmcm9tICcuL2dldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZSc7XG5pbXBvcnQgZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudCBmcm9tICcuL2dldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQnO1xuaW1wb3J0IGdldFJlZmVyZW5jZU5vZGUgZnJvbSAnLi9nZXRSZWZlcmVuY2VOb2RlJztcblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gcmVmZXJlbmNlIC0gdGhlIHJlZmVyZW5jZSBlbGVtZW50ICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEBwYXJhbSB7RWxlbWVudH0gZml4ZWRQb3NpdGlvbiAtIGlzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlLCBmaXhlZFBvc2l0aW9uID0gbnVsbCkge1xuICBjb25zdCBjb21tb25PZmZzZXRQYXJlbnQgPSBmaXhlZFBvc2l0aW9uID8gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChwb3BwZXIpIDogZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIGdldFJlZmVyZW5jZU5vZGUocmVmZXJlbmNlKSk7XG4gIHJldHVybiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUocmVmZXJlbmNlLCBjb21tb25PZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xufVxuIiwiLyoqXG4gKiBHZXQgdGhlIG91dGVyIHNpemVzIG9mIHRoZSBnaXZlbiBlbGVtZW50IChvZmZzZXQgc2l6ZSArIG1hcmdpbnMpXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCBjb250YWluaW5nIHdpZHRoIGFuZCBoZWlnaHQgcHJvcGVydGllc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPdXRlclNpemVzKGVsZW1lbnQpIHtcbiAgY29uc3Qgd2luZG93ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgY29uc3QgeCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCB8fCAwKSArIHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkJvdHRvbSB8fCAwKTtcbiAgY29uc3QgeSA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQgfHwgMCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5SaWdodCB8fCAwKTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoICsgeSxcbiAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgeCxcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsIi8qKlxuICogR2V0IHRoZSBvcHBvc2l0ZSBwbGFjZW1lbnQgb2YgdGhlIGdpdmVuIG9uZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudFxuICogQHJldHVybnMge1N0cmluZ30gZmxpcHBlZCBwbGFjZW1lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIGNvbnN0IGhhc2ggPSB7IGxlZnQ6ICdyaWdodCcsIHJpZ2h0OiAnbGVmdCcsIGJvdHRvbTogJ3RvcCcsIHRvcDogJ2JvdHRvbScgfTtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgbWF0Y2hlZCA9PiBoYXNoW21hdGNoZWRdKTtcbn1cbiIsImltcG9ydCBnZXRPdXRlclNpemVzIGZyb20gJy4vZ2V0T3V0ZXJTaXplcyc7XG5pbXBvcnQgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQgZnJvbSAnLi9nZXRPcHBvc2l0ZVBsYWNlbWVudCc7XG5cbi8qKlxuICogR2V0IG9mZnNldHMgdG8gdGhlIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIC0gQ1NTIHBvc2l0aW9uIHRoZSBQb3BwZXIgd2lsbCBnZXQgYXBwbGllZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gdGhlIHBvcHBlciBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0cyAtIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcGFyYW0ge1N0cmluZ30gcGxhY2VtZW50IC0gb25lIG9mIHRoZSB2YWxpZCBwbGFjZW1lbnQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gcG9wcGVyT2Zmc2V0cyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFBvcHBlck9mZnNldHMocG9wcGVyLCByZWZlcmVuY2VPZmZzZXRzLCBwbGFjZW1lbnQpIHtcbiAgcGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgLy8gR2V0IHBvcHBlciBub2RlIHNpemVzXG4gIGNvbnN0IHBvcHBlclJlY3QgPSBnZXRPdXRlclNpemVzKHBvcHBlcik7XG5cbiAgLy8gQWRkIHBvc2l0aW9uLCB3aWR0aCBhbmQgaGVpZ2h0IHRvIG91ciBvZmZzZXRzIG9iamVjdFxuICBjb25zdCBwb3BwZXJPZmZzZXRzID0ge1xuICAgIHdpZHRoOiBwb3BwZXJSZWN0LndpZHRoLFxuICAgIGhlaWdodDogcG9wcGVyUmVjdC5oZWlnaHQsXG4gIH07XG5cbiAgLy8gZGVwZW5kaW5nIGJ5IHRoZSBwb3BwZXIgcGxhY2VtZW50IHdlIGhhdmUgdG8gY29tcHV0ZSBpdHMgb2Zmc2V0cyBzbGlnaHRseSBkaWZmZXJlbnRseVxuICBjb25zdCBpc0hvcml6ID0gWydyaWdodCcsICdsZWZ0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgY29uc3QgbWFpblNpZGUgPSBpc0hvcml6ID8gJ3RvcCcgOiAnbGVmdCc7XG4gIGNvbnN0IHNlY29uZGFyeVNpZGUgPSBpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCc7XG4gIGNvbnN0IG1lYXN1cmVtZW50ID0gaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgY29uc3Qgc2Vjb25kYXJ5TWVhc3VyZW1lbnQgPSAhaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBwb3BwZXJPZmZzZXRzW21haW5TaWRlXSA9XG4gICAgcmVmZXJlbmNlT2Zmc2V0c1ttYWluU2lkZV0gK1xuICAgIHJlZmVyZW5jZU9mZnNldHNbbWVhc3VyZW1lbnRdIC8gMiAtXG4gICAgcG9wcGVyUmVjdFttZWFzdXJlbWVudF0gLyAyO1xuICBpZiAocGxhY2VtZW50ID09PSBzZWNvbmRhcnlTaWRlKSB7XG4gICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9XG4gICAgICByZWZlcmVuY2VPZmZzZXRzW3NlY29uZGFyeVNpZGVdIC0gcG9wcGVyUmVjdFtzZWNvbmRhcnlNZWFzdXJlbWVudF07XG4gIH0gZWxzZSB7XG4gICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9XG4gICAgICByZWZlcmVuY2VPZmZzZXRzW2dldE9wcG9zaXRlUGxhY2VtZW50KHNlY29uZGFyeVNpZGUpXTtcbiAgfVxuXG4gIHJldHVybiBwb3BwZXJPZmZzZXRzO1xufVxuIiwiLyoqXG4gKiBNaW1pY3MgdGhlIGBmaW5kYCBtZXRob2Qgb2YgQXJyYXlcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICogQGFyZ3VtZW50IHByb3BcbiAqIEBhcmd1bWVudCB2YWx1ZVxuICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmluZChhcnIsIGNoZWNrKSB7XG4gIC8vIHVzZSBuYXRpdmUgZmluZCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kKSB7XG4gICAgcmV0dXJuIGFyci5maW5kKGNoZWNrKTtcbiAgfVxuXG4gIC8vIHVzZSBgZmlsdGVyYCB0byBvYnRhaW4gdGhlIHNhbWUgYmVoYXZpb3Igb2YgYGZpbmRgXG4gIHJldHVybiBhcnIuZmlsdGVyKGNoZWNrKVswXTtcbn1cbiIsImltcG9ydCBmaW5kIGZyb20gJy4vZmluZCc7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hpbmcgb2JqZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FycmF5fSBhcnJcbiAqIEBhcmd1bWVudCBwcm9wXG4gKiBAYXJndW1lbnQgdmFsdWVcbiAqIEByZXR1cm5zIGluZGV4IG9yIC0xXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpbmRJbmRleChhcnIsIHByb3AsIHZhbHVlKSB7XG4gIC8vIHVzZSBuYXRpdmUgZmluZEluZGV4IGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleCkge1xuICAgIHJldHVybiBhcnIuZmluZEluZGV4KGN1ciA9PiBjdXJbcHJvcF0gPT09IHZhbHVlKTtcbiAgfVxuXG4gIC8vIHVzZSBgZmluZGAgKyBgaW5kZXhPZmAgaWYgYGZpbmRJbmRleGAgaXNuJ3Qgc3VwcG9ydGVkXG4gIGNvbnN0IG1hdGNoID0gZmluZChhcnIsIG9iaiA9PiBvYmpbcHJvcF0gPT09IHZhbHVlKTtcbiAgcmV0dXJuIGFyci5pbmRleE9mKG1hdGNoKTtcbn1cbiIsImltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4vaXNGdW5jdGlvbic7XG5pbXBvcnQgZmluZEluZGV4IGZyb20gJy4vZmluZEluZGV4JztcbmltcG9ydCBnZXRDbGllbnRSZWN0IGZyb20gJy4uL3V0aWxzL2dldENsaWVudFJlY3QnO1xuXG4vKipcbiAqIExvb3AgdHJvdWdoIHRoZSBsaXN0IG9mIG1vZGlmaWVycyBhbmQgcnVuIHRoZW0gaW4gb3JkZXIsXG4gKiBlYWNoIG9mIHRoZW0gd2lsbCB0aGVuIGVkaXQgdGhlIGRhdGEgb2JqZWN0LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmRzIC0gT3B0aW9uYWwgbW9kaWZpZXIgbmFtZSB1c2VkIGFzIHN0b3BwZXJcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBydW5Nb2RpZmllcnMobW9kaWZpZXJzLCBkYXRhLCBlbmRzKSB7XG4gIGNvbnN0IG1vZGlmaWVyc1RvUnVuID0gZW5kcyA9PT0gdW5kZWZpbmVkXG4gICAgPyBtb2RpZmllcnNcbiAgICA6IG1vZGlmaWVycy5zbGljZSgwLCBmaW5kSW5kZXgobW9kaWZpZXJzLCAnbmFtZScsIGVuZHMpKTtcblxuICBtb2RpZmllcnNUb1J1bi5mb3JFYWNoKG1vZGlmaWVyID0+IHtcbiAgICBpZiAobW9kaWZpZXJbJ2Z1bmN0aW9uJ10pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgIGNvbnNvbGUud2FybignYG1vZGlmaWVyLmZ1bmN0aW9uYCBpcyBkZXByZWNhdGVkLCB1c2UgYG1vZGlmaWVyLmZuYCEnKTtcbiAgICB9XG4gICAgY29uc3QgZm4gPSBtb2RpZmllclsnZnVuY3Rpb24nXSB8fCBtb2RpZmllci5mbjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICBpZiAobW9kaWZpZXIuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgLy8gQWRkIHByb3BlcnRpZXMgdG8gb2Zmc2V0cyB0byBtYWtlIHRoZW0gYSBjb21wbGV0ZSBjbGllbnRSZWN0IG9iamVjdFxuICAgICAgLy8gd2UgZG8gdGhpcyBiZWZvcmUgZWFjaCBtb2RpZmllciB0byBtYWtlIHN1cmUgdGhlIHByZXZpb3VzIG9uZSBkb2Vzbid0XG4gICAgICAvLyBtZXNzIHdpdGggdGhlc2UgdmFsdWVzXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcbiAgICAgIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UpO1xuXG4gICAgICBkYXRhID0gZm4oZGF0YSwgbW9kaWZpZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG4iLCJpbXBvcnQgY29tcHV0ZUF1dG9QbGFjZW1lbnQgZnJvbSAnLi4vdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQnO1xuaW1wb3J0IGdldFJlZmVyZW5jZU9mZnNldHMgZnJvbSAnLi4vdXRpbHMvZ2V0UmVmZXJlbmNlT2Zmc2V0cyc7XG5pbXBvcnQgZ2V0UG9wcGVyT2Zmc2V0cyBmcm9tICcuLi91dGlscy9nZXRQb3BwZXJPZmZzZXRzJztcbmltcG9ydCBydW5Nb2RpZmllcnMgZnJvbSAnLi4vdXRpbHMvcnVuTW9kaWZpZXJzJztcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyLCBjb21wdXRpbmcgdGhlIG5ldyBvZmZzZXRzIGFuZCBhcHBseWluZ1xuICogdGhlIG5ldyBzdHlsZS48YnIgLz5cbiAqIFByZWZlciBgc2NoZWR1bGVVcGRhdGVgIG92ZXIgYHVwZGF0ZWAgYmVjYXVzZSBvZiBwZXJmb3JtYW5jZSByZWFzb25zLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gIC8vIGlmIHBvcHBlciBpcyBkZXN0cm95ZWQsIGRvbid0IHBlcmZvcm0gYW55IGZ1cnRoZXIgdXBkYXRlXG4gIGlmICh0aGlzLnN0YXRlLmlzRGVzdHJveWVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGRhdGEgPSB7XG4gICAgaW5zdGFuY2U6IHRoaXMsXG4gICAgc3R5bGVzOiB7fSxcbiAgICBhcnJvd1N0eWxlczoge30sXG4gICAgYXR0cmlidXRlczoge30sXG4gICAgZmxpcHBlZDogZmFsc2UsXG4gICAgb2Zmc2V0czoge30sXG4gIH07XG5cbiAgLy8gY29tcHV0ZSByZWZlcmVuY2UgZWxlbWVudCBvZmZzZXRzXG4gIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgPSBnZXRSZWZlcmVuY2VPZmZzZXRzKFxuICAgIHRoaXMuc3RhdGUsXG4gICAgdGhpcy5wb3BwZXIsXG4gICAgdGhpcy5yZWZlcmVuY2UsXG4gICAgdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWRcbiAgKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgZGF0YS5wbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudChcbiAgICB0aGlzLm9wdGlvbnMucGxhY2VtZW50LFxuICAgIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsXG4gICAgdGhpcy5wb3BwZXIsXG4gICAgdGhpcy5yZWZlcmVuY2UsXG4gICAgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LFxuICAgIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nXG4gICk7XG5cbiAgLy8gc3RvcmUgdGhlIGNvbXB1dGVkIHBsYWNlbWVudCBpbnNpZGUgYG9yaWdpbmFsUGxhY2VtZW50YFxuICBkYXRhLm9yaWdpbmFsUGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG5cbiAgZGF0YS5wb3NpdGlvbkZpeGVkID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWQ7XG5cbiAgLy8gY29tcHV0ZSB0aGUgcG9wcGVyIG9mZnNldHNcbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldFBvcHBlck9mZnNldHMoXG4gICAgdGhpcy5wb3BwZXIsXG4gICAgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSxcbiAgICBkYXRhLnBsYWNlbWVudFxuICApO1xuXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIucG9zaXRpb24gPSB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZFxuICAgID8gJ2ZpeGVkJ1xuICAgIDogJ2Fic29sdXRlJztcblxuICAvLyBydW4gdGhlIG1vZGlmaWVyc1xuICBkYXRhID0gcnVuTW9kaWZpZXJzKHRoaXMubW9kaWZpZXJzLCBkYXRhKTtcblxuICAvLyB0aGUgZmlyc3QgYHVwZGF0ZWAgd2lsbCBjYWxsIGBvbkNyZWF0ZWAgY2FsbGJhY2tcbiAgLy8gdGhlIG90aGVyIG9uZXMgd2lsbCBjYWxsIGBvblVwZGF0ZWAgY2FsbGJhY2tcbiAgaWYgKCF0aGlzLnN0YXRlLmlzQ3JlYXRlZCkge1xuICAgIHRoaXMuc3RhdGUuaXNDcmVhdGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMub25DcmVhdGUoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcHRpb25zLm9uVXBkYXRlKGRhdGEpO1xuICB9XG59XG4iLCIvKipcbiAqIEhlbHBlciB1c2VkIHRvIGtub3cgaWYgdGhlIGdpdmVuIG1vZGlmaWVyIGlzIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNNb2RpZmllckVuYWJsZWQobW9kaWZpZXJzLCBtb2RpZmllck5hbWUpIHtcbiAgcmV0dXJuIG1vZGlmaWVycy5zb21lKFxuICAgICh7IG5hbWUsIGVuYWJsZWQgfSkgPT4gZW5hYmxlZCAmJiBuYW1lID09PSBtb2RpZmllck5hbWVcbiAgKTtcbn1cbiIsIi8qKlxuICogR2V0IHRoZSBwcmVmaXhlZCBzdXBwb3J0ZWQgcHJvcGVydHkgbmFtZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5IChjYW1lbENhc2UpXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBwcmVmaXhlZCBwcm9wZXJ0eSAoY2FtZWxDYXNlIG9yIFBhc2NhbENhc2UsIGRlcGVuZGluZyBvbiB0aGUgdmVuZG9yIHByZWZpeClcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKHByb3BlcnR5KSB7XG4gIGNvbnN0IHByZWZpeGVzID0gW2ZhbHNlLCAnbXMnLCAnV2Via2l0JywgJ01veicsICdPJ107XG4gIGNvbnN0IHVwcGVyUHJvcCA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHByZWZpeCA9IHByZWZpeGVzW2ldO1xuICAgIGNvbnN0IHRvQ2hlY2sgPSBwcmVmaXggPyBgJHtwcmVmaXh9JHt1cHBlclByb3B9YCA6IHByb3BlcnR5O1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuYm9keS5zdHlsZVt0b0NoZWNrXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0b0NoZWNrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbiIsImltcG9ydCBpc01vZGlmaWVyRW5hYmxlZCBmcm9tICcuLi91dGlscy9pc01vZGlmaWVyRW5hYmxlZCc7XG5pbXBvcnQgZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lIGZyb20gJy4uL3V0aWxzL2dldFN1cHBvcnRlZFByb3BlcnR5TmFtZSc7XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIHBvcHBlci5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgdGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCA9IHRydWU7XG5cbiAgLy8gdG91Y2ggRE9NIG9ubHkgaWYgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGlzIGVuYWJsZWRcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKHRoaXMubW9kaWZpZXJzLCAnYXBwbHlTdHlsZScpKSB7XG4gICAgdGhpcy5wb3BwZXIucmVtb3ZlQXR0cmlidXRlKCd4LXBsYWNlbWVudCcpO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnBvc2l0aW9uID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUudG9wID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUubGVmdCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUuYm90dG9tID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlW2dldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyldID0gJyc7XG4gIH1cblxuICB0aGlzLmRpc2FibGVFdmVudExpc3RlbmVycygpO1xuXG4gIC8vIHJlbW92ZSB0aGUgcG9wcGVyIGlmIHVzZXIgZXhwbGljaXRseSBhc2tlZCBmb3IgdGhlIGRlbGV0aW9uIG9uIGRlc3Ryb3lcbiAgLy8gZG8gbm90IHVzZSBgcmVtb3ZlYCBiZWNhdXNlIElFMTEgZG9lc24ndCBzdXBwb3J0IGl0XG4gIGlmICh0aGlzLm9wdGlvbnMucmVtb3ZlT25EZXN0cm95KSB7XG4gICAgdGhpcy5wb3BwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHBlcik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCIvKipcbiAqIEdldCB0aGUgd2luZG93IGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudFxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7V2luZG93fVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3coZWxlbWVudCkge1xuICBjb25zdCBvd25lckRvY3VtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICByZXR1cm4gb3duZXJEb2N1bWVudCA/IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiB3aW5kb3c7XG59XG4iLCJpbXBvcnQgZ2V0U2Nyb2xsUGFyZW50IGZyb20gJy4vZ2V0U2Nyb2xsUGFyZW50JztcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSAnLi9nZXRXaW5kb3cnO1xuXG5mdW5jdGlvbiBhdHRhY2hUb1Njcm9sbFBhcmVudHMoc2Nyb2xsUGFyZW50LCBldmVudCwgY2FsbGJhY2ssIHNjcm9sbFBhcmVudHMpIHtcbiAgY29uc3QgaXNCb2R5ID0gc2Nyb2xsUGFyZW50Lm5vZGVOYW1lID09PSAnQk9EWSc7XG4gIGNvbnN0IHRhcmdldCA9IGlzQm9keSA/IHNjcm9sbFBhcmVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogc2Nyb2xsUGFyZW50O1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2ssIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICBpZiAoIWlzQm9keSkge1xuICAgIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhcbiAgICAgIGdldFNjcm9sbFBhcmVudCh0YXJnZXQucGFyZW50Tm9kZSksXG4gICAgICBldmVudCxcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgc2Nyb2xsUGFyZW50c1xuICAgICk7XG4gIH1cbiAgc2Nyb2xsUGFyZW50cy5wdXNoKHRhcmdldCk7XG59XG5cbi8qKlxuICogU2V0dXAgbmVlZGVkIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXR1cEV2ZW50TGlzdGVuZXJzKFxuICByZWZlcmVuY2UsXG4gIG9wdGlvbnMsXG4gIHN0YXRlLFxuICB1cGRhdGVCb3VuZFxuKSB7XG4gIC8vIFJlc2l6ZSBldmVudCBsaXN0ZW5lciBvbiB3aW5kb3dcbiAgc3RhdGUudXBkYXRlQm91bmQgPSB1cGRhdGVCb3VuZDtcbiAgZ2V0V2luZG93KHJlZmVyZW5jZSkuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc3RhdGUudXBkYXRlQm91bmQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICAvLyBTY3JvbGwgZXZlbnQgbGlzdGVuZXIgb24gc2Nyb2xsIHBhcmVudHNcbiAgY29uc3Qgc2Nyb2xsRWxlbWVudCA9IGdldFNjcm9sbFBhcmVudChyZWZlcmVuY2UpO1xuICBhdHRhY2hUb1Njcm9sbFBhcmVudHMoXG4gICAgc2Nyb2xsRWxlbWVudCxcbiAgICAnc2Nyb2xsJyxcbiAgICBzdGF0ZS51cGRhdGVCb3VuZCxcbiAgICBzdGF0ZS5zY3JvbGxQYXJlbnRzXG4gICk7XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBzY3JvbGxFbGVtZW50O1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gdHJ1ZTtcblxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgc2V0dXBFdmVudExpc3RlbmVycyBmcm9tICcuLi91dGlscy9zZXR1cEV2ZW50TGlzdGVuZXJzJztcblxuLyoqXG4gKiBJdCB3aWxsIGFkZCByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgc3RhcnQgcmVjYWxjdWxhdGluZ1xuICogcG9zaXRpb24gb2YgdGhlIHBvcHBlciBlbGVtZW50IHdoZW4gdGhleSBhcmUgdHJpZ2dlcmVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBlbmFibGVFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKCF0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICB0aGlzLnN0YXRlID0gc2V0dXBFdmVudExpc3RlbmVycyhcbiAgICAgIHRoaXMucmVmZXJlbmNlLFxuICAgICAgdGhpcy5vcHRpb25zLFxuICAgICAgdGhpcy5zdGF0ZSxcbiAgICAgIHRoaXMuc2NoZWR1bGVVcGRhdGVcbiAgICApO1xuICB9XG59XG4iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gJy4vZ2V0V2luZG93JztcblxuLyoqXG4gKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3BwZXIgcG9zaXRpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHJlZmVyZW5jZSwgc3RhdGUpIHtcbiAgLy8gUmVtb3ZlIHJlc2l6ZSBldmVudCBsaXN0ZW5lciBvbiB3aW5kb3dcbiAgZ2V0V2luZG93KHJlZmVyZW5jZSkucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc3RhdGUudXBkYXRlQm91bmQpO1xuXG4gIC8vIFJlbW92ZSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIgb24gc2Nyb2xsIHBhcmVudHNcbiAgc3RhdGUuc2Nyb2xsUGFyZW50cy5mb3JFYWNoKHRhcmdldCA9PiB7XG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcbiAgfSk7XG5cbiAgLy8gUmVzZXQgc3RhdGVcbiAgc3RhdGUudXBkYXRlQm91bmQgPSBudWxsO1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0gW107XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBudWxsO1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gZmFsc2U7XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCByZW1vdmVFdmVudExpc3RlbmVycyBmcm9tICcuLi91dGlscy9yZW1vdmVFdmVudExpc3RlbmVycyc7XG5cbi8qKlxuICogSXQgd2lsbCByZW1vdmUgcmVzaXplL3Njcm9sbCBldmVudHMgYW5kIHdvbid0IHJlY2FsY3VsYXRlIHBvcHBlciBwb3NpdGlvblxuICogd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuIEl0IGFsc28gd29uJ3QgdHJpZ2dlciBgb25VcGRhdGVgIGNhbGxiYWNrIGFueW1vcmUsXG4gKiB1bmxlc3MgeW91IGNhbGwgYHVwZGF0ZWAgbWV0aG9kIG1hbnVhbGx5LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICh0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnNjaGVkdWxlVXBkYXRlKTtcbiAgICB0aGlzLnN0YXRlID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy5yZWZlcmVuY2UsIHRoaXMuc3RhdGUpO1xuICB9XG59XG4iLCIvKipcbiAqIFRlbGxzIGlmIGEgZ2l2ZW4gaW5wdXQgaXMgYSBudW1iZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7Kn0gaW5wdXQgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzTnVtZXJpYyhuKSB7XG4gIHJldHVybiBuICE9PSAnJyAmJiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG59XG4iLCJpbXBvcnQgaXNOdW1lcmljIGZyb20gJy4vaXNOdW1lcmljJztcblxuLyoqXG4gKiBTZXQgdGhlIHN0eWxlIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIHN0eWxlIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXRTdHlsZXMoZWxlbWVudCwgc3R5bGVzKSB7XG4gIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChwcm9wID0+IHtcbiAgICBsZXQgdW5pdCA9ICcnO1xuICAgIC8vIGFkZCB1bml0IGlmIHRoZSB2YWx1ZSBpcyBudW1lcmljIGFuZCBpcyBvbmUgb2YgdGhlIGZvbGxvd2luZ1xuICAgIGlmIChcbiAgICAgIFsnd2lkdGgnLCAnaGVpZ2h0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLmluZGV4T2YocHJvcCkgIT09XG4gICAgICAgIC0xICYmXG4gICAgICBpc051bWVyaWMoc3R5bGVzW3Byb3BdKVxuICAgICkge1xuICAgICAgdW5pdCA9ICdweCc7XG4gICAgfVxuICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBzdHlsZXNbcHJvcF0gKyB1bml0O1xuICB9KTtcbn1cbiIsIi8qKlxuICogU2V0IHRoZSBhdHRyaWJ1dGVzIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIGF0dHJpYnV0ZXMgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoZWxlbWVudCwgYXR0cmlidXRlcykge1xuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF0dHJpYnV0ZXNbcHJvcF07XG4gICAgaWYgKHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUocHJvcCwgYXR0cmlidXRlc1twcm9wXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuICAgIH1cbiAgfSk7XG59XG4iLCJpbXBvcnQgc2V0U3R5bGVzIGZyb20gJy4uL3V0aWxzL3NldFN0eWxlcyc7XG5pbXBvcnQgc2V0QXR0cmlidXRlcyBmcm9tICcuLi91dGlscy9zZXRBdHRyaWJ1dGVzJztcbmltcG9ydCBnZXRSZWZlcmVuY2VPZmZzZXRzIGZyb20gJy4uL3V0aWxzL2dldFJlZmVyZW5jZU9mZnNldHMnO1xuaW1wb3J0IGNvbXB1dGVBdXRvUGxhY2VtZW50IGZyb20gJy4uL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50JztcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLnN0eWxlcyAtIExpc3Qgb2Ygc3R5bGUgcHJvcGVydGllcyAtIHZhbHVlcyB0byBhcHBseSB0byBwb3BwZXIgZWxlbWVudFxuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEuYXR0cmlidXRlcyAtIExpc3Qgb2YgYXR0cmlidXRlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBzYW1lIGRhdGEgb2JqZWN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFwcGx5U3R5bGUoZGF0YSkge1xuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5zdHlsZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyBpbiB0aGlzIHdheSB3ZSBjYW4gbWFrZSB0aGUgM3JkIHBhcnR5IG1vZGlmaWVycyBhZGQgY3VzdG9tIHN0eWxlcyB0byBpdFxuICAvLyBCZSBhd2FyZSwgbW9kaWZpZXJzIGNvdWxkIG92ZXJyaWRlIHRoZSBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gdGhlIHByZXZpb3VzXG4gIC8vIGxpbmVzIG9mIHRoaXMgbW9kaWZpZXIhXG4gIHNldFN0eWxlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5zdHlsZXMpO1xuXG4gIC8vIGFueSBwcm9wZXJ0eSBwcmVzZW50IGluIGBkYXRhLmF0dHJpYnV0ZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyB0aGV5IHdpbGwgYmUgc2V0IGFzIEhUTUwgYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudFxuICBzZXRBdHRyaWJ1dGVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmF0dHJpYnV0ZXMpO1xuXG4gIC8vIGlmIGFycm93RWxlbWVudCBpcyBkZWZpbmVkIGFuZCBhcnJvd1N0eWxlcyBoYXMgc29tZSBwcm9wZXJ0aWVzXG4gIGlmIChkYXRhLmFycm93RWxlbWVudCAmJiBPYmplY3Qua2V5cyhkYXRhLmFycm93U3R5bGVzKS5sZW5ndGgpIHtcbiAgICBzZXRTdHlsZXMoZGF0YS5hcnJvd0VsZW1lbnQsIGRhdGEuYXJyb3dTdHlsZXMpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogU2V0IHRoZSB4LXBsYWNlbWVudCBhdHRyaWJ1dGUgYmVmb3JlIGV2ZXJ5dGhpbmcgZWxzZSBiZWNhdXNlIGl0IGNvdWxkIGJlIHVzZWRcbiAqIHRvIGFkZCBtYXJnaW5zIHRvIHRoZSBwb3BwZXIgbWFyZ2lucyBuZWVkcyB0byBiZSBjYWxjdWxhdGVkIHRvIGdldCB0aGVcbiAqIGNvcnJlY3QgcG9wcGVyIG9mZnNldHMuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLm1vZGlmaWVyc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBlbGVtZW50IHVzZWQgdG8gcG9zaXRpb24gdGhlIHBvcHBlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gVGhlIEhUTUwgZWxlbWVudCB1c2VkIGFzIHBvcHBlclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBQb3BwZXIuanMgb3B0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlTdHlsZU9uTG9hZChcbiAgcmVmZXJlbmNlLFxuICBwb3BwZXIsXG4gIG9wdGlvbnMsXG4gIG1vZGlmaWVyT3B0aW9ucyxcbiAgc3RhdGVcbikge1xuICAvLyBjb21wdXRlIHJlZmVyZW5jZSBlbGVtZW50IG9mZnNldHNcbiAgY29uc3QgcmVmZXJlbmNlT2Zmc2V0cyA9IGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlLCBvcHRpb25zLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIGNvbXB1dGUgYXV0byBwbGFjZW1lbnQsIHN0b3JlIHBsYWNlbWVudCBpbnNpZGUgdGhlIGRhdGEgb2JqZWN0LFxuICAvLyBtb2RpZmllcnMgd2lsbCBiZSBhYmxlIHRvIGVkaXQgYHBsYWNlbWVudGAgaWYgbmVlZGVkXG4gIC8vIGFuZCByZWZlciB0byBvcmlnaW5hbFBsYWNlbWVudCB0byBrbm93IHRoZSBvcmlnaW5hbCB2YWx1ZVxuICBjb25zdCBwbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudChcbiAgICBvcHRpb25zLnBsYWNlbWVudCxcbiAgICByZWZlcmVuY2VPZmZzZXRzLFxuICAgIHBvcHBlcixcbiAgICByZWZlcmVuY2UsXG4gICAgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCxcbiAgICBvcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmdcbiAgKTtcblxuICBwb3BwZXIuc2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcsIHBsYWNlbWVudCk7XG5cbiAgLy8gQXBwbHkgYHBvc2l0aW9uYCB0byBwb3BwZXIgYmVmb3JlIGFueXRoaW5nIGVsc2UgYmVjYXVzZVxuICAvLyB3aXRob3V0IHRoZSBwb3NpdGlvbiBhcHBsaWVkIHdlIGNhbid0IGd1YXJhbnRlZSBjb3JyZWN0IGNvbXB1dGF0aW9uc1xuICBzZXRTdHlsZXMocG9wcGVyLCB7IHBvc2l0aW9uOiBvcHRpb25zLnBvc2l0aW9uRml4ZWQgPyAnZml4ZWQnIDogJ2Fic29sdXRlJyB9KTtcblxuICByZXR1cm4gb3B0aW9ucztcbn1cbiIsIi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge0Jvb2xlYW59IHNob3VsZFJvdW5kIC0gSWYgdGhlIG9mZnNldHMgc2hvdWxkIGJlIHJvdW5kZWQgYXQgYWxsXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcG9wcGVyJ3MgcG9zaXRpb24gb2Zmc2V0cyByb3VuZGVkXG4gKlxuICogVGhlIHRhbGUgb2YgcGl4ZWwtcGVyZmVjdCBwb3NpdGlvbmluZy4gSXQncyBzdGlsbCBub3QgMTAwJSBwZXJmZWN0LCBidXQgYXNcbiAqIGdvb2QgYXMgaXQgY2FuIGJlIHdpdGhpbiByZWFzb24uXG4gKiBEaXNjdXNzaW9uIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9GZXpWcmFzdGEvcG9wcGVyLmpzL3B1bGwvNzE1XG4gKlxuICogTG93IERQSSBzY3JlZW5zIGNhdXNlIGEgcG9wcGVyIHRvIGJlIGJsdXJyeSBpZiBub3QgdXNpbmcgZnVsbCBwaXhlbHMgKFNhZmFyaVxuICogYXMgd2VsbCBvbiBIaWdoIERQSSBzY3JlZW5zKS5cbiAqXG4gKiBGaXJlZm94IHByZWZlcnMgbm8gcm91bmRpbmcgZm9yIHBvc2l0aW9uaW5nIGFuZCBkb2VzIG5vdCBoYXZlIGJsdXJyaW5lc3Mgb25cbiAqIGhpZ2ggRFBJIHNjcmVlbnMuXG4gKlxuICogT25seSBob3Jpem9udGFsIHBsYWNlbWVudCBhbmQgbGVmdC9yaWdodCB2YWx1ZXMgbmVlZCB0byBiZSBjb25zaWRlcmVkLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRSb3VuZGVkT2Zmc2V0cyhkYXRhLCBzaG91bGRSb3VuZCkge1xuICBjb25zdCB7IHBvcHBlciwgcmVmZXJlbmNlIH0gPSBkYXRhLm9mZnNldHM7XG4gIGNvbnN0IHsgcm91bmQsIGZsb29yIH0gPSBNYXRoO1xuICBjb25zdCBub1JvdW5kID0gdiA9PiB2O1xuICBcbiAgY29uc3QgcmVmZXJlbmNlV2lkdGggPSByb3VuZChyZWZlcmVuY2Uud2lkdGgpO1xuICBjb25zdCBwb3BwZXJXaWR0aCA9IHJvdW5kKHBvcHBlci53aWR0aCk7XG4gIFxuICBjb25zdCBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihkYXRhLnBsYWNlbWVudCkgIT09IC0xO1xuICBjb25zdCBpc1ZhcmlhdGlvbiA9IGRhdGEucGxhY2VtZW50LmluZGV4T2YoJy0nKSAhPT0gLTE7XG4gIGNvbnN0IHNhbWVXaWR0aFBhcml0eSA9IHJlZmVyZW5jZVdpZHRoICUgMiA9PT0gcG9wcGVyV2lkdGggJSAyO1xuICBjb25zdCBib3RoT2RkV2lkdGggPSByZWZlcmVuY2VXaWR0aCAlIDIgPT09IDEgJiYgcG9wcGVyV2lkdGggJSAyID09PSAxO1xuXG4gIGNvbnN0IGhvcml6b250YWxUb0ludGVnZXIgPSAhc2hvdWxkUm91bmRcbiAgICA/IG5vUm91bmRcbiAgICA6IGlzVmVydGljYWwgfHwgaXNWYXJpYXRpb24gfHwgc2FtZVdpZHRoUGFyaXR5XG4gICAgPyByb3VuZFxuICAgIDogZmxvb3I7XG4gIGNvbnN0IHZlcnRpY2FsVG9JbnRlZ2VyID0gIXNob3VsZFJvdW5kID8gbm9Sb3VuZCA6IHJvdW5kO1xuXG4gIHJldHVybiB7XG4gICAgbGVmdDogaG9yaXpvbnRhbFRvSW50ZWdlcihcbiAgICAgIGJvdGhPZGRXaWR0aCAmJiAhaXNWYXJpYXRpb24gJiYgc2hvdWxkUm91bmRcbiAgICAgICAgPyBwb3BwZXIubGVmdCAtIDFcbiAgICAgICAgOiBwb3BwZXIubGVmdFxuICAgICksXG4gICAgdG9wOiB2ZXJ0aWNhbFRvSW50ZWdlcihwb3BwZXIudG9wKSxcbiAgICBib3R0b206IHZlcnRpY2FsVG9JbnRlZ2VyKHBvcHBlci5ib3R0b20pLFxuICAgIHJpZ2h0OiBob3Jpem9udGFsVG9JbnRlZ2VyKHBvcHBlci5yaWdodCksXG4gIH07XG59XG4iLCJpbXBvcnQgZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lIGZyb20gJy4uL3V0aWxzL2dldFN1cHBvcnRlZFByb3BlcnR5TmFtZSc7XG5pbXBvcnQgZmluZCBmcm9tICcuLi91dGlscy9maW5kJztcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSAnLi4vdXRpbHMvZ2V0T2Zmc2V0UGFyZW50JztcbmltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSAnLi4vdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0JztcbmltcG9ydCBnZXRSb3VuZGVkT2Zmc2V0cyBmcm9tICcuLi91dGlscy9nZXRSb3VuZGVkT2Zmc2V0cyc7XG5pbXBvcnQgaXNCcm93c2VyIGZyb20gJy4uL3V0aWxzL2lzQnJvd3Nlcic7XG5cbmNvbnN0IGlzRmlyZWZveCA9IGlzQnJvd3NlciAmJiAvRmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVTdHlsZShkYXRhLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgeCwgeSB9ID0gb3B0aW9ucztcbiAgY29uc3QgeyBwb3BwZXIgfSA9IGRhdGEub2Zmc2V0cztcblxuICAvLyBSZW1vdmUgdGhpcyBsZWdhY3kgc3VwcG9ydCBpbiBQb3BwZXIuanMgdjJcbiAgY29uc3QgbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uID0gZmluZChcbiAgICBkYXRhLmluc3RhbmNlLm1vZGlmaWVycyxcbiAgICBtb2RpZmllciA9PiBtb2RpZmllci5uYW1lID09PSAnYXBwbHlTdHlsZSdcbiAgKS5ncHVBY2NlbGVyYXRpb247XG4gIGlmIChsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdXQVJOSU5HOiBgZ3B1QWNjZWxlcmF0aW9uYCBvcHRpb24gbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXIgYW5kIHdpbGwgbm90IGJlIHN1cHBvcnRlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgUG9wcGVyLmpzISdcbiAgICApO1xuICB9XG4gIGNvbnN0IGdwdUFjY2VsZXJhdGlvbiA9XG4gICAgbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uICE9PSB1bmRlZmluZWRcbiAgICAgID8gbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uXG4gICAgICA6IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uO1xuXG4gIGNvbnN0IG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG4gIGNvbnN0IG9mZnNldFBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50KTtcblxuICAvLyBTdHlsZXNcbiAgY29uc3Qgc3R5bGVzID0ge1xuICAgIHBvc2l0aW9uOiBwb3BwZXIucG9zaXRpb24sXG4gIH07XG5cbiAgY29uc3Qgb2Zmc2V0cyA9IGdldFJvdW5kZWRPZmZzZXRzKFxuICAgIGRhdGEsXG4gICAgd2luZG93LmRldmljZVBpeGVsUmF0aW8gPCAyIHx8ICFpc0ZpcmVmb3hcbiAgKTtcblxuICBjb25zdCBzaWRlQSA9IHggPT09ICdib3R0b20nID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgY29uc3Qgc2lkZUIgPSB5ID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcblxuICAvLyBpZiBncHVBY2NlbGVyYXRpb24gaXMgc2V0IHRvIGB0cnVlYCBhbmQgdHJhbnNmb3JtIGlzIHN1cHBvcnRlZCxcbiAgLy8gIHdlIHVzZSBgdHJhbnNsYXRlM2RgIHRvIGFwcGx5IHRoZSBwb3NpdGlvbiB0byB0aGUgcG9wcGVyIHdlXG4gIC8vIGF1dG9tYXRpY2FsbHkgdXNlIHRoZSBzdXBwb3J0ZWQgcHJlZml4ZWQgdmVyc2lvbiBpZiBuZWVkZWRcbiAgY29uc3QgcHJlZml4ZWRQcm9wZXJ0eSA9IGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyk7XG5cbiAgLy8gbm93LCBsZXQncyBtYWtlIGEgc3RlcCBiYWNrIGFuZCBsb29rIGF0IHRoaXMgY29kZSBjbG9zZWx5ICh3dGY/KVxuICAvLyBJZiB0aGUgY29udGVudCBvZiB0aGUgcG9wcGVyIGdyb3dzIG9uY2UgaXQncyBiZWVuIHBvc2l0aW9uZWQsIGl0XG4gIC8vIG1heSBoYXBwZW4gdGhhdCB0aGUgcG9wcGVyIGdldHMgbWlzcGxhY2VkIGJlY2F1c2Ugb2YgdGhlIG5ldyBjb250ZW50XG4gIC8vIG92ZXJmbG93aW5nIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUbyBhdm9pZCB0aGlzIHByb2JsZW0sIHdlIHByb3ZpZGUgdHdvIG9wdGlvbnMgKHggYW5kIHkpLCB3aGljaCBhbGxvd1xuICAvLyB0aGUgY29uc3VtZXIgdG8gZGVmaW5lIHRoZSBvZmZzZXQgb3JpZ2luLlxuICAvLyBJZiB3ZSBwb3NpdGlvbiBhIHBvcHBlciBvbiB0b3Agb2YgYSByZWZlcmVuY2UgZWxlbWVudCwgd2UgY2FuIHNldFxuICAvLyBgeGAgdG8gYHRvcGAgdG8gbWFrZSB0aGUgcG9wcGVyIGdyb3cgdG93YXJkcyBpdHMgdG9wIGluc3RlYWQgb2ZcbiAgLy8gaXRzIGJvdHRvbS5cbiAgbGV0IGxlZnQsIHRvcDtcbiAgaWYgKHNpZGVBID09PSAnYm90dG9tJykge1xuICAgIC8vIHdoZW4gb2Zmc2V0UGFyZW50IGlzIDxodG1sPiB0aGUgcG9zaXRpb25pbmcgaXMgcmVsYXRpdmUgdG8gdGhlIGJvdHRvbSBvZiB0aGUgc2NyZWVuIChleGNsdWRpbmcgdGhlIHNjcm9sbGJhcilcbiAgICAvLyBhbmQgbm90IHRoZSBib3R0b20gb2YgdGhlIGh0bWwgZWxlbWVudFxuICAgIGlmIChvZmZzZXRQYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgdG9wID0gLW9mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgKyBvZmZzZXRzLmJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9wID0gLW9mZnNldFBhcmVudFJlY3QuaGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRvcCA9IG9mZnNldHMudG9wO1xuICB9XG4gIGlmIChzaWRlQiA9PT0gJ3JpZ2h0Jykge1xuICAgIGlmIChvZmZzZXRQYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgbGVmdCA9IC1vZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggKyBvZmZzZXRzLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0gLW9mZnNldFBhcmVudFJlY3Qud2lkdGggKyBvZmZzZXRzLnJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZWZ0ID0gb2Zmc2V0cy5sZWZ0O1xuICB9XG4gIGlmIChncHVBY2NlbGVyYXRpb24gJiYgcHJlZml4ZWRQcm9wZXJ0eSkge1xuICAgIHN0eWxlc1twcmVmaXhlZFByb3BlcnR5XSA9IGB0cmFuc2xhdGUzZCgke2xlZnR9cHgsICR7dG9wfXB4LCAwKWA7XG4gICAgc3R5bGVzW3NpZGVBXSA9IDA7XG4gICAgc3R5bGVzW3NpZGVCXSA9IDA7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSAndHJhbnNmb3JtJztcbiAgfSBlbHNlIHtcbiAgICAvLyBvdGh3ZXJpc2UsIHdlIHVzZSB0aGUgc3RhbmRhcmQgYHRvcGAsIGBsZWZ0YCwgYGJvdHRvbWAgYW5kIGByaWdodGAgcHJvcGVydGllc1xuICAgIGNvbnN0IGludmVydFRvcCA9IHNpZGVBID09PSAnYm90dG9tJyA/IC0xIDogMTtcbiAgICBjb25zdCBpbnZlcnRMZWZ0ID0gc2lkZUIgPT09ICdyaWdodCcgPyAtMSA6IDE7XG4gICAgc3R5bGVzW3NpZGVBXSA9IHRvcCAqIGludmVydFRvcDtcbiAgICBzdHlsZXNbc2lkZUJdID0gbGVmdCAqIGludmVydExlZnQ7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSBgJHtzaWRlQX0sICR7c2lkZUJ9YDtcbiAgfVxuXG4gIC8vIEF0dHJpYnV0ZXNcbiAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICAneC1wbGFjZW1lbnQnOiBkYXRhLnBsYWNlbWVudCxcbiAgfTtcblxuICAvLyBVcGRhdGUgYGRhdGFgIGF0dHJpYnV0ZXMsIHN0eWxlcyBhbmQgYXJyb3dTdHlsZXNcbiAgZGF0YS5hdHRyaWJ1dGVzID0geyAuLi5hdHRyaWJ1dGVzLCAuLi5kYXRhLmF0dHJpYnV0ZXMgfTtcbiAgZGF0YS5zdHlsZXMgPSB7IC4uLnN0eWxlcywgLi4uZGF0YS5zdHlsZXMgfTtcbiAgZGF0YS5hcnJvd1N0eWxlcyA9IHsgLi4uZGF0YS5vZmZzZXRzLmFycm93LCAuLi5kYXRhLmFycm93U3R5bGVzIH07XG5cbiAgcmV0dXJuIGRhdGE7XG59XG4iLCJpbXBvcnQgZmluZCBmcm9tICcuL2ZpbmQnO1xuXG4vKipcbiAqIEhlbHBlciB1c2VkIHRvIGtub3cgaWYgdGhlIGdpdmVuIG1vZGlmaWVyIGRlcGVuZHMgZnJvbSBhbm90aGVyIG9uZS48YnIgLz5cbiAqIEl0IGNoZWNrcyBpZiB0aGUgbmVlZGVkIG1vZGlmaWVyIGlzIGxpc3RlZCBhbmQgZW5hYmxlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVycyAtIGxpc3Qgb2YgbW9kaWZpZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdGluZ05hbWUgLSBuYW1lIG9mIHJlcXVlc3RpbmcgbW9kaWZpZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0ZWROYW1lIC0gbmFtZSBvZiByZXF1ZXN0ZWQgbW9kaWZpZXJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc01vZGlmaWVyUmVxdWlyZWQoXG4gIG1vZGlmaWVycyxcbiAgcmVxdWVzdGluZ05hbWUsXG4gIHJlcXVlc3RlZE5hbWVcbikge1xuICBjb25zdCByZXF1ZXN0aW5nID0gZmluZChtb2RpZmllcnMsICh7IG5hbWUgfSkgPT4gbmFtZSA9PT0gcmVxdWVzdGluZ05hbWUpO1xuXG4gIGNvbnN0IGlzUmVxdWlyZWQgPVxuICAgICEhcmVxdWVzdGluZyAmJlxuICAgIG1vZGlmaWVycy5zb21lKG1vZGlmaWVyID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIG1vZGlmaWVyLm5hbWUgPT09IHJlcXVlc3RlZE5hbWUgJiZcbiAgICAgICAgbW9kaWZpZXIuZW5hYmxlZCAmJlxuICAgICAgICBtb2RpZmllci5vcmRlciA8IHJlcXVlc3Rpbmcub3JkZXJcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgaWYgKCFpc1JlcXVpcmVkKSB7XG4gICAgY29uc3QgcmVxdWVzdGluZyA9IGBcXGAke3JlcXVlc3RpbmdOYW1lfVxcYGA7XG4gICAgY29uc3QgcmVxdWVzdGVkID0gYFxcYCR7cmVxdWVzdGVkTmFtZX1cXGBgO1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGAke3JlcXVlc3RlZH0gbW9kaWZpZXIgaXMgcmVxdWlyZWQgYnkgJHtyZXF1ZXN0aW5nfSBtb2RpZmllciBpbiBvcmRlciB0byB3b3JrLCBiZSBzdXJlIHRvIGluY2x1ZGUgaXQgYmVmb3JlICR7cmVxdWVzdGluZ30hYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGlzUmVxdWlyZWQ7XG59XG4iLCJpbXBvcnQgZ2V0Q2xpZW50UmVjdCBmcm9tICcuLi91dGlscy9nZXRDbGllbnRSZWN0JztcbmltcG9ydCBnZXRPdXRlclNpemVzIGZyb20gJy4uL3V0aWxzL2dldE91dGVyU2l6ZXMnO1xuaW1wb3J0IGlzTW9kaWZpZXJSZXF1aXJlZCBmcm9tICcuLi91dGlscy9pc01vZGlmaWVyUmVxdWlyZWQnO1xuaW1wb3J0IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eSBmcm9tICcuLi91dGlscy9nZXRTdHlsZUNvbXB1dGVkUHJvcGVydHknO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXJyb3coZGF0YSwgb3B0aW9ucykge1xuICAvLyBhcnJvdyBkZXBlbmRzIG9uIGtlZXBUb2dldGhlciBpbiBvcmRlciB0byB3b3JrXG4gIGlmICghaXNNb2RpZmllclJlcXVpcmVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnYXJyb3cnLCAna2VlcFRvZ2V0aGVyJykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGxldCBhcnJvd0VsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQ7XG5cbiAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIGEgc3RyaW5nLCBzdXBwb3NlIGl0J3MgYSBDU1Mgc2VsZWN0b3JcbiAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJyb3dFbGVtZW50ID0gZGF0YS5pbnN0YW5jZS5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIG5vdCBmb3VuZCwgZG9uJ3QgcnVuIHRoZSBtb2RpZmllclxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgdGhlIGFycm93RWxlbWVudCBpc24ndCBhIHF1ZXJ5IHNlbGVjdG9yIHdlIG11c3QgY2hlY2sgdGhhdCB0aGVcbiAgICAvLyBwcm92aWRlZCBET00gbm9kZSBpcyBjaGlsZCBvZiBpdHMgcG9wcGVyIG5vZGVcbiAgICBpZiAoIWRhdGEuaW5zdGFuY2UucG9wcGVyLmNvbnRhaW5zKGFycm93RWxlbWVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ1dBUk5JTkc6IGBhcnJvdy5lbGVtZW50YCBtdXN0IGJlIGNoaWxkIG9mIGl0cyBwb3BwZXIgZWxlbWVudCEnXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgY29uc3QgeyBwb3BwZXIsIHJlZmVyZW5jZSB9ID0gZGF0YS5vZmZzZXRzO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICBjb25zdCBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICBjb25zdCBzaWRlQ2FwaXRhbGl6ZWQgPSBpc1ZlcnRpY2FsID8gJ1RvcCcgOiAnTGVmdCc7XG4gIGNvbnN0IHNpZGUgPSBzaWRlQ2FwaXRhbGl6ZWQudG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgYWx0U2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgY29uc3Qgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgY29uc3QgYXJyb3dFbGVtZW50U2l6ZSA9IGdldE91dGVyU2l6ZXMoYXJyb3dFbGVtZW50KVtsZW5dO1xuXG4gIC8vXG4gIC8vIGV4dGVuZHMga2VlcFRvZ2V0aGVyIGJlaGF2aW9yIG1ha2luZyBzdXJlIHRoZSBwb3BwZXIgYW5kIGl0c1xuICAvLyByZWZlcmVuY2UgaGF2ZSBlbm91Z2ggcGl4ZWxzIGluIGNvbmp1bmN0aW9uXG4gIC8vXG5cbiAgLy8gdG9wL2xlZnQgc2lkZVxuICBpZiAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd0VsZW1lbnRTaXplIDwgcG9wcGVyW3NpZGVdKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSAtPVxuICAgICAgcG9wcGVyW3NpZGVdIC0gKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSk7XG4gIH1cbiAgLy8gYm90dG9tL3JpZ2h0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtzaWRlXSArIGFycm93RWxlbWVudFNpemUgPiBwb3BwZXJbb3BTaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gKz1cbiAgICAgIHJlZmVyZW5jZVtzaWRlXSArIGFycm93RWxlbWVudFNpemUgLSBwb3BwZXJbb3BTaWRlXTtcbiAgfVxuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcblxuICAvLyBjb21wdXRlIGNlbnRlciBvZiB0aGUgcG9wcGVyXG4gIGNvbnN0IGNlbnRlciA9IHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVtsZW5dIC8gMiAtIGFycm93RWxlbWVudFNpemUgLyAyO1xuXG4gIC8vIENvbXB1dGUgdGhlIHNpZGVWYWx1ZSB1c2luZyB0aGUgdXBkYXRlZCBwb3BwZXIgb2Zmc2V0c1xuICAvLyB0YWtlIHBvcHBlciBtYXJnaW4gaW4gYWNjb3VudCBiZWNhdXNlIHdlIGRvbid0IGhhdmUgdGhpcyBpbmZvIGF2YWlsYWJsZVxuICBjb25zdCBjc3MgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICBjb25zdCBwb3BwZXJNYXJnaW5TaWRlID0gcGFyc2VGbG9hdChjc3NbYG1hcmdpbiR7c2lkZUNhcGl0YWxpemVkfWBdLCAxMCk7XG4gIGNvbnN0IHBvcHBlckJvcmRlclNpZGUgPSBwYXJzZUZsb2F0KGNzc1tgYm9yZGVyJHtzaWRlQ2FwaXRhbGl6ZWR9V2lkdGhgXSwgMTApO1xuICBsZXQgc2lkZVZhbHVlID1cbiAgICBjZW50ZXIgLSBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC0gcG9wcGVyTWFyZ2luU2lkZSAtIHBvcHBlckJvcmRlclNpZGU7XG5cbiAgLy8gcHJldmVudCBhcnJvd0VsZW1lbnQgZnJvbSBiZWluZyBwbGFjZWQgbm90IGNvbnRpZ3VvdXNseSB0byBpdHMgcG9wcGVyXG4gIHNpZGVWYWx1ZSA9IE1hdGgubWF4KE1hdGgubWluKHBvcHBlcltsZW5dIC0gYXJyb3dFbGVtZW50U2l6ZSwgc2lkZVZhbHVlKSwgMCk7XG5cbiAgZGF0YS5hcnJvd0VsZW1lbnQgPSBhcnJvd0VsZW1lbnQ7XG4gIGRhdGEub2Zmc2V0cy5hcnJvdyA9IHtcbiAgICBbc2lkZV06IE1hdGgucm91bmQoc2lkZVZhbHVlKSxcbiAgICBbYWx0U2lkZV06ICcnLCAvLyBtYWtlIHN1cmUgdG8gdW5zZXQgYW55IGV2ZW50dWFsIGFsdFNpZGUgdmFsdWUgZnJvbSB0aGUgRE9NIG5vZGVcbiAgfTtcblxuICByZXR1cm4gZGF0YTtcbn1cbiIsIi8qKlxuICogR2V0IHRoZSBvcHBvc2l0ZSBwbGFjZW1lbnQgdmFyaWF0aW9uIG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudCB2YXJpYXRpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKSB7XG4gIGlmICh2YXJpYXRpb24gPT09ICdlbmQnKSB7XG4gICAgcmV0dXJuICdzdGFydCc7XG4gIH0gZWxzZSBpZiAodmFyaWF0aW9uID09PSAnc3RhcnQnKSB7XG4gICAgcmV0dXJuICdlbmQnO1xuICB9XG4gIHJldHVybiB2YXJpYXRpb247XG59XG4iLCIvKipcbiAqIExpc3Qgb2YgYWNjZXB0ZWQgcGxhY2VtZW50cyB0byB1c2UgYXMgdmFsdWVzIG9mIHRoZSBgcGxhY2VtZW50YCBvcHRpb24uPGJyIC8+XG4gKiBWYWxpZCBwbGFjZW1lbnRzIGFyZTpcbiAqIC0gYGF1dG9gXG4gKiAtIGB0b3BgXG4gKiAtIGByaWdodGBcbiAqIC0gYGJvdHRvbWBcbiAqIC0gYGxlZnRgXG4gKlxuICogRWFjaCBwbGFjZW1lbnQgY2FuIGhhdmUgYSB2YXJpYXRpb24gZnJvbSB0aGlzIGxpc3Q6XG4gKiAtIGAtc3RhcnRgXG4gKiAtIGAtZW5kYFxuICpcbiAqIFZhcmlhdGlvbnMgYXJlIGludGVycHJldGVkIGVhc2lseSBpZiB5b3UgdGhpbmsgb2YgdGhlbSBhcyB0aGUgbGVmdCB0byByaWdodFxuICogd3JpdHRlbiBsYW5ndWFnZXMuIEhvcml6b250YWxseSAoYHRvcGAgYW5kIGBib3R0b21gKSwgYHN0YXJ0YCBpcyBsZWZ0IGFuZCBgZW5kYFxuICogaXMgcmlnaHQuPGJyIC8+XG4gKiBWZXJ0aWNhbGx5IChgbGVmdGAgYW5kIGByaWdodGApLCBgc3RhcnRgIGlzIHRvcCBhbmQgYGVuZGAgaXMgYm90dG9tLlxuICpcbiAqIFNvbWUgdmFsaWQgZXhhbXBsZXMgYXJlOlxuICogLSBgdG9wLWVuZGAgKG9uIHRvcCBvZiByZWZlcmVuY2UsIHJpZ2h0IGFsaWduZWQpXG4gKiAtIGByaWdodC1zdGFydGAgKG9uIHJpZ2h0IG9mIHJlZmVyZW5jZSwgdG9wIGFsaWduZWQpXG4gKiAtIGBib3R0b21gIChvbiBib3R0b20sIGNlbnRlcmVkKVxuICogLSBgYXV0by1lbmRgIChvbiB0aGUgc2lkZSB3aXRoIG1vcmUgc3BhY2UgYXZhaWxhYmxlLCBhbGlnbm1lbnQgZGVwZW5kcyBieSBwbGFjZW1lbnQpXG4gKlxuICogQHN0YXRpY1xuICogQHR5cGUge0FycmF5fVxuICogQGVudW0ge1N0cmluZ31cbiAqIEByZWFkb25seVxuICogQG1ldGhvZCBwbGFjZW1lbnRzXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFtcbiAgJ2F1dG8tc3RhcnQnLFxuICAnYXV0bycsXG4gICdhdXRvLWVuZCcsXG4gICd0b3Atc3RhcnQnLFxuICAndG9wJyxcbiAgJ3RvcC1lbmQnLFxuICAncmlnaHQtc3RhcnQnLFxuICAncmlnaHQnLFxuICAncmlnaHQtZW5kJyxcbiAgJ2JvdHRvbS1lbmQnLFxuICAnYm90dG9tJyxcbiAgJ2JvdHRvbS1zdGFydCcsXG4gICdsZWZ0LWVuZCcsXG4gICdsZWZ0JyxcbiAgJ2xlZnQtc3RhcnQnLFxuXTtcbiIsImltcG9ydCBwbGFjZW1lbnRzIGZyb20gJy4uL21ldGhvZHMvcGxhY2VtZW50cyc7XG5cbi8vIEdldCByaWQgb2YgYGF1dG9gIGBhdXRvLXN0YXJ0YCBhbmQgYGF1dG8tZW5kYFxuY29uc3QgdmFsaWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5zbGljZSgzKTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbml0aWFsIHBsYWNlbWVudCwgcmV0dXJucyBhbGwgdGhlIHN1YnNlcXVlbnQgcGxhY2VtZW50c1xuICogY2xvY2t3aXNlIChvciBjb3VudGVyLWNsb2Nrd2lzZSkuXG4gKlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCAtIEEgdmFsaWQgcGxhY2VtZW50IChpdCBhY2NlcHRzIHZhcmlhdGlvbnMpXG4gKiBAYXJndW1lbnQge0Jvb2xlYW59IGNvdW50ZXIgLSBTZXQgdG8gdHJ1ZSB0byB3YWxrIHRoZSBwbGFjZW1lbnRzIGNvdW50ZXJjbG9ja3dpc2VcbiAqIEByZXR1cm5zIHtBcnJheX0gcGxhY2VtZW50cyBpbmNsdWRpbmcgdGhlaXIgdmFyaWF0aW9uc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjbG9ja3dpc2UocGxhY2VtZW50LCBjb3VudGVyID0gZmFsc2UpIHtcbiAgY29uc3QgaW5kZXggPSB2YWxpZFBsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpO1xuICBjb25zdCBhcnIgPSB2YWxpZFBsYWNlbWVudHNcbiAgICAuc2xpY2UoaW5kZXggKyAxKVxuICAgIC5jb25jYXQodmFsaWRQbGFjZW1lbnRzLnNsaWNlKDAsIGluZGV4KSk7XG4gIHJldHVybiBjb3VudGVyID8gYXJyLnJldmVyc2UoKSA6IGFycjtcbn1cbiIsImltcG9ydCBnZXRPcHBvc2l0ZVBsYWNlbWVudCBmcm9tICcuLi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudCc7XG5pbXBvcnQgZ2V0T3Bwb3NpdGVWYXJpYXRpb24gZnJvbSAnLi4vdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb24nO1xuaW1wb3J0IGdldFBvcHBlck9mZnNldHMgZnJvbSAnLi4vdXRpbHMvZ2V0UG9wcGVyT2Zmc2V0cyc7XG5pbXBvcnQgcnVuTW9kaWZpZXJzIGZyb20gJy4uL3V0aWxzL3J1bk1vZGlmaWVycyc7XG5pbXBvcnQgZ2V0Qm91bmRhcmllcyBmcm9tICcuLi91dGlscy9nZXRCb3VuZGFyaWVzJztcbmltcG9ydCBpc01vZGlmaWVyRW5hYmxlZCBmcm9tICcuLi91dGlscy9pc01vZGlmaWVyRW5hYmxlZCc7XG5pbXBvcnQgY2xvY2t3aXNlIGZyb20gJy4uL3V0aWxzL2Nsb2Nrd2lzZSc7XG5cbmNvbnN0IEJFSEFWSU9SUyA9IHtcbiAgRkxJUDogJ2ZsaXAnLFxuICBDTE9DS1dJU0U6ICdjbG9ja3dpc2UnLFxuICBDT1VOVEVSQ0xPQ0tXSVNFOiAnY291bnRlcmNsb2Nrd2lzZScsXG59O1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmxpcChkYXRhLCBvcHRpb25zKSB7XG4gIC8vIGlmIGBpbm5lcmAgbW9kaWZpZXIgaXMgZW5hYmxlZCwgd2UgY2FuJ3QgdXNlIHRoZSBgZmxpcGAgbW9kaWZpZXJcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaW5uZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgaWYgKGRhdGEuZmxpcHBlZCAmJiBkYXRhLnBsYWNlbWVudCA9PT0gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCkge1xuICAgIC8vIHNlZW1zIGxpa2UgZmxpcCBpcyB0cnlpbmcgdG8gbG9vcCwgcHJvYmFibHkgdGhlcmUncyBub3QgZW5vdWdoIHNwYWNlIG9uIGFueSBvZiB0aGUgZmxpcHBhYmxlIHNpZGVzXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBjb25zdCBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhcbiAgICBkYXRhLmluc3RhbmNlLnBvcHBlcixcbiAgICBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSxcbiAgICBvcHRpb25zLnBhZGRpbmcsXG4gICAgb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCxcbiAgICBkYXRhLnBvc2l0aW9uRml4ZWRcbiAgKTtcblxuICBsZXQgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgbGV0IHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgbGV0IHZhcmlhdGlvbiA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMV0gfHwgJyc7XG5cbiAgbGV0IGZsaXBPcmRlciA9IFtdO1xuXG4gIHN3aXRjaCAob3B0aW9ucy5iZWhhdmlvcikge1xuICAgIGNhc2UgQkVIQVZJT1JTLkZMSVA6XG4gICAgICBmbGlwT3JkZXIgPSBbcGxhY2VtZW50LCBwbGFjZW1lbnRPcHBvc2l0ZV07XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DTE9DS1dJU0U6XG4gICAgICBmbGlwT3JkZXIgPSBjbG9ja3dpc2UocGxhY2VtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQkVIQVZJT1JTLkNPVU5URVJDTE9DS1dJU0U6XG4gICAgICBmbGlwT3JkZXIgPSBjbG9ja3dpc2UocGxhY2VtZW50LCB0cnVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBmbGlwT3JkZXIgPSBvcHRpb25zLmJlaGF2aW9yO1xuICB9XG5cbiAgZmxpcE9yZGVyLmZvckVhY2goKHN0ZXAsIGluZGV4KSA9PiB7XG4gICAgaWYgKHBsYWNlbWVudCAhPT0gc3RlcCB8fCBmbGlwT3JkZXIubGVuZ3RoID09PSBpbmRleCArIDEpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gICAgcGxhY2VtZW50T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgY29uc3QgcG9wcGVyT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG4gICAgY29uc3QgcmVmT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgICAvLyB1c2luZyBmbG9vciBiZWNhdXNlIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyBtYXkgY29udGFpbiBkZWNpbWFscyB3ZSBhcmUgbm90IGdvaW5nIHRvIGNvbnNpZGVyIGhlcmVcbiAgICBjb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgY29uc3Qgb3ZlcmxhcHNSZWYgPVxuICAgICAgKHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmXG4gICAgICAgIGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IocmVmT2Zmc2V0cy5sZWZ0KSkgfHxcbiAgICAgIChwbGFjZW1lbnQgPT09ICdyaWdodCcgJiZcbiAgICAgICAgZmxvb3IocG9wcGVyT2Zmc2V0cy5sZWZ0KSA8IGZsb29yKHJlZk9mZnNldHMucmlnaHQpKSB8fFxuICAgICAgKHBsYWNlbWVudCA9PT0gJ3RvcCcgJiZcbiAgICAgICAgZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IocmVmT2Zmc2V0cy50b3ApKSB8fFxuICAgICAgKHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiZcbiAgICAgICAgZmxvb3IocG9wcGVyT2Zmc2V0cy50b3ApIDwgZmxvb3IocmVmT2Zmc2V0cy5ib3R0b20pKTtcblxuICAgIGNvbnN0IG92ZXJmbG93c0xlZnQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IoYm91bmRhcmllcy5sZWZ0KTtcbiAgICBjb25zdCBvdmVyZmxvd3NSaWdodCA9IGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IoYm91bmRhcmllcy5yaWdodCk7XG4gICAgY29uc3Qgb3ZlcmZsb3dzVG9wID0gZmxvb3IocG9wcGVyT2Zmc2V0cy50b3ApIDwgZmxvb3IoYm91bmRhcmllcy50b3ApO1xuICAgIGNvbnN0IG92ZXJmbG93c0JvdHRvbSA9XG4gICAgICBmbG9vcihwb3BwZXJPZmZzZXRzLmJvdHRvbSkgPiBmbG9vcihib3VuZGFyaWVzLmJvdHRvbSk7XG5cbiAgICBjb25zdCBvdmVyZmxvd3NCb3VuZGFyaWVzID1cbiAgICAgIChwbGFjZW1lbnQgPT09ICdsZWZ0JyAmJiBvdmVyZmxvd3NMZWZ0KSB8fFxuICAgICAgKHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJiBvdmVyZmxvd3NSaWdodCkgfHxcbiAgICAgIChwbGFjZW1lbnQgPT09ICd0b3AnICYmIG92ZXJmbG93c1RvcCkgfHxcbiAgICAgIChwbGFjZW1lbnQgPT09ICdib3R0b20nICYmIG92ZXJmbG93c0JvdHRvbSk7XG5cbiAgICAvLyBmbGlwIHRoZSB2YXJpYXRpb24gaWYgcmVxdWlyZWRcbiAgICBjb25zdCBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICAgIC8vIGZsaXBzIHZhcmlhdGlvbiBpZiByZWZlcmVuY2UgZWxlbWVudCBvdmVyZmxvd3MgYm91bmRhcmllc1xuICAgIGNvbnN0IGZsaXBwZWRWYXJpYXRpb25CeVJlZiA9XG4gICAgICAhIW9wdGlvbnMuZmxpcFZhcmlhdGlvbnMgJiZcbiAgICAgICgoaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzTGVmdCkgfHxcbiAgICAgICAgKGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NSaWdodCkgfHxcbiAgICAgICAgKCFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NUb3ApIHx8XG4gICAgICAgICghaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c0JvdHRvbSkpO1xuXG4gICAgLy8gZmxpcHMgdmFyaWF0aW9uIGlmIHBvcHBlciBjb250ZW50IG92ZXJmbG93cyBib3VuZGFyaWVzXG4gICAgY29uc3QgZmxpcHBlZFZhcmlhdGlvbkJ5Q29udGVudCA9XG4gICAgICAhIW9wdGlvbnMuZmxpcFZhcmlhdGlvbnNCeUNvbnRlbnQgJiZcbiAgICAgICgoaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzUmlnaHQpIHx8XG4gICAgICAgIChpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzTGVmdCkgfHxcbiAgICAgICAgKCFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NCb3R0b20pIHx8XG4gICAgICAgICghaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c1RvcCkpO1xuXG4gICAgY29uc3QgZmxpcHBlZFZhcmlhdGlvbiA9IGZsaXBwZWRWYXJpYXRpb25CeVJlZiB8fCBmbGlwcGVkVmFyaWF0aW9uQnlDb250ZW50O1xuXG4gICAgaWYgKG92ZXJsYXBzUmVmIHx8IG92ZXJmbG93c0JvdW5kYXJpZXMgfHwgZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgLy8gdGhpcyBib29sZWFuIHRvIGRldGVjdCBhbnkgZmxpcCBsb29wXG4gICAgICBkYXRhLmZsaXBwZWQgPSB0cnVlO1xuXG4gICAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcykge1xuICAgICAgICBwbGFjZW1lbnQgPSBmbGlwT3JkZXJbaW5kZXggKyAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZsaXBwZWRWYXJpYXRpb24pIHtcbiAgICAgICAgdmFyaWF0aW9uID0gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGF0YS5wbGFjZW1lbnQgPSBwbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xuXG4gICAgICAvLyB0aGlzIG9iamVjdCBjb250YWlucyBgcG9zaXRpb25gLCB3ZSB3YW50IHRvIHByZXNlcnZlIGl0IGFsb25nIHdpdGhcbiAgICAgIC8vIGFueSBhZGRpdGlvbmFsIHByb3BlcnR5IHdlIG1heSBhZGQgaW4gdGhlIGZ1dHVyZVxuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IHtcbiAgICAgICAgLi4uZGF0YS5vZmZzZXRzLnBvcHBlcixcbiAgICAgICAgLi4uZ2V0UG9wcGVyT2Zmc2V0cyhcbiAgICAgICAgICBkYXRhLmluc3RhbmNlLnBvcHBlcixcbiAgICAgICAgICBkYXRhLm9mZnNldHMucmVmZXJlbmNlLFxuICAgICAgICAgIGRhdGEucGxhY2VtZW50XG4gICAgICAgICksXG4gICAgICB9O1xuXG4gICAgICBkYXRhID0gcnVuTW9kaWZpZXJzKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBkYXRhLCAnZmxpcCcpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufVxuIiwiLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGtlZXBUb2dldGhlcihkYXRhKSB7XG4gIGNvbnN0IHsgcG9wcGVyLCByZWZlcmVuY2UgfSA9IGRhdGEub2Zmc2V0cztcbiAgY29uc3QgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgY29uc3QgZmxvb3IgPSBNYXRoLmZsb29yO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgY29uc3Qgc2lkZSA9IGlzVmVydGljYWwgPyAncmlnaHQnIDogJ2JvdHRvbSc7XG4gIGNvbnN0IG9wU2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgY29uc3QgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gIGlmIChwb3BwZXJbc2lkZV0gPCBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPVxuICAgICAgZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pIC0gcG9wcGVyW21lYXN1cmVtZW50XTtcbiAgfVxuICBpZiAocG9wcGVyW29wU2lkZV0gPiBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW3NpZGVdKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuIiwiaW1wb3J0IGlzTnVtZXJpYyBmcm9tICcuLi91dGlscy9pc051bWVyaWMnO1xuaW1wb3J0IGdldENsaWVudFJlY3QgZnJvbSAnLi4vdXRpbHMvZ2V0Q2xpZW50UmVjdCc7XG5pbXBvcnQgZmluZCBmcm9tICcuLi91dGlscy9maW5kJztcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBjb250YWluaW5nIHZhbHVlICsgdW5pdCBpbnRvIGEgcHggdmFsdWUgbnVtYmVyXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiB7bW9kaWZpZXJzfm9mZnNldH1cbiAqIEBwcml2YXRlXG4gKiBAYXJndW1lbnQge1N0cmluZ30gc3RyIC0gVmFsdWUgKyB1bml0IHN0cmluZ1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IG1lYXN1cmVtZW50IC0gYGhlaWdodGAgb3IgYHdpZHRoYFxuICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gKiBAcmV0dXJucyB7TnVtYmVyfFN0cmluZ31cbiAqIFZhbHVlIGluIHBpeGVscywgb3Igb3JpZ2luYWwgc3RyaW5nIGlmIG5vIHZhbHVlcyB3ZXJlIGV4dHJhY3RlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9WYWx1ZShzdHIsIG1lYXN1cmVtZW50LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzKSB7XG4gIC8vIHNlcGFyYXRlIHZhbHVlIGZyb20gdW5pdFxuICBjb25zdCBzcGxpdCA9IHN0ci5tYXRjaCgvKCg/OlxcLXxcXCspP1xcZCpcXC4/XFxkKikoLiopLyk7XG4gIGNvbnN0IHZhbHVlID0gK3NwbGl0WzFdO1xuICBjb25zdCB1bml0ID0gc3BsaXRbMl07XG5cbiAgLy8gSWYgaXQncyBub3QgYSBudW1iZXIgaXQncyBhbiBvcGVyYXRvciwgSSBndWVzc1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIGlmICh1bml0LmluZGV4T2YoJyUnKSA9PT0gMCkge1xuICAgIGxldCBlbGVtZW50O1xuICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgY2FzZSAnJXAnOlxuICAgICAgICBlbGVtZW50ID0gcG9wcGVyT2Zmc2V0cztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICclJzpcbiAgICAgIGNhc2UgJyVyJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGVsZW1lbnQgPSByZWZlcmVuY2VPZmZzZXRzO1xuICAgIH1cblxuICAgIGNvbnN0IHJlY3QgPSBnZXRDbGllbnRSZWN0KGVsZW1lbnQpO1xuICAgIHJldHVybiByZWN0W21lYXN1cmVtZW50XSAvIDEwMCAqIHZhbHVlO1xuICB9IGVsc2UgaWYgKHVuaXQgPT09ICd2aCcgfHwgdW5pdCA9PT0gJ3Z3Jykge1xuICAgIC8vIGlmIGlzIGEgdmggb3IgdncsIHdlIGNhbGN1bGF0ZSB0aGUgc2l6ZSBiYXNlZCBvbiB0aGUgdmlld3BvcnRcbiAgICBsZXQgc2l6ZTtcbiAgICBpZiAodW5pdCA9PT0gJ3ZoJykge1xuICAgICAgc2l6ZSA9IE1hdGgubWF4KFxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LFxuICAgICAgICB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2l6ZSA9IE1hdGgubWF4KFxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICAgIHdpbmRvdy5pbm5lcldpZHRoIHx8IDBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBzaXplIC8gMTAwICogdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgaXMgYW4gZXhwbGljaXQgcGl4ZWwgdW5pdCwgd2UgZ2V0IHJpZCBvZiB0aGUgdW5pdCBhbmQga2VlcCB0aGUgdmFsdWVcbiAgICAvLyBpZiBpcyBhbiBpbXBsaWNpdCB1bml0LCBpdCdzIHB4LCBhbmQgd2UgcmV0dXJuIGp1c3QgdGhlIHZhbHVlXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYW4gYG9mZnNldGAgc3RyaW5nIHRvIGV4dHJhcG9sYXRlIGB4YCBhbmQgYHlgIG51bWVyaWMgb2Zmc2V0cy5cbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIHttb2RpZmllcnN+b2Zmc2V0fVxuICogQHByaXZhdGVcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBvZmZzZXRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzXG4gKiBAYXJndW1lbnQge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IGJhc2VQbGFjZW1lbnRcbiAqIEByZXR1cm5zIHtBcnJheX0gYSB0d28gY2VsbHMgYXJyYXkgd2l0aCB4IGFuZCB5IG9mZnNldHMgaW4gbnVtYmVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VPZmZzZXQoXG4gIG9mZnNldCxcbiAgcG9wcGVyT2Zmc2V0cyxcbiAgcmVmZXJlbmNlT2Zmc2V0cyxcbiAgYmFzZVBsYWNlbWVudFxuKSB7XG4gIGNvbnN0IG9mZnNldHMgPSBbMCwgMF07XG5cbiAgLy8gVXNlIGhlaWdodCBpZiBwbGFjZW1lbnQgaXMgbGVmdCBvciByaWdodCBhbmQgaW5kZXggaXMgMCBvdGhlcndpc2UgdXNlIHdpZHRoXG4gIC8vIGluIHRoaXMgd2F5IHRoZSBmaXJzdCBvZmZzZXQgd2lsbCB1c2UgYW4gYXhpcyBhbmQgdGhlIHNlY29uZCBvbmVcbiAgLy8gd2lsbCB1c2UgdGhlIG90aGVyIG9uZVxuICBjb25zdCB1c2VIZWlnaHQgPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAvLyBTcGxpdCB0aGUgb2Zmc2V0IHN0cmluZyB0byBvYnRhaW4gYSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHNcbiAgLy8gVGhlIHJlZ2V4IGFkZHJlc3NlcyB2YWx1ZXMgd2l0aCB0aGUgcGx1cyBvciBtaW51cyBzaWduIGluIGZyb250ICgrMTAsIC0yMCwgZXRjKVxuICBjb25zdCBmcmFnbWVudHMgPSBvZmZzZXQuc3BsaXQoLyhcXCt8XFwtKS8pLm1hcChmcmFnID0+IGZyYWcudHJpbSgpKTtcblxuICAvLyBEZXRlY3QgaWYgdGhlIG9mZnNldCBzdHJpbmcgY29udGFpbnMgYSBwYWlyIG9mIHZhbHVlcyBvciBhIHNpbmdsZSBvbmVcbiAgLy8gdGhleSBjb3VsZCBiZSBzZXBhcmF0ZWQgYnkgY29tbWEgb3Igc3BhY2VcbiAgY29uc3QgZGl2aWRlciA9IGZyYWdtZW50cy5pbmRleE9mKFxuICAgIGZpbmQoZnJhZ21lbnRzLCBmcmFnID0+IGZyYWcuc2VhcmNoKC8sfFxccy8pICE9PSAtMSlcbiAgKTtcblxuICBpZiAoZnJhZ21lbnRzW2RpdmlkZXJdICYmIGZyYWdtZW50c1tkaXZpZGVyXS5pbmRleE9mKCcsJykgPT09IC0xKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ09mZnNldHMgc2VwYXJhdGVkIGJ5IHdoaXRlIHNwYWNlKHMpIGFyZSBkZXByZWNhdGVkLCB1c2UgYSBjb21tYSAoLCkgaW5zdGVhZC4nXG4gICAgKTtcbiAgfVxuXG4gIC8vIElmIGRpdmlkZXIgaXMgZm91bmQsIHdlIGRpdmlkZSB0aGUgbGlzdCBvZiB2YWx1ZXMgYW5kIG9wZXJhbmRzIHRvIGRpdmlkZVxuICAvLyB0aGVtIGJ5IG9mc2V0IFggYW5kIFkuXG4gIGNvbnN0IHNwbGl0UmVnZXggPSAvXFxzKixcXHMqfFxccysvO1xuICBsZXQgb3BzID0gZGl2aWRlciAhPT0gLTFcbiAgICA/IFtcbiAgICAgICAgZnJhZ21lbnRzXG4gICAgICAgICAgLnNsaWNlKDAsIGRpdmlkZXIpXG4gICAgICAgICAgLmNvbmNhdChbZnJhZ21lbnRzW2RpdmlkZXJdLnNwbGl0KHNwbGl0UmVnZXgpWzBdXSksXG4gICAgICAgIFtmcmFnbWVudHNbZGl2aWRlcl0uc3BsaXQoc3BsaXRSZWdleClbMV1dLmNvbmNhdChcbiAgICAgICAgICBmcmFnbWVudHMuc2xpY2UoZGl2aWRlciArIDEpXG4gICAgICAgICksXG4gICAgICBdXG4gICAgOiBbZnJhZ21lbnRzXTtcblxuICAvLyBDb252ZXJ0IHRoZSB2YWx1ZXMgd2l0aCB1bml0cyB0byBhYnNvbHV0ZSBwaXhlbHMgdG8gYWxsb3cgb3VyIGNvbXB1dGF0aW9uc1xuICBvcHMgPSBvcHMubWFwKChvcCwgaW5kZXgpID0+IHtcbiAgICAvLyBNb3N0IG9mIHRoZSB1bml0cyByZWx5IG9uIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgcG9wcGVyXG4gICAgY29uc3QgbWVhc3VyZW1lbnQgPSAoaW5kZXggPT09IDEgPyAhdXNlSGVpZ2h0IDogdXNlSGVpZ2h0KVxuICAgICAgPyAnaGVpZ2h0J1xuICAgICAgOiAnd2lkdGgnO1xuICAgIGxldCBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgIHJldHVybiAoXG4gICAgICBvcFxuICAgICAgICAvLyBUaGlzIGFnZ3JlZ2F0ZXMgYW55IGArYCBvciBgLWAgc2lnbiB0aGF0IGFyZW4ndCBjb25zaWRlcmVkIG9wZXJhdG9yc1xuICAgICAgICAvLyBlLmcuOiAxMCArICs1ID0+IFsxMCwgKywgKzVdXG4gICAgICAgIC5yZWR1Y2UoKGEsIGIpID0+IHtcbiAgICAgICAgICBpZiAoYVthLmxlbmd0aCAtIDFdID09PSAnJyAmJiBbJysnLCAnLSddLmluZGV4T2YoYikgIT09IC0xKSB7XG4gICAgICAgICAgICBhW2EubGVuZ3RoIC0gMV0gPSBiO1xuICAgICAgICAgICAgbWVyZ2VXaXRoUHJldmlvdXMgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgfSBlbHNlIGlmIChtZXJnZVdpdGhQcmV2aW91cykge1xuICAgICAgICAgICAgYVthLmxlbmd0aCAtIDFdICs9IGI7XG4gICAgICAgICAgICBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKVxuICAgICAgICAvLyBIZXJlIHdlIGNvbnZlcnQgdGhlIHN0cmluZyB2YWx1ZXMgaW50byBudW1iZXIgdmFsdWVzIChpbiBweClcbiAgICAgICAgLm1hcChzdHIgPT4gdG9WYWx1ZShzdHIsIG1lYXN1cmVtZW50LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzKSlcbiAgICApO1xuICB9KTtcblxuICAvLyBMb29wIHRyb3VnaCB0aGUgb2Zmc2V0cyBhcnJheXMgYW5kIGV4ZWN1dGUgdGhlIG9wZXJhdGlvbnNcbiAgb3BzLmZvckVhY2goKG9wLCBpbmRleCkgPT4ge1xuICAgIG9wLmZvckVhY2goKGZyYWcsIGluZGV4MikgPT4ge1xuICAgICAgaWYgKGlzTnVtZXJpYyhmcmFnKSkge1xuICAgICAgICBvZmZzZXRzW2luZGV4XSArPSBmcmFnICogKG9wW2luZGV4MiAtIDFdID09PSAnLScgPyAtMSA6IDEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQGFyZ3VtZW50IHtOdW1iZXJ8U3RyaW5nfSBvcHRpb25zLm9mZnNldD0wXG4gKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb2Zmc2V0KGRhdGEsIHsgb2Zmc2V0IH0pIHtcbiAgY29uc3QgeyBwbGFjZW1lbnQsIG9mZnNldHM6IHsgcG9wcGVyLCByZWZlcmVuY2UgfSB9ID0gZGF0YTtcbiAgY29uc3QgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuXG4gIGxldCBvZmZzZXRzO1xuICBpZiAoaXNOdW1lcmljKCtvZmZzZXQpKSB7XG4gICAgb2Zmc2V0cyA9IFsrb2Zmc2V0LCAwXTtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXRzID0gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYmFzZVBsYWNlbWVudCk7XG4gIH1cblxuICBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2xlZnQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0IC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3JpZ2h0Jykge1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICd0b3AnKSB7XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIudG9wIC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2JvdHRvbScpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1sxXTtcbiAgfVxuXG4gIGRhdGEucG9wcGVyID0gcG9wcGVyO1xuICByZXR1cm4gZGF0YTtcbn1cbiIsImltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSAnLi4vdXRpbHMvZ2V0T2Zmc2V0UGFyZW50JztcbmltcG9ydCBnZXRCb3VuZGFyaWVzIGZyb20gJy4uL3V0aWxzL2dldEJvdW5kYXJpZXMnO1xuaW1wb3J0IGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZSBmcm9tICcuLi91dGlscy9nZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUnO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coZGF0YSwgb3B0aW9ucykge1xuICBsZXQgYm91bmRhcmllc0VsZW1lbnQgPVxuICAgIG9wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQgfHwgZ2V0T2Zmc2V0UGFyZW50KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcblxuICAvLyBJZiBvZmZzZXRQYXJlbnQgaXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LCB3ZSByZWFsbHkgd2FudCB0b1xuICAvLyBnbyBvbmUgc3RlcCB1cCBhbmQgdXNlIHRoZSBuZXh0IG9mZnNldFBhcmVudCBhcyByZWZlcmVuY2UgdG9cbiAgLy8gYXZvaWQgdG8gbWFrZSB0aGlzIG1vZGlmaWVyIGNvbXBsZXRlbHkgdXNlbGVzcyBhbmQgbG9vayBsaWtlIGJyb2tlblxuICBpZiAoZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UgPT09IGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gICAgYm91bmRhcmllc0VsZW1lbnQgPSBnZXRPZmZzZXRQYXJlbnQoYm91bmRhcmllc0VsZW1lbnQpO1xuICB9XG5cbiAgLy8gTk9URTogRE9NIGFjY2VzcyBoZXJlXG4gIC8vIHJlc2V0cyB0aGUgcG9wcGVyJ3MgcG9zaXRpb24gc28gdGhhdCB0aGUgZG9jdW1lbnQgc2l6ZSBjYW4gYmUgY2FsY3VsYXRlZCBleGNsdWRpbmdcbiAgLy8gdGhlIHNpemUgb2YgdGhlIHBvcHBlciBlbGVtZW50IGl0c2VsZlxuICBjb25zdCB0cmFuc2Zvcm1Qcm9wID0gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKTtcbiAgY29uc3QgcG9wcGVyU3R5bGVzID0gZGF0YS5pbnN0YW5jZS5wb3BwZXIuc3R5bGU7IC8vIGFzc2lnbm1lbnQgdG8gaGVscCBtaW5pZmljYXRpb25cbiAgY29uc3QgeyB0b3AsIGxlZnQsIFt0cmFuc2Zvcm1Qcm9wXTogdHJhbnNmb3JtIH0gPSBwb3BwZXJTdHlsZXM7XG4gIHBvcHBlclN0eWxlcy50b3AgPSAnJztcbiAgcG9wcGVyU3R5bGVzLmxlZnQgPSAnJztcbiAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gJyc7XG5cbiAgY29uc3QgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoXG4gICAgZGF0YS5pbnN0YW5jZS5wb3BwZXIsXG4gICAgZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UsXG4gICAgb3B0aW9ucy5wYWRkaW5nLFxuICAgIGJvdW5kYXJpZXNFbGVtZW50LFxuICAgIGRhdGEucG9zaXRpb25GaXhlZFxuICApO1xuXG4gIC8vIE5PVEU6IERPTSBhY2Nlc3MgaGVyZVxuICAvLyByZXN0b3JlcyB0aGUgb3JpZ2luYWwgc3R5bGUgcHJvcGVydGllcyBhZnRlciB0aGUgb2Zmc2V0cyBoYXZlIGJlZW4gY29tcHV0ZWRcbiAgcG9wcGVyU3R5bGVzLnRvcCA9IHRvcDtcbiAgcG9wcGVyU3R5bGVzLmxlZnQgPSBsZWZ0O1xuICBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm07XG5cbiAgb3B0aW9ucy5ib3VuZGFyaWVzID0gYm91bmRhcmllcztcblxuICBjb25zdCBvcmRlciA9IG9wdGlvbnMucHJpb3JpdHk7XG4gIGxldCBwb3BwZXIgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuXG4gIGNvbnN0IGNoZWNrID0ge1xuICAgIHByaW1hcnkocGxhY2VtZW50KSB7XG4gICAgICBsZXQgdmFsdWUgPSBwb3BwZXJbcGxhY2VtZW50XTtcbiAgICAgIGlmIChcbiAgICAgICAgcG9wcGVyW3BsYWNlbWVudF0gPCBib3VuZGFyaWVzW3BsYWNlbWVudF0gJiZcbiAgICAgICAgIW9wdGlvbnMuZXNjYXBlV2l0aFJlZmVyZW5jZVxuICAgICAgKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5tYXgocG9wcGVyW3BsYWNlbWVudF0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBbcGxhY2VtZW50XTogdmFsdWUgfTtcbiAgICB9LFxuICAgIHNlY29uZGFyeShwbGFjZW1lbnQpIHtcbiAgICAgIGNvbnN0IG1haW5TaWRlID0gcGxhY2VtZW50ID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgICBsZXQgdmFsdWUgPSBwb3BwZXJbbWFpblNpZGVdO1xuICAgICAgaWYgKFxuICAgICAgICBwb3BwZXJbcGxhY2VtZW50XSA+IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJlxuICAgICAgICAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlXG4gICAgICApIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLm1pbihcbiAgICAgICAgICBwb3BwZXJbbWFpblNpZGVdLFxuICAgICAgICAgIGJvdW5kYXJpZXNbcGxhY2VtZW50XSAtXG4gICAgICAgICAgICAocGxhY2VtZW50ID09PSAncmlnaHQnID8gcG9wcGVyLndpZHRoIDogcG9wcGVyLmhlaWdodClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IFttYWluU2lkZV06IHZhbHVlIH07XG4gICAgfSxcbiAgfTtcblxuICBvcmRlci5mb3JFYWNoKHBsYWNlbWVudCA9PiB7XG4gICAgY29uc3Qgc2lkZSA9XG4gICAgICBbJ2xlZnQnLCAndG9wJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMSA/ICdwcmltYXJ5JyA6ICdzZWNvbmRhcnknO1xuICAgIHBvcHBlciA9IHsgLi4ucG9wcGVyLCAuLi5jaGVja1tzaWRlXShwbGFjZW1lbnQpIH07XG4gIH0pO1xuXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBwb3BwZXI7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG4iLCIvKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzaGlmdChkYXRhKSB7XG4gIGNvbnN0IHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICBjb25zdCBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIGNvbnN0IHNoaWZ0dmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgLy8gaWYgc2hpZnQgc2hpZnR2YXJpYXRpb24gaXMgc3BlY2lmaWVkLCBydW4gdGhlIG1vZGlmaWVyXG4gIGlmIChzaGlmdHZhcmlhdGlvbikge1xuICAgIGNvbnN0IHsgcmVmZXJlbmNlLCBwb3BwZXIgfSA9IGRhdGEub2Zmc2V0cztcbiAgICBjb25zdCBpc1ZlcnRpY2FsID0gWydib3R0b20nLCAndG9wJ10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG4gICAgY29uc3Qgc2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgICBjb25zdCBtZWFzdXJlbWVudCA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgICBjb25zdCBzaGlmdE9mZnNldHMgPSB7XG4gICAgICBzdGFydDogeyBbc2lkZV06IHJlZmVyZW5jZVtzaWRlXSB9LFxuICAgICAgZW5kOiB7XG4gICAgICAgIFtzaWRlXTogcmVmZXJlbmNlW3NpZGVdICsgcmVmZXJlbmNlW21lYXN1cmVtZW50XSAtIHBvcHBlclttZWFzdXJlbWVudF0sXG4gICAgICB9LFxuICAgIH07XG5cbiAgICBkYXRhLm9mZnNldHMucG9wcGVyID0geyAuLi5wb3BwZXIsIC4uLnNoaWZ0T2Zmc2V0c1tzaGlmdHZhcmlhdGlvbl0gfTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuIiwiaW1wb3J0IGlzTW9kaWZpZXJSZXF1aXJlZCBmcm9tICcuLi91dGlscy9pc01vZGlmaWVyUmVxdWlyZWQnO1xuaW1wb3J0IGZpbmQgZnJvbSAnLi4vdXRpbHMvZmluZCc7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBoaWRlKGRhdGEpIHtcbiAgaWYgKCFpc01vZGlmaWVyUmVxdWlyZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdoaWRlJywgJ3ByZXZlbnRPdmVyZmxvdycpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBjb25zdCByZWZSZWN0ID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcbiAgY29uc3QgYm91bmQgPSBmaW5kKFxuICAgIGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLFxuICAgIG1vZGlmaWVyID0+IG1vZGlmaWVyLm5hbWUgPT09ICdwcmV2ZW50T3ZlcmZsb3cnXG4gICkuYm91bmRhcmllcztcblxuICBpZiAoXG4gICAgcmVmUmVjdC5ib3R0b20gPCBib3VuZC50b3AgfHxcbiAgICByZWZSZWN0LmxlZnQgPiBib3VuZC5yaWdodCB8fFxuICAgIHJlZlJlY3QudG9wID4gYm91bmQuYm90dG9tIHx8XG4gICAgcmVmUmVjdC5yaWdodCA8IGJvdW5kLmxlZnRcbiAgKSB7XG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgRE9NIGFjY2VzcyBpZiB2aXNpYmlsaXR5IGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKGRhdGEuaGlkZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gdHJ1ZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9ICcnO1xuICB9IGVsc2Uge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhLmhpZGUgPSBmYWxzZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG4iLCJpbXBvcnQgZ2V0Q2xpZW50UmVjdCBmcm9tICcuLi91dGlscy9nZXRDbGllbnRSZWN0JztcbmltcG9ydCBnZXRPcHBvc2l0ZVBsYWNlbWVudCBmcm9tICcuLi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudCc7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlubmVyKGRhdGEpIHtcbiAgY29uc3QgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gIGNvbnN0IGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgY29uc3QgeyBwb3BwZXIsIHJlZmVyZW5jZSB9ID0gZGF0YS5vZmZzZXRzO1xuICBjb25zdCBpc0hvcml6ID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgY29uc3Qgc3VidHJhY3RMZW5ndGggPSBbJ3RvcCcsICdsZWZ0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA9PT0gLTE7XG5cbiAgcG9wcGVyW2lzSG9yaXogPyAnbGVmdCcgOiAndG9wJ10gPVxuICAgIHJlZmVyZW5jZVtiYXNlUGxhY2VtZW50XSAtXG4gICAgKHN1YnRyYWN0TGVuZ3RoID8gcG9wcGVyW2lzSG9yaXogPyAnd2lkdGgnIDogJ2hlaWdodCddIDogMCk7XG5cbiAgZGF0YS5wbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChwb3BwZXIpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuIiwiaW1wb3J0IGFwcGx5U3R5bGUsIHsgYXBwbHlTdHlsZU9uTG9hZCB9IGZyb20gJy4vYXBwbHlTdHlsZSc7XG5pbXBvcnQgY29tcHV0ZVN0eWxlIGZyb20gJy4vY29tcHV0ZVN0eWxlJztcbmltcG9ydCBhcnJvdyBmcm9tICcuL2Fycm93JztcbmltcG9ydCBmbGlwIGZyb20gJy4vZmxpcCc7XG5pbXBvcnQga2VlcFRvZ2V0aGVyIGZyb20gJy4va2VlcFRvZ2V0aGVyJztcbmltcG9ydCBvZmZzZXQgZnJvbSAnLi9vZmZzZXQnO1xuaW1wb3J0IHByZXZlbnRPdmVyZmxvdyBmcm9tICcuL3ByZXZlbnRPdmVyZmxvdyc7XG5pbXBvcnQgc2hpZnQgZnJvbSAnLi9zaGlmdCc7XG5pbXBvcnQgaGlkZSBmcm9tICcuL2hpZGUnO1xuaW1wb3J0IGlubmVyIGZyb20gJy4vaW5uZXInO1xuXG4vKipcbiAqIE1vZGlmaWVyIGZ1bmN0aW9uLCBlYWNoIG1vZGlmaWVyIGNhbiBoYXZlIGEgZnVuY3Rpb24gb2YgdGhpcyB0eXBlIGFzc2lnbmVkXG4gKiB0byBpdHMgYGZuYCBwcm9wZXJ0eS48YnIgLz5cbiAqIFRoZXNlIGZ1bmN0aW9ucyB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIHVwZGF0ZSwgdGhpcyBtZWFucyB0aGF0IHlvdSBtdXN0XG4gKiBtYWtlIHN1cmUgdGhleSBhcmUgcGVyZm9ybWFudCBlbm91Z2ggdG8gYXZvaWQgcGVyZm9ybWFuY2UgYm90dGxlbmVja3MuXG4gKlxuICogQGZ1bmN0aW9uIE1vZGlmaWVyRm5cbiAqIEBhcmd1bWVudCB7ZGF0YU9iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5cbi8qKlxuICogTW9kaWZpZXJzIGFyZSBwbHVnaW5zIHVzZWQgdG8gYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHlvdXIgcG9wcGVycy48YnIgLz5cbiAqIFBvcHBlci5qcyB1c2VzIGEgc2V0IG9mIDkgbW9kaWZpZXJzIHRvIHByb3ZpZGUgYWxsIHRoZSBiYXNpYyBmdW5jdGlvbmFsaXRpZXNcbiAqIG5lZWRlZCBieSB0aGUgbGlicmFyeS5cbiAqXG4gKiBVc3VhbGx5IHlvdSBkb24ndCB3YW50IHRvIG92ZXJyaWRlIHRoZSBgb3JkZXJgLCBgZm5gIGFuZCBgb25Mb2FkYCBwcm9wcy5cbiAqIEFsbCB0aGUgb3RoZXIgcHJvcGVydGllcyBhcmUgY29uZmlndXJhdGlvbnMgdGhhdCBjb3VsZCBiZSB0d2Vha2VkLlxuICogQG5hbWVzcGFjZSBtb2RpZmllcnNcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBzaGlmdCB0aGUgcG9wcGVyIG9uIHRoZSBzdGFydCBvciBlbmQgb2YgaXRzIHJlZmVyZW5jZVxuICAgKiBlbGVtZW50LjxiciAvPlxuICAgKiBJdCB3aWxsIHJlYWQgdGhlIHZhcmlhdGlvbiBvZiB0aGUgYHBsYWNlbWVudGAgcHJvcGVydHkuPGJyIC8+XG4gICAqIEl0IGNhbiBiZSBvbmUgZWl0aGVyIGAtZW5kYCBvciBgLXN0YXJ0YC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHNoaWZ0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTEwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogc2hpZnQsXG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBgb2Zmc2V0YCBtb2RpZmllciBjYW4gc2hpZnQgeW91ciBwb3BwZXIgb24gYm90aCBpdHMgYXhpcy5cbiAgICpcbiAgICogSXQgYWNjZXB0cyB0aGUgZm9sbG93aW5nIHVuaXRzOlxuICAgKiAtIGBweGAgb3IgdW5pdC1sZXNzLCBpbnRlcnByZXRlZCBhcyBwaXhlbHNcbiAgICogLSBgJWAgb3IgYCVyYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICAgKiAtIGAlcGAsIHBlcmNlbnRhZ2UgcmVsYXRpdmUgdG8gdGhlIGxlbmd0aCBvZiB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICogLSBgdndgLCBDU1Mgdmlld3BvcnQgd2lkdGggdW5pdFxuICAgKiAtIGB2aGAsIENTUyB2aWV3cG9ydCBoZWlnaHQgdW5pdFxuICAgKlxuICAgKiBGb3IgbGVuZ3RoIGlzIGludGVuZGVkIHRoZSBtYWluIGF4aXMgcmVsYXRpdmUgdG8gdGhlIHBsYWNlbWVudCBvZiB0aGUgcG9wcGVyLjxiciAvPlxuICAgKiBUaGlzIG1lYW5zIHRoYXQgaWYgdGhlIHBsYWNlbWVudCBpcyBgdG9wYCBvciBgYm90dG9tYCwgdGhlIGxlbmd0aCB3aWxsIGJlIHRoZVxuICAgKiBgd2lkdGhgLiBJbiBjYXNlIG9mIGBsZWZ0YCBvciBgcmlnaHRgLCBpdCB3aWxsIGJlIHRoZSBgaGVpZ2h0YC5cbiAgICpcbiAgICogWW91IGNhbiBwcm92aWRlIGEgc2luZ2xlIHZhbHVlIChhcyBgTnVtYmVyYCBvciBgU3RyaW5nYCksIG9yIGEgcGFpciBvZiB2YWx1ZXNcbiAgICogYXMgYFN0cmluZ2AgZGl2aWRlZCBieSBhIGNvbW1hIG9yIG9uZSAob3IgbW9yZSkgd2hpdGUgc3BhY2VzLjxiciAvPlxuICAgKiBUaGUgbGF0dGVyIGlzIGEgZGVwcmVjYXRlZCBtZXRob2QgYmVjYXVzZSBpdCBsZWFkcyB0byBjb25mdXNpb24gYW5kIHdpbGwgYmVcbiAgICogcmVtb3ZlZCBpbiB2Mi48YnIgLz5cbiAgICogQWRkaXRpb25hbGx5LCBpdCBhY2NlcHRzIGFkZGl0aW9ucyBhbmQgc3VidHJhY3Rpb25zIGJldHdlZW4gZGlmZmVyZW50IHVuaXRzLlxuICAgKiBOb3RlIHRoYXQgbXVsdGlwbGljYXRpb25zIGFuZCBkaXZpc2lvbnMgYXJlbid0IHN1cHBvcnRlZC5cbiAgICpcbiAgICogVmFsaWQgZXhhbXBsZXMgYXJlOlxuICAgKiBgYGBcbiAgICogMTBcbiAgICogJzEwJSdcbiAgICogJzEwLCAxMCdcbiAgICogJzEwJSwgMTAnXG4gICAqICcxMCArIDEwJSdcbiAgICogJzEwIC0gNXZoICsgMyUnXG4gICAqICctMTBweCArIDV2aCwgNXB4IC0gNiUnXG4gICAqIGBgYFxuICAgKiA+ICoqTkIqKjogSWYgeW91IGRlc2lyZSB0byBhcHBseSBvZmZzZXRzIHRvIHlvdXIgcG9wcGVycyBpbiBhIHdheSB0aGF0IG1heSBtYWtlIHRoZW0gb3ZlcmxhcFxuICAgKiA+IHdpdGggdGhlaXIgcmVmZXJlbmNlIGVsZW1lbnQsIHVuZm9ydHVuYXRlbHksIHlvdSB3aWxsIGhhdmUgdG8gZGlzYWJsZSB0aGUgYGZsaXBgIG1vZGlmaWVyLlxuICAgKiA+IFlvdSBjYW4gcmVhZCBtb3JlIG9uIHRoaXMgYXQgdGhpcyBbaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9GZXpWcmFzdGEvcG9wcGVyLmpzL2lzc3Vlcy8zNzMpLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgb2Zmc2V0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTIwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMjAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogb2Zmc2V0LFxuICAgIC8qKiBAcHJvcCB7TnVtYmVyfFN0cmluZ30gb2Zmc2V0PTBcbiAgICAgKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAgICAgKi9cbiAgICBvZmZzZXQ6IDAsXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gcHJldmVudCB0aGUgcG9wcGVyIGZyb20gYmVpbmcgcG9zaXRpb25lZCBvdXRzaWRlIHRoZSBib3VuZGFyeS5cbiAgICpcbiAgICogQSBzY2VuYXJpbyBleGlzdHMgd2hlcmUgdGhlIHJlZmVyZW5jZSBpdHNlbGYgaXMgbm90IHdpdGhpbiB0aGUgYm91bmRhcmllcy48YnIgLz5cbiAgICogV2UgY2FuIHNheSBpdCBoYXMgXCJlc2NhcGVkIHRoZSBib3VuZGFyaWVzXCIg4oCUIG9yIGp1c3QgXCJlc2NhcGVkXCIuPGJyIC8+XG4gICAqIEluIHRoaXMgY2FzZSB3ZSBuZWVkIHRvIGRlY2lkZSB3aGV0aGVyIHRoZSBwb3BwZXIgc2hvdWxkIGVpdGhlcjpcbiAgICpcbiAgICogLSBkZXRhY2ggZnJvbSB0aGUgcmVmZXJlbmNlIGFuZCByZW1haW4gXCJ0cmFwcGVkXCIgaW4gdGhlIGJvdW5kYXJpZXMsIG9yXG4gICAqIC0gaWYgaXQgc2hvdWxkIGlnbm9yZSB0aGUgYm91bmRhcnkgYW5kIFwiZXNjYXBlIHdpdGggaXRzIHJlZmVyZW5jZVwiXG4gICAqXG4gICAqIFdoZW4gYGVzY2FwZVdpdGhSZWZlcmVuY2VgIGlzIHNldCB0b2B0cnVlYCBhbmQgcmVmZXJlbmNlIGlzIGNvbXBsZXRlbHlcbiAgICogb3V0c2lkZSBpdHMgYm91bmRhcmllcywgdGhlIHBvcHBlciB3aWxsIG92ZXJmbG93IChvciBjb21wbGV0ZWx5IGxlYXZlKVxuICAgKiB0aGUgYm91bmRhcmllcyBpbiBvcmRlciB0byByZW1haW4gYXR0YWNoZWQgdG8gdGhlIGVkZ2Ugb2YgdGhlIHJlZmVyZW5jZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHByZXZlbnRPdmVyZmxvdzoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0zMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDMwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7QXJyYXl9IFtwcmlvcml0eT1bJ2xlZnQnLCdyaWdodCcsJ3RvcCcsJ2JvdHRvbSddXVxuICAgICAqIFBvcHBlciB3aWxsIHRyeSB0byBwcmV2ZW50IG92ZXJmbG93IGZvbGxvd2luZyB0aGVzZSBwcmlvcml0aWVzIGJ5IGRlZmF1bHQsXG4gICAgICogdGhlbiwgaXQgY291bGQgb3ZlcmZsb3cgb24gdGhlIGxlZnQgYW5kIG9uIHRvcCBvZiB0aGUgYGJvdW5kYXJpZXNFbGVtZW50YFxuICAgICAqL1xuICAgIHByaW9yaXR5OiBbJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSddLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIEFtb3VudCBvZiBwaXhlbCB1c2VkIHRvIGRlZmluZSBhIG1pbmltdW0gZGlzdGFuY2UgYmV0d2VlbiB0aGUgYm91bmRhcmllc1xuICAgICAqIGFuZCB0aGUgcG9wcGVyLiBUaGlzIG1ha2VzIHN1cmUgdGhlIHBvcHBlciBhbHdheXMgaGFzIGEgbGl0dGxlIHBhZGRpbmdcbiAgICAgKiBiZXR3ZWVuIHRoZSBlZGdlcyBvZiBpdHMgY29udGFpbmVyXG4gICAgICovXG4gICAgcGFkZGluZzogNSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudD0nc2Nyb2xsUGFyZW50J1xuICAgICAqIEJvdW5kYXJpZXMgdXNlZCBieSB0aGUgbW9kaWZpZXIuIENhbiBiZSBgc2Nyb2xsUGFyZW50YCwgYHdpbmRvd2AsXG4gICAgICogYHZpZXdwb3J0YCBvciBhbnkgRE9NIGVsZW1lbnQuXG4gICAgICovXG4gICAgYm91bmRhcmllc0VsZW1lbnQ6ICdzY3JvbGxQYXJlbnQnLFxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2Ugc3VyZSB0aGUgcmVmZXJlbmNlIGFuZCBpdHMgcG9wcGVyIHN0YXkgbmVhciBlYWNoIG90aGVyXG4gICAqIHdpdGhvdXQgbGVhdmluZyBhbnkgZ2FwIGJldHdlZW4gdGhlIHR3by4gRXNwZWNpYWxseSB1c2VmdWwgd2hlbiB0aGUgYXJyb3cgaXNcbiAgICogZW5hYmxlZCBhbmQgeW91IHdhbnQgdG8gZW5zdXJlIHRoYXQgaXQgcG9pbnRzIHRvIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogSXQgY2FyZXMgb25seSBhYm91dCB0aGUgZmlyc3QgYXhpcy4gWW91IGNhbiBzdGlsbCBoYXZlIHBvcHBlcnMgd2l0aCBtYXJnaW5cbiAgICogYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBrZWVwVG9nZXRoZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NDAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA0MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBrZWVwVG9nZXRoZXIsXG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgbW9kaWZpZXIgaXMgdXNlZCB0byBtb3ZlIHRoZSBgYXJyb3dFbGVtZW50YCBvZiB0aGUgcG9wcGVyIHRvIG1ha2VcbiAgICogc3VyZSBpdCBpcyBwb3NpdGlvbmVkIGJldHdlZW4gdGhlIHJlZmVyZW5jZSBlbGVtZW50IGFuZCBpdHMgcG9wcGVyIGVsZW1lbnQuXG4gICAqIEl0IHdpbGwgcmVhZCB0aGUgb3V0ZXIgc2l6ZSBvZiB0aGUgYGFycm93RWxlbWVudGAgbm9kZSB0byBkZXRlY3QgaG93IG1hbnlcbiAgICogcGl4ZWxzIG9mIGNvbmp1bmN0aW9uIGFyZSBuZWVkZWQuXG4gICAqXG4gICAqIEl0IGhhcyBubyBlZmZlY3QgaWYgbm8gYGFycm93RWxlbWVudGAgaXMgcHJvdmlkZWQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBhcnJvdzoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj01MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDUwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGFycm93LFxuICAgIC8qKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBlbGVtZW50PSdbeC1hcnJvd10nIC0gU2VsZWN0b3Igb3Igbm9kZSB1c2VkIGFzIGFycm93ICovXG4gICAgZWxlbWVudDogJ1t4LWFycm93XScsXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gZmxpcCB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50IHdoZW4gaXQgc3RhcnRzIHRvIG92ZXJsYXAgaXRzXG4gICAqIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGUgYHByZXZlbnRPdmVyZmxvd2AgbW9kaWZpZXIgYmVmb3JlIGl0IGluIG9yZGVyIHRvIHdvcmsuXG4gICAqXG4gICAqICoqTk9URToqKiB0aGlzIG1vZGlmaWVyIHdpbGwgaW50ZXJydXB0IHRoZSBjdXJyZW50IHVwZGF0ZSBjeWNsZSBhbmQgd2lsbFxuICAgKiByZXN0YXJ0IGl0IGlmIGl0IGRldGVjdHMgdGhlIG5lZWQgdG8gZmxpcCB0aGUgcGxhY2VtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgZmxpcDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj02MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDYwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGZsaXAsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xBcnJheX0gYmVoYXZpb3I9J2ZsaXAnXG4gICAgICogVGhlIGJlaGF2aW9yIHVzZWQgdG8gY2hhbmdlIHRoZSBwb3BwZXIncyBwbGFjZW1lbnQuIEl0IGNhbiBiZSBvbmUgb2ZcbiAgICAgKiBgZmxpcGAsIGBjbG9ja3dpc2VgLCBgY291bnRlcmNsb2Nrd2lzZWAgb3IgYW4gYXJyYXkgd2l0aCBhIGxpc3Qgb2YgdmFsaWRcbiAgICAgKiBwbGFjZW1lbnRzICh3aXRoIG9wdGlvbmFsIHZhcmlhdGlvbnMpXG4gICAgICovXG4gICAgYmVoYXZpb3I6ICdmbGlwJyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7bnVtYmVyfSBwYWRkaW5nPTVcbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgZmxpcCBpZiBpdCBoaXRzIHRoZSBlZGdlcyBvZiB0aGUgYGJvdW5kYXJpZXNFbGVtZW50YFxuICAgICAqL1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQ9J3ZpZXdwb3J0J1xuICAgICAqIFRoZSBlbGVtZW50IHdoaWNoIHdpbGwgZGVmaW5lIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBwb3BwZXIgcG9zaXRpb24uXG4gICAgICogVGhlIHBvcHBlciB3aWxsIG5ldmVyIGJlIHBsYWNlZCBvdXRzaWRlIG9mIHRoZSBkZWZpbmVkIGJvdW5kYXJpZXNcbiAgICAgKiAoZXhjZXB0IGlmIGBrZWVwVG9nZXRoZXJgIGlzIGVuYWJsZWQpXG4gICAgICovXG4gICAgYm91bmRhcmllc0VsZW1lbnQ6ICd2aWV3cG9ydCcsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGZsaXBWYXJpYXRpb25zPWZhbHNlXG4gICAgICogVGhlIHBvcHBlciB3aWxsIHN3aXRjaCBwbGFjZW1lbnQgdmFyaWF0aW9uIGJldHdlZW4gYC1zdGFydGAgYW5kIGAtZW5kYCB3aGVuXG4gICAgICogdGhlIHJlZmVyZW5jZSBlbGVtZW50IG92ZXJsYXBzIGl0cyBib3VuZGFyaWVzLlxuICAgICAqXG4gICAgICogVGhlIG9yaWdpbmFsIHBsYWNlbWVudCBzaG91bGQgaGF2ZSBhIHNldCB2YXJpYXRpb24uXG4gICAgICovXG4gICAgZmxpcFZhcmlhdGlvbnM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBmbGlwVmFyaWF0aW9uc0J5Q29udGVudD1mYWxzZVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBzd2l0Y2ggcGxhY2VtZW50IHZhcmlhdGlvbiBiZXR3ZWVuIGAtc3RhcnRgIGFuZCBgLWVuZGAgd2hlblxuICAgICAqIHRoZSBwb3BwZXIgZWxlbWVudCBvdmVybGFwcyBpdHMgcmVmZXJlbmNlIGJvdW5kYXJpZXMuXG4gICAgICpcbiAgICAgKiBUaGUgb3JpZ2luYWwgcGxhY2VtZW50IHNob3VsZCBoYXZlIGEgc2V0IHZhcmlhdGlvbi5cbiAgICAgKi9cbiAgICBmbGlwVmFyaWF0aW9uc0J5Q29udGVudDogZmFsc2UsXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gbWFrZSB0aGUgcG9wcGVyIGZsb3cgdG93YXJkIHRoZSBpbm5lciBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEJ5IGRlZmF1bHQsIHdoZW4gdGhpcyBtb2RpZmllciBpcyBkaXNhYmxlZCwgdGhlIHBvcHBlciB3aWxsIGJlIHBsYWNlZCBvdXRzaWRlXG4gICAqIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGlubmVyOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTcwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNzAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD1mYWxzZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBpbm5lcixcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBoaWRlIHRoZSBwb3BwZXIgd2hlbiBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0c2lkZSBvZiB0aGVcbiAgICogcG9wcGVyIGJvdW5kYXJpZXMuIEl0IHdpbGwgc2V0IGEgYHgtb3V0LW9mLWJvdW5kYXJpZXNgIGF0dHJpYnV0ZSB3aGljaCBjYW5cbiAgICogYmUgdXNlZCB0byBoaWRlIHdpdGggYSBDU1Mgc2VsZWN0b3IgdGhlIHBvcHBlciB3aGVuIGl0cyByZWZlcmVuY2UgaXNcbiAgICogb3V0IG9mIGJvdW5kYXJpZXMuXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoZSBgcHJldmVudE92ZXJmbG93YCBtb2RpZmllciBiZWZvcmUgaXQgaW4gb3JkZXIgdG8gd29yay5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGhpZGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA4MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBoaWRlLFxuICB9LFxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgc3R5bGUgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciBlbGVtZW50IHRvIGdldHNcbiAgICogcHJvcGVybHkgcG9zaXRpb25lZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgbW9kaWZpZXIgd2lsbCBub3QgdG91Y2ggdGhlIERPTSwgaXQganVzdCBwcmVwYXJlcyB0aGUgc3R5bGVzXG4gICAqIHNvIHRoYXQgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGNhbiBhcHBseSBpdC4gVGhpcyBzZXBhcmF0aW9uIGlzIHVzZWZ1bFxuICAgKiBpbiBjYXNlIHlvdSBuZWVkIHRvIHJlcGxhY2UgYGFwcGx5U3R5bGVgIHdpdGggYSBjdXN0b20gaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqIFRoaXMgbW9kaWZpZXIgaGFzIGA4NTBgIGFzIGBvcmRlcmAgdmFsdWUgdG8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgKiB3aXRoIHByZXZpb3VzIHZlcnNpb25zIG9mIFBvcHBlci5qcy4gRXhwZWN0IHRoZSBtb2RpZmllcnMgb3JkZXJpbmcgbWV0aG9kXG4gICAqIHRvIGNoYW5nZSBpbiBmdXR1cmUgbWFqb3IgdmVyc2lvbnMgb2YgdGhlIGxpYnJhcnkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBjb21wdXRlU3R5bGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODUwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA4NTAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBjb21wdXRlU3R5bGUsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGdwdUFjY2VsZXJhdGlvbj10cnVlXG4gICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNEIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtzdHJpbmd9IFt4PSdib3R0b20nXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWCBheGlzIChgYm90dG9tYCBvciBgdG9wYCkuIEFLQSBYIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYGJvdHRvbWBcbiAgICAgKi9cbiAgICB4OiAnYm90dG9tJyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nbGVmdCddXG4gICAgICogV2hlcmUgdG8gYW5jaG9yIHRoZSBZIGF4aXMgKGBsZWZ0YCBvciBgcmlnaHRgKS4gQUtBIFkgb2Zmc2V0IG9yaWdpbi5cbiAgICAgKiBDaGFuZ2UgdGhpcyBpZiB5b3VyIHBvcHBlciBzaG91bGQgZ3JvdyBpbiBhIGRpcmVjdGlvbiBkaWZmZXJlbnQgZnJvbSBgcmlnaHRgXG4gICAgICovXG4gICAgeTogJ3JpZ2h0JyxcbiAgfSxcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgY29tcHV0ZWQgc3R5bGVzIHRvIHRoZSBwb3BwZXIgZWxlbWVudC5cbiAgICpcbiAgICogQWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyBhcmUgbGltaXRlZCB0byB0aGlzIG1vZGlmaWVyLiBUaGlzIGlzIHVzZWZ1bCBpbiBjYXNlXG4gICAqIHlvdSB3YW50IHRvIGludGVncmF0ZSBQb3BwZXIuanMgaW5zaWRlIGEgZnJhbWV3b3JrIG9yIHZpZXcgbGlicmFyeSBhbmQgeW91XG4gICAqIHdhbnQgdG8gZGVsZWdhdGUgYWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyB0byBpdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHlvdSBkaXNhYmxlIHRoaXMgbW9kaWZpZXIsIHlvdSBtdXN0IG1ha2Ugc3VyZSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICogaGFzIGl0cyBwb3NpdGlvbiBzZXQgdG8gYGFic29sdXRlYCBiZWZvcmUgUG9wcGVyLmpzIGNhbiBkbyBpdHMgd29yayFcbiAgICpcbiAgICogSnVzdCBkaXNhYmxlIHRoaXMgbW9kaWZpZXIgYW5kIGRlZmluZSB5b3VyIG93biB0byBhY2hpZXZlIHRoZSBkZXNpcmVkIGVmZmVjdC5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFwcGx5U3R5bGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9OTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA5MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBhcHBseVN0eWxlLFxuICAgIC8qKiBAcHJvcCB7RnVuY3Rpb259ICovXG4gICAgb25Mb2FkOiBhcHBseVN0eWxlT25Mb2FkLFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS4xMC4wLCB0aGUgcHJvcGVydHkgbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXJcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgKiBJZiB0cnVlLCBpdCB1c2VzIHRoZSBDU1MgM0QgdHJhbnNmb3JtYXRpb24gdG8gcG9zaXRpb24gdGhlIHBvcHBlci5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHVuZGVmaW5lZCxcbiAgfSxcbn07XG5cbi8qKlxuICogVGhlIGBkYXRhT2JqZWN0YCBpcyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIGluZm9ybWF0aW9uIHVzZWQgYnkgUG9wcGVyLmpzLlxuICogVGhpcyBvYmplY3QgaXMgcGFzc2VkIHRvIG1vZGlmaWVycyBhbmQgdG8gdGhlIGBvbkNyZWF0ZWAgYW5kIGBvblVwZGF0ZWAgY2FsbGJhY2tzLlxuICogQG5hbWUgZGF0YU9iamVjdFxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuaW5zdGFuY2UgVGhlIFBvcHBlci5qcyBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGRhdGEucGxhY2VtZW50IFBsYWNlbWVudCBhcHBsaWVkIHRvIHBvcHBlclxuICogQHByb3BlcnR5IHtTdHJpbmd9IGRhdGEub3JpZ2luYWxQbGFjZW1lbnQgUGxhY2VtZW50IG9yaWdpbmFsbHkgZGVmaW5lZCBvbiBpbml0XG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRhdGEuZmxpcHBlZCBUcnVlIGlmIHBvcHBlciBoYXMgYmVlbiBmbGlwcGVkIGJ5IGZsaXAgbW9kaWZpZXJcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGF0YS5oaWRlIFRydWUgaWYgdGhlIHJlZmVyZW5jZSBlbGVtZW50IGlzIG91dCBvZiBib3VuZGFyaWVzLCB1c2VmdWwgdG8ga25vdyB3aGVuIHRvIGhpZGUgdGhlIHBvcHBlclxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gZGF0YS5hcnJvd0VsZW1lbnQgTm9kZSB1c2VkIGFzIGFycm93IGJ5IGFycm93IG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5zdHlsZXMgQW55IENTUyBwcm9wZXJ0eSBkZWZpbmVkIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIuIEl0IGV4cGVjdHMgdGhlIEphdmFTY3JpcHQgbm9tZW5jbGF0dXJlIChlZy4gYG1hcmdpbkJvdHRvbWApXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5hcnJvd1N0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciBhcnJvdy4gSXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmJvdW5kYXJpZXMgT2Zmc2V0cyBvZiB0aGUgcG9wcGVyIGJvdW5kYXJpZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMgVGhlIG1lYXN1cmVtZW50cyBvZiBwb3BwZXIsIHJlZmVyZW5jZSBhbmQgYXJyb3cgZWxlbWVudHNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucG9wcGVyIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgYHRvcGAsIGBsZWZ0YCwgYHdpZHRoYCwgYGhlaWdodGAgdmFsdWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLmFycm93XSBgdG9wYCBhbmQgYGxlZnRgIG9mZnNldHMsIG9ubHkgb25lIG9mIHRoZW0gd2lsbCBiZSBkaWZmZXJlbnQgZnJvbSAwXG4gKi9cbiIsImltcG9ydCBtb2RpZmllcnMgZnJvbSAnLi4vbW9kaWZpZXJzL2luZGV4JztcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgcHJvdmlkZWQgdG8gUG9wcGVyLmpzIGNvbnN0cnVjdG9yLjxiciAvPlxuICogVGhlc2UgY2FuIGJlIG92ZXJyaWRkZW4gdXNpbmcgdGhlIGBvcHRpb25zYCBhcmd1bWVudCBvZiBQb3BwZXIuanMuPGJyIC8+XG4gKiBUbyBvdmVycmlkZSBhbiBvcHRpb24sIHNpbXBseSBwYXNzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lXG4gKiBzdHJ1Y3R1cmUgb2YgdGhlIGBvcHRpb25zYCBvYmplY3QsIGFzIHRoZSAzcmQgYXJndW1lbnQuIEZvciBleGFtcGxlOlxuICogYGBgXG4gKiBuZXcgUG9wcGVyKHJlZiwgcG9wLCB7XG4gKiAgIG1vZGlmaWVyczoge1xuICogICAgIHByZXZlbnRPdmVyZmxvdzogeyBlbmFibGVkOiBmYWxzZSB9XG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLyoqXG4gICAqIFBvcHBlcidzIHBsYWNlbWVudC5cbiAgICogQHByb3Age1BvcHBlci5wbGFjZW1lbnRzfSBwbGFjZW1lbnQ9J2JvdHRvbSdcbiAgICovXG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG5cbiAgLyoqXG4gICAqIFNldCB0aGlzIHRvIHRydWUgaWYgeW91IHdhbnQgcG9wcGVyIHRvIHBvc2l0aW9uIGl0IHNlbGYgaW4gJ2ZpeGVkJyBtb2RlXG4gICAqIEBwcm9wIHtCb29sZWFufSBwb3NpdGlvbkZpeGVkPWZhbHNlXG4gICAqL1xuICBwb3NpdGlvbkZpeGVkOiBmYWxzZSxcblxuICAvKipcbiAgICogV2hldGhlciBldmVudHMgKHJlc2l6ZSwgc2Nyb2xsKSBhcmUgaW5pdGlhbGx5IGVuYWJsZWQuXG4gICAqIEBwcm9wIHtCb29sZWFufSBldmVudHNFbmFibGVkPXRydWVcbiAgICovXG4gIGV2ZW50c0VuYWJsZWQ6IHRydWUsXG5cbiAgLyoqXG4gICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgcmVtb3ZlIHRoZSBwb3BwZXIgd2hlblxuICAgKiB5b3UgY2FsbCB0aGUgYGRlc3Ryb3lgIG1ldGhvZC5cbiAgICogQHByb3Age0Jvb2xlYW59IHJlbW92ZU9uRGVzdHJveT1mYWxzZVxuICAgKi9cbiAgcmVtb3ZlT25EZXN0cm95OiBmYWxzZSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyBjcmVhdGVkLjxiciAvPlxuICAgKiBCeSBkZWZhdWx0LCBpdCBpcyBzZXQgdG8gbm8tb3AuPGJyIC8+XG4gICAqIEFjY2VzcyBQb3BwZXIuanMgaW5zdGFuY2Ugd2l0aCBgZGF0YS5pbnN0YW5jZWAuXG4gICAqIEBwcm9wIHtvbkNyZWF0ZX1cbiAgICovXG4gIG9uQ3JlYXRlOiAoKSA9PiB7fSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyB1cGRhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5vdCBjYWxsZWRcbiAgICogb24gdGhlIGluaXRpYWxpemF0aW9uL2NyZWF0aW9uIG9mIHRoZSBwb3BwZXIsIGJ1dCBvbmx5IG9uIHN1YnNlcXVlbnRcbiAgICogdXBkYXRlcy48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXQgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25VcGRhdGV9XG4gICAqL1xuICBvblVwZGF0ZTogKCkgPT4ge30sXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgbW9kaWZpZXJzIHVzZWQgdG8gbW9kaWZ5IHRoZSBvZmZzZXRzIGJlZm9yZSB0aGV5IGFyZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIuXG4gICAqIFRoZXkgcHJvdmlkZSBtb3N0IG9mIHRoZSBmdW5jdGlvbmFsaXRpZXMgb2YgUG9wcGVyLmpzLlxuICAgKiBAcHJvcCB7bW9kaWZpZXJzfVxuICAgKi9cbiAgbW9kaWZpZXJzLFxufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgb25DcmVhdGVcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIG9uVXBkYXRlXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqL1xuIiwiLy8gVXRpbHNcbmltcG9ydCBkZWJvdW5jZSBmcm9tICcuL3V0aWxzL2RlYm91bmNlJztcbmltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4vdXRpbHMvaXNGdW5jdGlvbic7XG5cbi8vIE1ldGhvZHNcbmltcG9ydCB1cGRhdGUgZnJvbSAnLi9tZXRob2RzL3VwZGF0ZSc7XG5pbXBvcnQgZGVzdHJveSBmcm9tICcuL21ldGhvZHMvZGVzdHJveSc7XG5pbXBvcnQgZW5hYmxlRXZlbnRMaXN0ZW5lcnMgZnJvbSAnLi9tZXRob2RzL2VuYWJsZUV2ZW50TGlzdGVuZXJzJztcbmltcG9ydCBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMgZnJvbSAnLi9tZXRob2RzL2Rpc2FibGVFdmVudExpc3RlbmVycyc7XG5pbXBvcnQgRGVmYXVsdHMgZnJvbSAnLi9tZXRob2RzL2RlZmF1bHRzJztcbmltcG9ydCBwbGFjZW1lbnRzIGZyb20gJy4vbWV0aG9kcy9wbGFjZW1lbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9wcGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUG9wcGVyLmpzIGluc3RhbmNlLlxuICAgKiBAY2xhc3MgUG9wcGVyXG4gICAqIEBwYXJhbSB7RWxlbWVudHxyZWZlcmVuY2VPYmplY3R9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXIgLSBUaGUgSFRNTCAvIFhNTCBlbGVtZW50IHVzZWQgYXMgdGhlIHBvcHBlclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFlvdXIgY3VzdG9tIG9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIG9uZXMgZGVmaW5lZCBpbiBbRGVmYXVsdHNdKCNkZWZhdWx0cylcbiAgICogQHJldHVybiB7T2JqZWN0fSBpbnN0YW5jZSAtIFRoZSBnZW5lcmF0ZWQgUG9wcGVyLmpzIGluc3RhbmNlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gbWFrZSB1cGRhdGUoKSBkZWJvdW5jZWQsIHNvIHRoYXQgaXQgb25seSBydW5zIGF0IG1vc3Qgb25jZS1wZXItdGlja1xuICAgIHRoaXMudXBkYXRlID0gZGVib3VuY2UodGhpcy51cGRhdGUuYmluZCh0aGlzKSk7XG5cbiAgICAvLyB3aXRoIHt9IHdlIGNyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgb3B0aW9ucyBpbnNpZGUgaXRcbiAgICB0aGlzLm9wdGlvbnMgPSB7IC4uLlBvcHBlci5EZWZhdWx0cywgLi4ub3B0aW9ucyB9O1xuXG4gICAgLy8gaW5pdCBzdGF0ZVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpc0Rlc3Ryb3llZDogZmFsc2UsXG4gICAgICBpc0NyZWF0ZWQ6IGZhbHNlLFxuICAgICAgc2Nyb2xsUGFyZW50czogW10sXG4gICAgfTtcblxuICAgIC8vIGdldCByZWZlcmVuY2UgYW5kIHBvcHBlciBlbGVtZW50cyAoYWxsb3cgalF1ZXJ5IHdyYXBwZXJzKVxuICAgIHRoaXMucmVmZXJlbmNlID0gcmVmZXJlbmNlICYmIHJlZmVyZW5jZS5qcXVlcnkgPyByZWZlcmVuY2VbMF0gOiByZWZlcmVuY2U7XG4gICAgdGhpcy5wb3BwZXIgPSBwb3BwZXIgJiYgcG9wcGVyLmpxdWVyeSA/IHBvcHBlclswXSA6IHBvcHBlcjtcblxuICAgIC8vIERlZXAgbWVyZ2UgbW9kaWZpZXJzIG9wdGlvbnNcbiAgICB0aGlzLm9wdGlvbnMubW9kaWZpZXJzID0ge307XG4gICAgT2JqZWN0LmtleXMoe1xuICAgICAgLi4uUG9wcGVyLkRlZmF1bHRzLm1vZGlmaWVycyxcbiAgICAgIC4uLm9wdGlvbnMubW9kaWZpZXJzLFxuICAgIH0pLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICB0aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdID0ge1xuICAgICAgICAvLyBJZiBpdCdzIGEgYnVpbHQtaW4gbW9kaWZpZXIsIHVzZSBpdCBhcyBiYXNlXG4gICAgICAgIC4uLihQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzW25hbWVdIHx8IHt9KSxcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGN1c3RvbSBvcHRpb25zLCBvdmVycmlkZSBhbmQgbWVyZ2Ugd2l0aCBkZWZhdWx0IG9uZXNcbiAgICAgICAgLi4uKG9wdGlvbnMubW9kaWZpZXJzID8gb3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gOiB7fSksXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gUmVmYWN0b3JpbmcgbW9kaWZpZXJzJyBsaXN0IChPYmplY3QgPT4gQXJyYXkpXG4gICAgdGhpcy5tb2RpZmllcnMgPSBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMubW9kaWZpZXJzKVxuICAgICAgLm1hcChuYW1lID0+ICh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIC4uLnRoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0sXG4gICAgICB9KSlcbiAgICAgIC8vIHNvcnQgdGhlIG1vZGlmaWVycyBieSBvcmRlclxuICAgICAgLnNvcnQoKGEsIGIpID0+IGEub3JkZXIgLSBiLm9yZGVyKTtcblxuICAgIC8vIG1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgd2hlbiBQb3BwZXIuanMgZ2V0IGluaXRlZFxuICAgIC8vIHN1Y2ggY29kZSBpcyBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBvZiBpdHMgbW9kaWZpZXJcbiAgICAvLyB0aGV5IGNvdWxkIGFkZCBuZXcgcHJvcGVydGllcyB0byB0aGVpciBvcHRpb25zIGNvbmZpZ3VyYXRpb25cbiAgICAvLyBCRSBBV0FSRTogZG9uJ3QgYWRkIG9wdGlvbnMgdG8gYG9wdGlvbnMubW9kaWZpZXJzLm5hbWVgIGJ1dCB0byBgbW9kaWZpZXJPcHRpb25zYCFcbiAgICB0aGlzLm1vZGlmaWVycy5mb3JFYWNoKG1vZGlmaWVyT3B0aW9ucyA9PiB7XG4gICAgICBpZiAobW9kaWZpZXJPcHRpb25zLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihtb2RpZmllck9wdGlvbnMub25Mb2FkKSkge1xuICAgICAgICBtb2RpZmllck9wdGlvbnMub25Mb2FkKFxuICAgICAgICAgIHRoaXMucmVmZXJlbmNlLFxuICAgICAgICAgIHRoaXMucG9wcGVyLFxuICAgICAgICAgIHRoaXMub3B0aW9ucyxcbiAgICAgICAgICBtb2RpZmllck9wdGlvbnMsXG4gICAgICAgICAgdGhpcy5zdGF0ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZmlyZSB0aGUgZmlyc3QgdXBkYXRlIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIgaW4gdGhlIHJpZ2h0IHBsYWNlXG4gICAgdGhpcy51cGRhdGUoKTtcblxuICAgIGNvbnN0IGV2ZW50c0VuYWJsZWQgPSB0aGlzLm9wdGlvbnMuZXZlbnRzRW5hYmxlZDtcbiAgICBpZiAoZXZlbnRzRW5hYmxlZCkge1xuICAgICAgLy8gc2V0dXAgZXZlbnQgbGlzdGVuZXJzLCB0aGV5IHdpbGwgdGFrZSBjYXJlIG9mIHVwZGF0ZSB0aGUgcG9zaXRpb24gaW4gc3BlY2lmaWMgc2l0dWF0aW9uc1xuICAgICAgdGhpcy5lbmFibGVFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCA9IGV2ZW50c0VuYWJsZWQ7XG4gIH1cblxuICAvLyBXZSBjYW4ndCB1c2UgY2xhc3MgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgZG9uJ3QgZ2V0IGxpc3RlZCBpbiB0aGVcbiAgLy8gY2xhc3MgcHJvdG90eXBlIGFuZCBicmVhayBzdHVmZiBsaWtlIFNpbm9uIHN0dWJzXG4gIHVwZGF0ZSgpIHtcbiAgICByZXR1cm4gdXBkYXRlLmNhbGwodGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICByZXR1cm4gZGVzdHJveS5jYWxsKHRoaXMpO1xuICB9XG4gIGVuYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHJldHVybiBlbmFibGVFdmVudExpc3RlbmVycy5jYWxsKHRoaXMpO1xuICB9XG4gIGRpc2FibGVFdmVudExpc3RlbmVycygpIHtcbiAgICByZXR1cm4gZGlzYWJsZUV2ZW50TGlzdGVuZXJzLmNhbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogU2NoZWR1bGVzIGFuIHVwZGF0ZS4gSXQgd2lsbCBydW4gb24gdGhlIG5leHQgVUkgdXBkYXRlIGF2YWlsYWJsZS5cbiAgICogQG1ldGhvZCBzY2hlZHVsZVVwZGF0ZVxuICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAqL1xuICBzY2hlZHVsZVVwZGF0ZSA9ICgpID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZSk7XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgdXRpbGl0aWVzIHVzZWZ1bCB3aGVuIHdyaXRpbmcgY3VzdG9tIG1vZGlmaWVycy5cbiAgICogU3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDEuNywgdGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIG9ubHkgaWYgeW91XG4gICAqIGluY2x1ZGUgYHBvcHBlci11dGlscy5qc2AgYmVmb3JlIGBwb3BwZXIuanNgLlxuICAgKlxuICAgKiAqKkRFUFJFQ0FUSU9OKio6IFRoaXMgd2F5IHRvIGFjY2VzcyBQb3BwZXJVdGlscyBpcyBkZXByZWNhdGVkXG4gICAqIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdjIhIFVzZSB0aGUgUG9wcGVyVXRpbHMgbW9kdWxlIGRpcmVjdGx5IGluc3RlYWQuXG4gICAqIER1ZSB0byB0aGUgaGlnaCBpbnN0YWJpbGl0eSBvZiB0aGUgbWV0aG9kcyBjb250YWluZWQgaW4gVXRpbHMsIHdlIGNhbid0XG4gICAqIGd1YXJhbnRlZSB0aGVtIHRvIGZvbGxvdyBzZW12ZXIuIFVzZSB0aGVtIGF0IHlvdXIgb3duIHJpc2shXG4gICAqIEBzdGF0aWNcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjhcbiAgICogQG1lbWJlciBVdGlsc1xuICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAqL1xuICBzdGF0aWMgVXRpbHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpLlBvcHBlclV0aWxzO1xuXG4gIHN0YXRpYyBwbGFjZW1lbnRzID0gcGxhY2VtZW50cztcblxuICBzdGF0aWMgRGVmYXVsdHMgPSBEZWZhdWx0cztcbn1cblxuLyoqXG4gKiBUaGUgYHJlZmVyZW5jZU9iamVjdGAgaXMgYW4gb2JqZWN0IHRoYXQgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGNvbXBhdGlibGUgd2l0aCBQb3BwZXIuanNcbiAqIGFuZCBsZXRzIHlvdSB1c2UgaXQgYXMgcmVwbGFjZW1lbnQgb2YgYSByZWFsIERPTSBub2RlLjxiciAvPlxuICogWW91IGNhbiB1c2UgdGhpcyBtZXRob2QgdG8gcG9zaXRpb24gYSBwb3BwZXIgcmVsYXRpdmVseSB0byBhIHNldCBvZiBjb29yZGluYXRlc1xuICogaW4gY2FzZSB5b3UgZG9uJ3QgaGF2ZSBhIERPTSBub2RlIHRvIHVzZSBhcyByZWZlcmVuY2UuXG4gKlxuICogYGBgXG4gKiBuZXcgUG9wcGVyKHJlZmVyZW5jZU9iamVjdCwgcG9wcGVyTm9kZSk7XG4gKiBgYGBcbiAqXG4gKiBOQjogVGhpcyBmZWF0dXJlIGlzbid0IHN1cHBvcnRlZCBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMC5cbiAqIEBuYW1lIHJlZmVyZW5jZU9iamVjdFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZGF0YS5nZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2V0IG9mIGNvb3JkaW5hdGVzIGNvbXBhdGlibGUgd2l0aCB0aGUgbmF0aXZlIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgIG1ldGhvZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudFdpZHRoXG4gKiBBbiBFUzYgZ2V0dGVyIHRoYXQgd2lsbCByZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSB2aXJ0dWFsIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGEuY2xpZW50SGVpZ2h0XG4gKiBBbiBFUzYgZ2V0dGVyIHRoYXQgd2lsbCByZXR1cm4gdGhlIGhlaWdodCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqL1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwiaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbmltcG9ydCAnYm9vdHN0cmFwJzsgLy8gaidpbXBvcnRlIGJvb3RzdHJhcC5qcyBkZXB1aXMgbm9kZV9tb2R1bGVzXG5pbXBvcnQgb3dsQ2Fyb3VzZWwgZnJvbSAnb3dsLmNhcm91c2VsJztcblxuXG5cblxuJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24gKCkge1xuXG4gIHZhciBqc19hY2NvcmRpb24gPSAkKFwiLmpzLWFjY29yZGlvblwiKSxcbiAgICBjb2xsYXBzZV90cmlnZ2VyID0ganNfYWNjb3JkaW9uLmZpbmQoXCIuYnRuLWxpbmtcIik7XG4gIGlmIChqc19hY2NvcmRpb24ubGVuZ3RoID4gMCkge1xuICAgIC8vICAgT3BlbiBmaXJzdCBhY2NvcmRpb24gYnkgZGVmYXVsdFxuICAgIGpzX2FjY29yZGlvblxuICAgICAgLmZpbmQoXCIuY2FyZFwiKVxuICAgICAgLmZpcnN0KClcbiAgICAgIC5maW5kKFwiLmNvbGxhcHNlXCIpXG4gICAgICAuY3NzKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuXG4gICAgLy8gICBBZGQgY2xhc3MgZXhwYW5kZWQgb24gZmlyc3QgYWNjb3JkaW9uIGJ5IGRlZmF1bHRcbiAgICBqc19hY2NvcmRpb25cbiAgICAgIC5maW5kKFwiLmNhcmRcIilcbiAgICAgIC5maXJzdCgpXG4gICAgICAuZmluZChcIi5idG4tbGlua1wiKVxuICAgICAgLmFkZENsYXNzKFwiZXhwYW5kZWRcIik7XG5cbiAgICAvLyAgIGNsaWNrIGV2ZW50IGZvciBhY2NvcmRpb25cbiAgICBjb2xsYXBzZV90cmlnZ2VyLmNsaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGN1cnJlbnRDb2xsYXBzZSA9ICQodGhpcylcbiAgICAgICAgICAuY2xvc2VzdChcIi5jYXJkXCIpXG4gICAgICAgICAgLmZpbmQoXCIuY29sbGFwc2VcIiksXG4gICAgICAgIHJlbWFpbmluZ0NvbGxhcHNlID0gJCh0aGlzKVxuICAgICAgICAgIC5jbG9zZXN0KGpzX2FjY29yZGlvbilcbiAgICAgICAgICAuZmluZChcIi5jb2xsYXBzZVwiKVxuICAgICAgICAgIC5ub3QoY3VycmVudENvbGxhcHNlKSxcbiAgICAgICAgcmVtYWluaW5nQnRuID0gJCh0aGlzKVxuICAgICAgICAgIC5jbG9zZXN0KGpzX2FjY29yZGlvbilcbiAgICAgICAgICAuZmluZChcIi5idG4tbGlua1wiKVxuICAgICAgICAgIC5ub3QodGhpcyk7XG4gICAgICBcbiAgICAvLyAgICAgdG9nZ2xlIHRoZSBjbGlja2VkIGFjY29yZGlvblxuICAgICAgY3VycmVudENvbGxhcHNlLnNsaWRlVG9nZ2xlKCk7XG4gICAgICAkKHRoaXMpLnRvZ2dsZUNsYXNzKFwiZXhwYW5kZWRcIik7XG4gICAgICBcbiAgICAvLyAgICAgY2xvc2UgYWxsIG90aGVyIGFjY29yZGlvbiBpZiBhbnkuXG4gICAgICByZW1haW5pbmdDb2xsYXBzZS5zbGlkZVVwKCk7XG4gICAgICByZW1haW5pbmdCdG4ucmVtb3ZlQ2xhc3MoXCJleHBhbmRlZFwiKTtcbiAgICB9KTtcbiAgfVxuXG5cblxuICAkKFwiLmNhcm91c2VsX3BhcnRlbmFpcmVzXCIpLm93bENhcm91c2VsKHtcbiAgICBpdGVtczogMyxcbiAgICBsb29wOiB0cnVlLFxuICAgIG1hcmdpbjogMzAsXG4gICAgbmF2OiB0cnVlLFxuICAgIG5hdlRleHQ6IFsnPGkgY2xhc3M9XCJmYSBmYS1jaGV2cm9uLWxlZnQgZmEtMnhcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+JywnPGkgY2xhc3M9XCJmYSBmYS1jaGV2cm9uLXJpZ2h0IGZhLTJ4XCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPiddLFxuICAgIHJlc3BvbnNpdmU6e1xuICAgICAgMDp7XG4gICAgICAgICAgaXRlbXM6MVxuICAgICAgfSxcbiAgICAgIDc2ODp7XG4gICAgICAgICAgaXRlbXM6MlxuICAgICAgfSxcbiAgICAgIDk5Mjp7XG4gICAgICAgICAgaXRlbXM6M1xuICAgICAgfVxuICAgIH0gXG4gIH0pO1xuXG5cbn0pOyIsIm1vZHVsZS5leHBvcnRzID0galF1ZXJ5OyJdLCJzb3VyY2VSb290IjoiIn0=